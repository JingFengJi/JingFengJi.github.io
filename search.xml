<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Unity编辑器拓展之三十五:如何在Editor下使用单例ScriptableObject]]></title>
    <url>%2F2020%2F11%2F05%2Funity-bian-ji-qi-tuo-zhan-zhi-san-shi-wu-ru-he-zai-editor-xia-shi-yong-dan-li-scriptableobject%2F</url>
    <content type="text"><![CDATA[本文介绍在Editor下使用单例ScriptableObject ScriptableSingleton GUI官方文档click here! Unity FilePathAttribute官方文档click here! 前言相信大家都用过ScriptableObject（以下简称so），这里不过多介绍它了，不过关于ScriptableSingleton，可能就用的不多了，上面有官方文档链接。ScriptableSingleton就是一个单例的so。最近在整理项目中开发的工具，准备集合成一个方便移植的工具库，为了更抽象、可移植性更强，有些工具就得抽象出一个配置文件出来，关于这类配置文件，各个项目可能又不一样，所以这类文件就不适合放在工具库内部。放在工程内、工具库以外是比较合适的做法。那么问题在于，工具库里的工具如何拿到这个配置文件呢？（当然如果配置文件不使用so，也无所谓啦） 正文可行的方案思考出来两种： 1、定义一个FilePathAttribute（并不是指Unity2020提供的那个），在工具外部定义一个FilePathAttribute的字段指定路径，工具内部通过这个Attribute拿到对应的配置文件路径。2、使用ScriptableSingleton 第一种方案这里就不演示了，这个方案其实是从GF框架从学习来的，可以参见GF框架的ResourceEditorConfigPathAttribute。 第二种方案是Unity提供的方案，如何使用具体参考上面的官方文档。这里介绍下使用时候的坑！！！ 以下测试环境Unity2019.4.2f1。 1、新建一个单例so 1234567using UnityEditor;public class TestScriptableObjectSingleton : ScriptableSingleton&lt;TestScriptableObjectSingleton&gt;&#123; public string UserName; public int Age;&#125; 2、新建一个测试读写上面so的代码 123456789101112131415161718192021using UnityEditor;namespace Editor&#123; public class TestLoadSo &#123; [MenuItem("Tools/Read")] public static void Read() &#123; UnityEngine.Debug.LogError(TestScriptableObjectSingleton.instance.UserName); UnityEngine.Debug.LogError(TestScriptableObjectSingleton.instance.Age); &#125; [MenuItem("Tools/Write")] public static void Write() &#123; TestScriptableObjectSingleton.instance.UserName = "user_name"; TestScriptableObjectSingleton.instance.Age = 18; &#125; &#125;&#125; 3、测试gif图 从图上看很正常对吧？写入的数据也能正常的读出来。。。但是，重启Unity后，再执行以下Tool/Read，数据没了，因为Unity内部创建的单例so是不会帮我们保存的。 在访问instance的时候，如果instance为空，会调用一下CreateAndLoad。 然后会通过FilePathAttribute找到该类型定义的文件路径，然而，该FilePathAttribute是internal的，从目前了解来看，直到2020版本，FilePathAttribute才公开。 既然无法使用FilePathAttribute，如果我们自己创建一个该类型的so，那么只会报错存在多个，因为它内部压根就无法找到自定义的那个so，更别提instance能够引用到它了。 解决方案解决方案就是自己写，毕竟项目现在上不了2020。。。 其实啰嗦这么半天，Editor下单例的so写起来就那么点代码，只不过啰嗦下Unity的坑吧。。。 直接上代码了。 123456789101112131415161718192021222324252627282930using UnityEditor;using UnityEngine;public class ScriptableObjectSingleton&lt;T&gt; : ScriptableObject where T : ScriptableObject&#123; private static T s_Instance; public static T Instance &#123; get &#123; if (s_Instance == null) &#123; string[] findAssets = AssetDatabase.FindAssets($"t:&#123;typeof(T).Name&#125;"); if (findAssets == null || findAssets.Length == 0) &#123; Debug.LogError($"Please create ScriptableObject typeof &#123;typeof(T)&#125; first..."); &#125; else if (findAssets.Length &gt; 1) &#123; Debug.LogError($"ScriptableObject typeof &#123;typeof(T)&#125; exist multiple，please check they..."); &#125; else &#123; s_Instance = AssetDatabase.LoadAssetAtPath&lt;T&gt;(AssetDatabase.GUIDToAssetPath(findAssets[0])); &#125; &#125; return s_Instance; &#125; &#125;&#125; 12345678using UnityEditor;using UnityEngine;[CreateAssetMenu(menuName = "ScriptableObjectSingletonTest")]public class ScriptableObjectSingletonTest : ScriptableObjectSingleton&lt;ScriptableObjectSingletonTest&gt;&#123; public string UserName; public int Age;&#125; 本篇文章，如果有不懂，欢迎留言~click here! 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。如果有不懂，欢迎留言评论!]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>ScriptableSingleton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之三十四:在ShaderEditor中添加ToolTip]]></title>
    <url>%2F2020%2F10%2F24%2Funity-bian-ji-qi-tuo-zhan-zhi-san-shi-si-zai-shadereditor-zhong-tian-jia-tooltip%2F</url>
    <content type="text"><![CDATA[本文介绍在ShaderEditor中添加ToolTip字段提示。 Custom Shader GUI官方文档click here! 前言最近群里群友咨询如何给Shader Vector类型的参数添加ToolTip。 MaterialEditor中跟Vector有关的只有VectorProperty函数 然而两个重载均没有提供传入ToolTip或者GUIContent的参数，目前从文档来看ColorProperty、FloatProperty默认没有提供ToolTip支持，MaterialEditor.TextureProperty中倒是支持传入ToolTip。 接下来翻一翻MaterialEditor的源码 最终VectorProperty的函数实现如下图： 可见，参数只支持一个string类型的lable，但是！！！EditorGUI.Vector4Field明明是支持传入GUIContent的(🤔🤔🤔 Unity 你想干嘛？？？) 再来看看内部的默认ShaderProperty函数：DefaultShaderPropertyInternal 这个函数明明是传的GUIContent！！！为什么在调用TextureProperty和VectorProperty的时候，你又只用了GUIContent的text，抛弃了ToolTip🤣🤣🤣（Unity，我跟你讲，你不要搞事情啊） 正文接下来上代码支持各类型Property的ToolTip。先反射DefaultShaderPropertyInternal函数，由于该函数里不支持TextureProperty和VectorProperty的ToolTip，需要额外做些事。 TextureProperty有个重载支持传入ToolTip的，只是DefaultShaderPropertyInternal里没用而已。 定义一个ToolTipDrawer继承至MaterialPropertyDrawer。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576using System;using System.Reflection;using UnityEditor;using UnityEngine;public class ToolTipDrawer : MaterialPropertyDrawer&#123; private GUIContent _guiContent; private MethodInfo _internalMethod; private Type[] _methodArgumentTypes; private object[] _methodArguments; private MethodInfo _getPropertyRectMethodInfo; private object[] _getPropertyRectMethodInfoArguments; public ToolTipDrawer(string tooltip) &#123; _guiContent = new GUIContent(string.Empty, tooltip); _methodArgumentTypes = new[] &#123;typeof(Rect), typeof(MaterialProperty), typeof(GUIContent)&#125;; _methodArguments = new object[3]; _internalMethod = typeof(MaterialEditor) .GetMethod("DefaultShaderPropertyInternal", BindingFlags.Instance | BindingFlags.NonPublic, null, _methodArgumentTypes, null); _getPropertyRectMethodInfo = typeof(MaterialEditor).GetMethod("GetPropertyRect", BindingFlags.Instance | BindingFlags.NonPublic, null, new[] &#123;typeof(MaterialProperty), typeof(string), typeof(bool)&#125;, null); _getPropertyRectMethodInfoArguments = new object[3]; &#125; //拷贝至https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/Inspector/MaterialEditor.cs private Vector4 VectorProperty(Rect position, MaterialProperty prop, GUIContent content) &#123; EditorGUI.BeginChangeCheck(); EditorGUI.showMixedValue = prop.hasMixedValue; var oldLabelWidth = EditorGUIUtility.labelWidth; EditorGUIUtility.labelWidth = 0f; //修改拷贝出来的函数，修改函数参数和以下content Vector4 newValue = EditorGUI.Vector4Field(position, content, prop.vectorValue); EditorGUIUtility.labelWidth = oldLabelWidth; EditorGUI.showMixedValue = false; if (EditorGUI.EndChangeCheck()) prop.vectorValue = newValue; return prop.vectorValue; &#125; public override void OnGUI(Rect position, MaterialProperty prop, String label, MaterialEditor editor) &#123; _guiContent.text = label; if (prop.type == MaterialProperty.PropType.Vector) &#123; VectorProperty(position, prop, _guiContent); &#125; else if (prop.type == MaterialProperty.PropType.Texture) &#123; bool scaleOffset = (prop.flags &amp; MaterialProperty.PropFlags.NoScaleOffset) == 0; _getPropertyRectMethodInfoArguments[0] = prop; _getPropertyRectMethodInfoArguments[1] = label; _getPropertyRectMethodInfoArguments[2] = true; Rect r = (Rect)_getPropertyRectMethodInfo.Invoke(editor,_getPropertyRectMethodInfoArguments); editor.TextureProperty(r, prop, _guiContent.text, _guiContent.tooltip, scaleOffset); &#125; else &#123; //其余几个类型，默认就支持 if (_internalMethod != null) &#123; _methodArguments[0] = position; _methodArguments[1] = prop; _methodArguments[2] = _guiContent; _internalMethod.Invoke(editor, _methodArguments); &#125; &#125; &#125;&#125; 再定义一个测试的Shader 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Shader "Custom/TestToolTip"&#123; Properties &#123; [ToolTip(This is MainTex)] _Texture ("Texture", 2D) = "white" &#123;&#125; [ToolTip(This is Range)] _Range("Range", Range(0, 1)) = 0.02 [ToolTip(This is Color)] _Color("Color", Color) = (1,1,1,1) [ToolTip(This is Float)] _Float("Float", Float) = 8 [ToolTip(This is Vector)] _Vector("Vector", Vector) = (1,1,1,1) &#125; SubShader &#123; Tags &#123; "RenderType"="Opaque" &#125; LOD 100 Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "UnityCG.cginc" struct appdata &#123; float4 vertex : POSITION; float2 uv : TEXCOORD0; &#125;; struct v2f &#123; float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; &#125;; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) &#123; v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); return o; &#125; fixed4 frag (v2f i) : SV_Target &#123; fixed4 col = tex2D(_MainTex, i.uv); return col; &#125; ENDCG &#125; &#125; FallBack "Diffuse"&#125; 结尾通过阅读MaterialEditor源码，还是能收获一些东西的，最后1024节日快乐。 本篇文章，如果有不懂，欢迎留言~click here! 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。如果有不懂，欢迎留言评论!]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>ShaderEditor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之三十三:ReplaceComponentAttributte组件替换]]></title>
    <url>%2F2020%2F08%2F22%2Funity-bian-ji-qi-tuo-zhan-zhi-san-shi-san-replacecomponentattributte-zu-jian-ti-huan%2F</url>
    <content type="text"><![CDATA[本文介绍ReplaceComponentAttributte，方便使用自定义组件替换Unity原生组件。 Unity-ObjectFactory官方文档click here! 本篇文章，如果有不懂，欢迎留言~click here! 前言在项目中有时候会拓展Unity原生组件，例如ImagePro替换Image组件，为了避免项目中其他同事继续使用Image组件。Unity提供了一个ObjectFactory，其中的componentWasAdded能监听到组件被添加，基于ObjectFactory就可以实现原生组件在被Add时替换成拓展组件了。 源码ReplaceComponentAttribute1234567891011using System;public class ReplaceComponentAttribute : Attribute&#123; public Type ReplaceType &#123; get; private set; &#125; public ReplaceComponentAttribute(Type replaceType) &#123; ReplaceType = replaceType; &#125;&#125; ObjectFactoryExtensionEditor1234567891011121314151617181920212223242526272829303132333435363738394041424344using System.Reflection;using UnityEditor;using UnityEngine;[InitializeOnLoad]internal static class ObjectFactoryExtensionEditor&#123; static ObjectFactoryExtensionEditor() &#123; //注册组件被Add时的回调 ObjectFactory.componentWasAdded += OnComponentWasAdded; &#125; private static void OnComponentWasAdded(Component addCom) &#123; //获取所有ReplaceComponentAttribute的type Assembly asm = Assembly.GetAssembly(typeof(ReplaceComponentAttribute)); System.Type[] types = asm.GetExportedTypes(); for (int i = 0; i &lt; types.Length; i++) &#123; if (types[i] == typeof(ReplaceComponentAttribute)) &#123; continue; &#125; var attributes = types[i].GetCustomAttributes(typeof(ReplaceComponentAttribute), true); if (attributes.Length &gt; 0) &#123; //如果ReplaceType 是 当前被添加的组件，则替换 ReplaceComponentAttribute replaceComponentAttribute = (ReplaceComponentAttribute)attributes[0]; if (addCom.GetType() == replaceComponentAttribute.ReplaceType) &#123; //替换 EditorApplication.delayCall += () =&gt; &#123; GameObject go = addCom.gameObject; Object.DestroyImmediate(addCom); go.AddComponent(types[i]); &#125;; break; &#125; &#125; &#125; &#125;&#125; 测试新建一个ImagePro组件 12345678using UnityEngine.UI;//替换Image组件[ReplaceComponent(typeof(Image))]public class ImagePro : Image&#123; //Your Code&#125; 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。如果有不懂，欢迎留言评论!]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>Attributte</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之三十二:关于多选中Preview绘制探究]]></title>
    <url>%2F2020%2F07%2F30%2Funity-bian-ji-qi-tuo-zhan-zhi-san-shi-er-guan-yu-duo-xuan-zhong-preview-hui-zhi-tan-jiu%2F</url>
    <content type="text"><![CDATA[本文介绍在Unity中多选Object时，Preview视图的绘制，欢迎访问😁 本篇文章，如果有不懂，欢迎留言~click here! 前言先来介绍一下本篇文章的背景，在项目中通过使用一个ScriptableObject，暂定名为SpriteSetting，SpriteSetting内通过一个字典序列化存储了一些Sprite（以SpriteName为key，以Sprite为Value），一般使用场景为一个图集对应一个SpriteSetting。那么在运行时，只需要Load这个SpriteSetting的so，就可以根据name这个key得到Sprite。 关于序列化字典，github有开源仓库，AssetStore上也有很多。 本示例使用的AsssetStore上的Serialized Dictionary Lite。地址【https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992】【注：示意图中的搜索框是我自己拓展的，不知道作者更新没有😁😁😁】 基于此，延伸出了一些编辑器拓展方面的需求：1、选中Sprite时，支持Preview预览2、支持多选，Preview预览显示多个 SpriteAtlasSetting12345678910111213141516171819202122232425262728using System;using RotaryHeart.Lib.SerializableDictionary;using UnityEngine;[CreateAssetMenu(menuName = "Game/Config/SpriteAtlasSetting")]public class SpriteAtlasSetting : ScriptableObject&#123; //SerializableDictionaryBase是上述介绍的库，序列化字典的基类 //SpriteAtlasDic以string为key，以Sprite为Value [Serializable] public class SpriteAtlasDic : SerializableDictionaryBase&lt;string , Sprite&gt; &#123; &#125; [SerializeField] private SpriteAtlasDic _spriteAtlasDic; //根据Key从字典中获取Sprite public Sprite TryGetSprite(string key) &#123; _spriteAtlasDic.TryGetValue(key, out Sprite value); return value; &#125; //判断是否包含某个Key public bool ContainsKey(string key) &#123; return _spriteAtlasDic.ContainsKey(key); &#125;&#125; 新建一个SpriteAtlasSetting，目前尚未自定义显示，示意图如下: 可以看到，Inspector面板底下的Preview空空如也，无法从这个so中得出Sprite长什么样子。 选中Sprite,绘制Preview绘制Preview的前提是得知道当前选中了哪一个，或者哪几个。本文推荐的开源库里可以在RotaryHeart.Lib.SerializableDictionary.ReorderableList的Selected中拿到。SerializableDictionaryBase&lt;TKey,TValue&gt;的基类DrawableDictionary里包含了一个ReorderableList，这个ReorderableList要注意跟Unity自带的ReorderableList区分开，这里提到的ReorderableList是作者自己实现的一个。 绘制Preview主要用到了以下两个接口，AssetPreview.GetAssetPreview和EditorGUI.DrawTextureTransparent，前者是获取Preview，后者是绘制。 但是，绘制一个很简单，这里不做演示了，如何绘制多个呢。 从图中可以看到，其中涉及到一个布局算法，当改变Preview宽和高时，其中的sprite示意图会跟着改变布局排列。 经过多番查看UnityEditor的开源部分代码（仓库地址，在Editor.cs中发现了以下函数： 下面的DrawPreview函数支持传入UnityObject数组，这里的UnityObject其实就是UnityEngine.Object，函数内根据传入的这个数组来绘制多个。我本意是想直接反射调用该函数，结果测试失败。在OnPreviewGUI函数里直接反射调用该函数会造成死循环。。。🤣🤣🤣 最后选择直接讲该布局算法拷贝出来。。。 新建一个DrawPreviewExtension脚本，源码如下； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//源码来源于https://github.com/Unity-Technologies/UnityCsReference/blob/2018.4/Editor/Mono/Inspector/Editor.csusing UnityEditor;using UnityEngine;using UnityObject = UnityEngine.Object;public static class DrawPreviewExtension&#123; const int kGridTargetCount = 25; const int kGridSpacing = 10; const int kPreviewMinSize = 55; const int kPreviewLabelHeight = 12; const int kPreviewLabelPadding = 5; static Styles s_Styles; class Styles &#123; public GUIStyle preBackground = "PreBackground"; public GUIStyle preBackgroundSolid = "PreBackgroundSolid"; public GUIStyle previewMiniLabel = "PreMiniLabel"; public GUIStyle dropShadowLabelStyle = "PreOverlayLabel"; &#125; public static void DrawPreview(Rect previewArea, UnityObject[] targets) &#123; if (s_Styles == null) s_Styles = new Styles(); //是否绘制多个目标的示意图 if (targets.Length &gt; 1) &#123; Rect previewPositionInner = new RectOffset(16, 16, 20, 25).Remove(previewArea); int maxRows = Mathf.Max(1, Mathf.FloorToInt((previewPositionInner.height + kGridSpacing) / (kPreviewMinSize + kGridSpacing + kPreviewLabelHeight))); int maxCols = Mathf.Max(1, Mathf.FloorToInt((previewPositionInner.width + kGridSpacing) / (kPreviewMinSize + kGridSpacing))); int countWithMinimumSize = maxRows * maxCols; int neededCount = Mathf.Min(targets.Length, kGridTargetCount); bool fixedSize = true; int[] division = new int[2] &#123;maxCols, maxRows&#125;; if (neededCount &lt; countWithMinimumSize) &#123; division = GetGridDivision(previewPositionInner, neededCount, kPreviewLabelHeight); fixedSize = false; &#125; int count = Mathf.Min(division[0] * division[1], targets.Length); previewPositionInner.width += kGridSpacing; previewPositionInner.height += kGridSpacing; Vector2 cellSize = new Vector2( Mathf.FloorToInt(previewPositionInner.width / division[0] - kGridSpacing), Mathf.FloorToInt(previewPositionInner.height / division[1] - kGridSpacing) ); float previewSize = Mathf.Min(cellSize.x, cellSize.y - kPreviewLabelHeight); if (fixedSize) previewSize = Mathf.Min(previewSize, kPreviewMinSize); for (int i = 0; i &lt; count; i++) &#123; Rect r = new Rect( previewPositionInner.x + (i % division[0]) * previewPositionInner.width / division[0], previewPositionInner.y + (i / division[0]) * previewPositionInner.height / division[1], cellSize.x, cellSize.y ); r.height -= kPreviewLabelHeight; Rect rSquare = new Rect(r.x + (r.width - previewSize) * 0.5f, r.y + (r.height - previewSize) * 0.5f, previewSize, previewSize); GUI.BeginGroup(rSquare); //获取Preview示意图 Texture previewTexture = AssetPreview.GetAssetPreview(targets[i]); if (previewTexture != null) &#123; EditorGUI.DrawTextureTransparent(new Rect(0, 0, previewSize, previewSize), previewTexture, ScaleMode.ScaleToFit); &#125; GUI.EndGroup(); r.y = rSquare.yMax; r.height = 16; GUI.Label(r, targets[i].name, s_Styles.previewMiniLabel); &#125; &#125; else &#123; Texture previewTexture = AssetPreview.GetAssetPreview(targets[0]); if (previewTexture != null) &#123; EditorGUI.DrawTextureTransparent(previewArea, previewTexture, ScaleMode.ScaleToFit); &#125; &#125; &#125; private static float AbsRatioDiff(float x, float y) &#123; return Mathf.Max(x / y, y / x); &#125; private static int[] GetGridDivision(Rect rect, int minimumNr, int labelHeight) &#123; // The edge size of a square calculated based on area float approxSize = Mathf.Sqrt(rect.width * rect.height / minimumNr); int xCount = Mathf.FloorToInt(rect.width / approxSize); int yCount = Mathf.FloorToInt(rect.height / (approxSize + labelHeight)); // This heuristic is not entirely optimal and could probably be improved while (xCount * yCount &lt; minimumNr) &#123; float ratioIfXInc = AbsRatioDiff((xCount + 1) / rect.width, yCount / (rect.height - yCount * labelHeight)); float ratioIfYInc = AbsRatioDiff(xCount / rect.width, (yCount + 1) / (rect.height - (yCount + 1) * labelHeight)); if (ratioIfXInc &lt; ratioIfYInc) &#123; xCount++; if (xCount * yCount &gt; minimumNr) yCount = Mathf.CeilToInt((float)minimumNr / xCount); &#125; else &#123; yCount++; if (xCount * yCount &gt; minimumNr) xCount = Mathf.CeilToInt((float)minimumNr / yCount); &#125; &#125; return new int[] &#123; xCount, yCount &#125;; &#125;&#125; 新建一个SpriteAtlasSettingDrawer脚本用来绘制SpriteAtlasSetting这个so类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System.Reflection;using UnityEditor;using UnityEngine;[CustomEditor(typeof(SpriteAtlasSetting))]public class SpriteAtlasSettingDrawer : UnityEditor.Editor&#123; //这里要返回true，表示有Preview需要绘制 public override bool HasPreviewGUI() &#123; return true; &#125; //Preview绘制函数 public override void OnPreviewGUI(Rect r, GUIStyle background) &#123; base.OnPreviewGUI(r, background); SpriteAtlasSetting spriteAtlasSetting = target as SpriteAtlasSetting; //_spriteAtlasDic前面是定义的私有的，这里反射拿 FieldInfo spriteAtlasDicFieldInfo = spriteAtlasSetting.GetType().GetField("_spriteAtlasDic", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public); SpriteAtlasSetting.SpriteAtlasDic spriteAtlasDicFieldInfoValue = spriteAtlasDicFieldInfo.GetValue(spriteAtlasSetting) as SpriteAtlasSetting.SpriteAtlasDic; if (spriteAtlasDicFieldInfoValue != null &amp;&amp; spriteAtlasDicFieldInfoValue.reorderableList != null) &#123; if (spriteAtlasDicFieldInfoValue.reorderableList.Selected.Length &gt; 0) &#123; int[] selected = spriteAtlasDicFieldInfoValue.reorderableList.Selected; //字典的_values也是私有的，反射拿 FieldInfo spriteAtlasDicValueFieldInfo = spriteAtlasDicFieldInfoValue.GetType().BaseType .GetField("_values", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public); //拿到字典中所有的sprite Sprite[] values = spriteAtlasDicValueFieldInfo.GetValue(spriteAtlasDicFieldInfoValue) as Sprite[]; //根据selected拿到被选中的Sprite，这里就不考虑什么GC不GC的了，反正也只是演示。。 Sprite[] drawSprites = new Sprite[selected.Length]; for (int i = 0; i &lt; selected.Length; i++) &#123; drawSprites[i] = values[selected[i]]; &#125; //调用前面封装的静态接口，绘制多选中preview DrawPreviewExtension.DrawPreview(r, drawSprites); &#125; &#125; &#125;&#125; 结尾表面上，我们只是实现了以Sprite为value的序列化字典的多选中绘制，实际上，别的类型资源的选中绘制也是一样的。例如材质，如下图： 这部分支持就不详细介绍了，主要是上述的多选中Preview布局算法。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。如果有不懂，欢迎留言评论!]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>Preview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GameFramework框架源码解读（二）：Setting]]></title>
    <url>%2F2020%2F07%2F20%2Fgameframework-kuang-jia-yuan-ma-jie-du-er-setting%2F</url>
    <content type="text"><![CDATA[GameFramework框架源码解读Setting组件，欢迎访问😂 本篇文章，如果有不懂，欢迎留言~click here! 模块介绍以键值对的形式存储玩家数据，对UnityEngine.PlayerPrefs进行封装，也可以保存将数据直接存储在磁盘上。PlayerPrefs在运行时无法直接获取到所有键值，因此E大提供了该模块来代替PlayerPrefs。关于如何在Editor下获取所有键值对，参考这篇文章：Unity编辑器拓展之三十一:获取PlayerPrefs所有键值对 常规接口使用使用GameEntry.GetComponent()获取Setting组件。 对比PlayerPrefs类的接口来看，Setting组件也提供了GetInt、SetInt、GetBool、SetBool、GetString、SetString、GetFloat、SetFloat等接口。除此之外，Setting组件还做了些拓展。 1、GetAllSettingNames获取获取所有游戏配置项的名称 2、HasSetting检查是否存在游戏配置项，同PlayerPrefs.HasKey 3、RemoveSetting移出指定游戏配置项，同PlayerPrefs.DeleteKey 4、RemoveAllSettings清空所有游戏配置项，同PlayerPrefs.DeleteAll(慎用) 5、GetObject读取对象，这是一个泛型接口。 跟进到SettingManager里面可以看到是调用了SettingHelper里的GetObject函数，继续进去看。SettingHelperBase类实现了ISettingHelper接口，而UGF里提供了两个SettingHelper,DefaultSettingHelper和PlayerPrefsSettingHelper，而这两个SettingHelper里都是通过Utility.Json.ToObject进行对象的读取的。 6、SetObject写入对象，同上GetObject 实践1、为项目选择SettingHelper 这里不建议使用PlayerPrefsSettingHelper了，因为它是基于PlayerPrefs进行的二次封装，所以依然是不支持运行时获取所有键值的。 当然，可以自己编写一个Helper，继承SettingHelperBase，比如你的游戏数据需要自行做加密解密🤔🤔🤔 2、运行StarForce案例后，Setting的Inspector面板如下： 面板上能看到所有键值对，以及一个保存和删除所有数据的按钮。目前尚未支持在非运行时就可以预览Setting里的所有数据，要支持也不难，在非运行时将存放数据的文件加载出来显示在Inspector面板上即可。 本系列GameFramework框架源码介绍会持续更新，也作为自己的学习笔记。如有不详细之处，欢迎沟通。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。如果有不懂，欢迎留言评论!]]></content>
      <categories>
        <category>Unity</category>
        <category>GameFramework框架</category>
      </categories>
      <tags>
        <tag>GameFramework框架源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UIElement入门]:4.自定义元素]]></title>
    <url>%2F2020%2F05%2F17%2Fuielement-ru-men-4-zi-ding-yi-yuan-su%2F</url>
    <content type="text"><![CDATA[本系列文章介绍UIElement知识点，欢迎访问😉 UIElement官方文档 本系列文章使用的Unity版本为2019.3.7f1 本系列文章目录：UIElement : EditorWindow简单介绍UIElement : UXML元素介绍UIElement : UQuery介绍UIElement : Layout EngineUIElement : 自定义元素后续待更新内容：UIElement : Editor Demo Quick ToolUIElement : Layout Engine YogaLayoutUIElement : UIBuilder的使用介绍UIElement : 使用UIBuilder开发Editor Demo QuickToolUIElement : 使用UIElement开发GF框架的AssetBundlBuilderUIElement : Runtime Demo Tank 自定义元素定义一个自定义元素类在使用UXML文件定义新元素之前，必须从VisualElement或它的一个子类派生一个新类，然后在这个新类中实现适当的功能。你的新类必须实现一个默认构造函数。 12345678910class StatusBar : VisualElement&#123; public StatusBar() &#123; m_Status = String.Empty; &#125; string m_Status; public string status &#123; get; set; &#125;&#125; 元素工厂为了让UIElement在读取UXML文件时能够识别到该自定义元素类，必须为该元素类定义一个工厂。如果工厂不需要做一些特殊的事情，可以直接从UxmlFactoy派生工厂。建议将工厂类放在组件类中。 1234567891011121314class StatusBar : VisualElement&#123; public StatusBar() &#123; m_Status = String.Empty; &#125; string m_Status; public string status &#123; get; set; &#125; public new class UxmlFactory : UxmlFactory&lt;StatusBar&gt; &#123;&#125; // ...&#125; 定义了这个工厂之后，可以在UXML文件中使用&lt;StatusBar&gt;元素。 添加元素可以为一个新类定义UXML特征，并设置它的工厂来使用这些特征。例如，下面的代码演示了如何定义一个UXML traits类，将status属性初始化为StatusBar类的属性。status属性是从XML数据初始化的。 123456789101112131415161718192021222324252627282930313233343536class StatusBar : VisualElement&#123; public StatusBar() &#123; m_Status = String.Empty; &#125; string m_Status; public string status &#123; get; set; &#125; public new class UxmlFactory : UxmlFactory&lt;StatusBar, UxmlTraits&gt; &#123;&#125; //将UxmlTraits类放在StatusBar类中，Init()方法可以访问StatusBar的私有成员。 public new class UxmlTraits : VisualElement.UxmlTraits &#123; //定义一个变量名m_Status初始值为status的UXML属性 UxmlStringAttributeDescription m_Status = new UxmlStringAttributeDescription &#123; name = "status" &#125;; public override IEnumerable&lt;UxmlChildElementDescription&gt; uxmlChildElementsDescription &#123; //返回一个空的IEnumerable，表示StatusBar不允许包含子元素 get &#123; yield break; &#125; &#125; public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc) &#123; //调用base.Init()来初始化基类属性。 base.Init(ve, bag, cc); //从UXML解析器中读取属性包中status属性的值并设置status属性设置为该值。 //将元素的status初始化为m_Status的值，也就是"status" ((StatusBar)ve).status = m_Status.GetValueFromBag(bag, cc); &#125; &#125; // ...&#125; UxmlTraits有两个用途:工厂使用它来初始化新创建的对象。模式生成过程对其进行分析，以获得关于元素的信息。这些信息被转换成XML模式指令。 上面的代码示例使用UxmlStringAttributeDescription类声明了一个string属性。UIElements支持以下类型的属性，每个都将c#类型链接到UXML类型 Attribute Attribute Value Type UxmlStringAttributeDescription String UxmlFloatAttributeDescription Float UxmlDoubleAttributeDescription Double UxmlIntAttributeDescription Int UxmlLongAttributeDescription Long UxmlBoolAttributeDescription Bool UxmlColorAttributeDescription Color UxmlEnumAttributeDescription&lt;T&gt; Enum 要使元素接受任何类型的子元素，必须重写uxmlChildElementsDescription属性。例如，要使StatusBar元素接受任何类型的子元素，必须指定uxmlChildElementsDescription属性，如下所示 1234567public override IEnumerable&lt;UxmlChildElementDescription&gt; uxmlChildElementsDescription&#123; get &#123; yield return new UxmlChildElementDescription(typeof(VisualElement)); &#125;&#125; 定义命名空间在c#中定义了一个新元素，就可以开始在UXML文件中使用这个元素了。如果新元素是在一个新的名称空间中定义的，那么应该为该名称空间定义一个前缀。命名空间前缀被声明为根&lt;UXML&gt;元素的属性，并在限定元素作用域时替换完整的命名空间名称。 例如将StatusBar放到MyVisualElement命名空间下： 1234567891011using UnityEditor.UIElements;using UnityEngine;using UnityEngine.UIElements;namespace MyVisualElement&#123; class StatusBar : VisualElement &#123; //...省略 &#125;&#125; 那么UXML中使用Status元素是： 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;engine:UXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:engine="UnityEngine.UIElements" xmlns:editor="UnityEditor.UIElements" xsi:noNamespaceSchemaLocation="../../UIElementsSchema/UIElements.xsd"&gt; &lt;!--此处要写完整的命名空间--&gt; &lt;MyVisualElement.StatusBar /&gt;&lt;/engine:UXML&gt; 高级用法自定义UXML name可以自定义UXML名称通过重写IUxmlFactory.uxmlName和IUXmlFactory.uxmlQualifiedName属性。确保uxmlName在命名空间中是唯一的，uxmlQualifiedName在项目中是唯一的。如果两个名称都不唯一，则在尝试加载程序集时会引发异常。 123456789101112public class FactoryWithCustomName : UxmlFactory&lt;..., ...&gt;&#123; public override string uxmlName &#123; get &#123; return "UniqueName"; &#125; &#125; public override string uxmlQualifiedName &#123; get &#123; return uxmlNamespace + "." + uxmlName; &#125; &#125;&#125; 为元素选择工厂默认情况下，IUxmlFactory实例化一个元素并使用元素的名称选择该元素。 可以通过重写IUXmlFactory.AcceptsAttributeBag使选择过程考虑元素上的属性值。然后，工厂将检查元素属性，以决定是否可以为UXML元素实例化一个对象 如果VisualElement类是泛型的，这就很有用。在这种情况下，用于专门化类的类工厂可以检查XML类型属性的值。根据值的不同，可以接受或拒绝实例化。 在有多个工厂可以实例化一个元素的情况下，选择第一个注册的工厂。 重写基类元素属性的默认值通过在派生的UxmlTraits类中设置其defaultValue来更改基类中声明的属性的默认值。 12345678class MyElementTraits : VisualElement.UxmlTraits&#123; public MyElementTraits() &#123; //更改m TabIndex的默认值为0 m_TabIndex.defaultValue = 0; &#125;&#125; 接受任何属性默认情况下，生成的XML模式声明元素可以具有任何属性。 除了在UxmlTraits类中声明的属性值之外，其他属性的值不受限制。这与XML验证器相反，XML验证器检查声明的属性值是否与其声明相匹配。 额外的属性包含在IUxmlAttributes包中，该包传递给IUxmlFactory.AcceptsAttributBag()和IUxmlFactory.Init()函数。工厂实现决定是否使用这些附加属性。默认行为是放弃附加属性。 如果放弃附加属性，就意味着这些附加属性没有附加到实例化的VisualElement，并且这些atttibute不能用UQuery查询。 在定义新元素时，可以通过设置UxmlTraits将接受的属性限制为那些显式声明的属性，在UxmlTraits构造函数中将anyattribute属性设为false即可。 自定义元素案例以下代码实现包含8种数据类型的VisualElement。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091using System.Collections.Generic;using UnityEditor.UIElements;using UnityEngine;using UnityEngine.UIElements;//命名空间namespace MyVisualElement&#123; //自定义元素类 class CustomVisualElement : VisualElement &#123; //枚举 public enum Existance &#123; None, Good, Bad &#125; //8种数据类型的属性 public string stringAttr &#123; get; set; &#125; public float floatAttr &#123; get; set; &#125; public double doubleAttr &#123; get; set; &#125; public int intAttr &#123; get; set; &#125; public long longAttr &#123; get; set; &#125; public bool boolAttr &#123; get; set; &#125; public Color colorAttr &#123; get; set; &#125; public Existance enumAttr &#123; get; set; &#125; //工厂 public new class UxmlFactory : UxmlFactory&lt;CustomVisualElement, UxmlTraits&gt; &#123; &#125; //使用UxmlTraits初始化新创建的元素对象 public new class UxmlTraits : VisualElement.UxmlTraits &#123; UxmlStringAttributeDescription m_String = new UxmlStringAttributeDescription &#123;name = "string-attr", defaultValue = "default_value"&#125;; UxmlFloatAttributeDescription m_Float = new UxmlFloatAttributeDescription &#123;name = "float-attr", defaultValue = 0.1f&#125;; UxmlDoubleAttributeDescription m_Double = new UxmlDoubleAttributeDescription &#123;name = "double-attr", defaultValue = 0.1&#125;; UxmlIntAttributeDescription m_Int = new UxmlIntAttributeDescription &#123;name = "int-attr", defaultValue = 2&#125;; UxmlLongAttributeDescription m_Long = new UxmlLongAttributeDescription &#123;name = "long-attr", defaultValue = 3&#125;; UxmlBoolAttributeDescription m_Bool = new UxmlBoolAttributeDescription &#123;name = "bool-attr", defaultValue = false&#125;; UxmlColorAttributeDescription m_Color = new UxmlColorAttributeDescription &#123;name = "color-attr", defaultValue = Color.red&#125;; UxmlEnumAttributeDescription&lt;Existance&gt; m_Enum = new UxmlEnumAttributeDescription&lt;Existance&gt; &#123;name = "enum-attr", defaultValue = Existance.Bad&#125;; //该自定义的元素 无子元素 public override IEnumerable&lt;UxmlChildElementDescription&gt; uxmlChildElementsDescription &#123; get &#123; yield break; &#125; &#125; //初始化 public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc) &#123; base.Init(ve, bag, cc); var ate = ve as CustomVisualElement; ate.Clear(); //添加8个属性对应的Field，以及初始化默认值 ate.stringAttr = m_String.GetValueFromBag(bag, cc); ate.Add(new TextField("String") &#123;value = ate.stringAttr&#125;); ate.floatAttr = m_Float.GetValueFromBag(bag, cc); ate.Add(new FloatField("Float") &#123;value = ate.floatAttr&#125;); ate.doubleAttr = m_Double.GetValueFromBag(bag, cc); ate.Add(new DoubleField("Double") &#123;value = ate.doubleAttr&#125;); ate.intAttr = m_Int.GetValueFromBag(bag, cc); ate.Add(new IntegerField("Integer") &#123;value = ate.intAttr&#125;); ate.longAttr = m_Long.GetValueFromBag(bag, cc); ate.Add(new LongField("Long") &#123;value = ate.longAttr&#125;); ate.boolAttr = m_Bool.GetValueFromBag(bag, cc); ate.Add(new Toggle("Toggle") &#123;value = ate.boolAttr&#125;); ate.colorAttr = m_Color.GetValueFromBag(bag, cc); ate.Add(new ColorField("Color") &#123;value = ate.colorAttr&#125;); ate.enumAttr = m_Enum.GetValueFromBag(bag, cc); var en = new EnumField("Enum"); en.Init(m_Enum.defaultValue); en.value = ate.enumAttr; ate.Add(en); &#125; &#125; &#125;&#125; UXML： 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;engine:UXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:engine="UnityEngine.UIElements" xmlns:editor="UnityEditor.UIElements" xsi:noNamespaceSchemaLocation="../../UIElementsSchema/UIElements.xsd"&gt; &lt;!--C#元素类定义了命名空间--&gt; &lt;MyVisualElement.CustomVisualElement /&gt;&lt;/engine:UXML&gt; UXML中也可以直接定义属性值： 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;engine:UXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:engine="UnityEngine.UIElements" xmlns:editor="UnityEditor.UIElements" xsi:noNamespaceSchemaLocation="../../UIElementsSchema/UIElements.xsd"&gt; &lt;!--C#元素类定义了命名空间--&gt; &lt;!--举例说明：string-attr 得跟UxmlTraits中定义的UxmlAttributeDescription的name保持一致--&gt; &lt;MyVisualElement.CustomVisualElement string-attr="my-string" float-attr="4.2" double-attr="4.3" int-attr="4" long-attr="423" bool-attr="true" color-attr="#CA7C03FF" enum-attr="Good"/&gt;&lt;/engine:UXML&gt; C# Load Code: 12var customElement = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;("Assets/Editor/CustomElement.uxml");root.Add(customElement.CloneTree()); 参考文章 自定义元素官方文档官方论坛讨论：如何创建自定义元素？ 更多的UIElement知识点文章，还在进行中，如有相关内容需要介绍的，可以在下方留言，抽空更新文章~ 以上知识分享，如有错误，欢迎指出，共同学习，共同进步，欢迎留言评论!]]></content>
      <categories>
        <category>Unity</category>
        <category>UIElement</category>
      </categories>
      <tags>
        <tag>UIElement</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UIElement入门]:3.Layout Engine]]></title>
    <url>%2F2020%2F05%2F13%2Fuielement-ru-men-3-layout-engine%2F</url>
    <content type="text"><![CDATA[本系列文章介绍UIElement知识点，欢迎访问😉 UIElement官方文档 本系列文章使用的Unity版本为2019.3.7f1 本系列文章目录：UIElement : EditorWindow简单介绍UIElement : UXML元素介绍UIElement : UQuery介绍UIElement : Layout EngineUIElement : 自定义元素后续待更新内容：UIElement : Editor Demo Quick ToolUIElement : Layout Engine YogaLayoutUIElement : UIBuilder的使用介绍UIElement : 使用UIBuilder开发Editor Demo QuickToolUIElement : 使用UIElement开发GF框架的AssetBundlBuilderUIElement : Runtime Demo Tank 前言UIElements使用Yoga布局引擎根据布局和样式属性来定义UI。 默认情况下，所有元素都是布局的一部分，布局具有以下默认行为： 容器垂直分布其子元素 容器矩形的位置包括其子矩形，此行为可能受到其他布局属性的限制。 具有文本的元素在其大小计算中使用文本大小，此行为可能受到其他布局属性的限制。 Layout Engine Yoga Layout 官方文档 Position Position分为Relative/Absolute: Relative：相对定位。元素根据布局的正常流程进行定位，然后根据顶部、右侧、底部和左侧的值相对于该位置进行偏移。偏移量不影响任何同级或父元素的位置。 Absolute：绝对定位。当元素被绝对定位时，它不参与常规布局流。相反，它是独立于它的兄弟姐妹而设计的。位置是根据顶部、右侧、底部和左侧值确定的。 Left、Top、Right、Bottom这个值是用来使用Absolute或者Relative Layout后对元素位置进行偏移的。 FlexFlex DirectionFlex方向控制节点的子节点布局的方向。这也被称为主轴。主轴是子元素摆放的方向。横轴:垂直于主轴的轴。FlexDirection是一个枚举类型，在UnityEngine.UIElements命名空间下。 Column：从上到下排列子元素。如果启用了换行，那么下一行将从容器顶部左侧的第一项开始。 ColumnReverse：让孩子们从下到上对齐。如果启用了换行，那么下一行将从容器底部左边的第一项开始。 Row：让子元素从左到右对齐。如果启用了换行，那么下一行将在容器左边的第一项开始。 RowReverse：让孩子们从右向左对齐。如果启用了换行，那么下一行将在容器右侧的第一项下开始。 依次是从上到下、从下到上、从左到右、从右到左 Flex Wrap在容器上设置flex wrap属性，并控制当子元素沿主轴溢出容器的大小时会发生什么。默认情况下，子元素被强制放到一行中(这一行可以收缩元素)。 No Wrap：将子元素放在一行 Wrap：沿主轴将子元素放在多行，也就是允许换行。 Wrap Reverse：允许换行，换行的顺序跟Wrap是相反的。 AlignAlign是一个枚举类型，在UnityEngine.UIElements命名空间下。 Auto：让Flex属性决定布局 FlexStart：将容器的子元素对齐到容器横轴的起点 Center：将容器的子元素对齐到容器横轴的中心。 FlexEnd：将容器的子元素对齐到容器横轴的末端。 Stretch：拉伸容器的子元素以匹配容器的横轴的高度。 Align Items如何在容器的横轴上对齐子元素 Justify Content子元素在容器主轴上的对齐方式 FlexStart：将容器的子元素对齐到容器主轴的开始位置。 Center：将容器的子元素对齐到容器主轴的中心。 FlexEnd：将容器的子元素对齐到容器主轴的末端。 SpaceBetween：在容器的主轴上均匀地划分孩子的空间，在孩子之间分配剩余的空间。 SpaceAround：在容器的主轴线上均匀地分布子元素空间，将剩余的空间分布在子元素周围。与空间相比，使用周围的空间会导致空间被分配到第一个子元素的开始和最后一个子元素的结束。 Sizewidth和height是设置元素的固定宽高；maxWidth和maxHeight是设置元素的最大宽高；minWidth和minHeight是设置元素的最小宽高。 Margin &amp; Padding &amp; Border Margin(外边距)影响节点外部的间距。带有margin的节点将从其父节点的界限中偏移自身，但也会偏移任何兄弟节点的位置。如果父节点是自动调整大小的，则节点的边距会影响其父节点的总大小。 Padding(内边距))如果元素有显式的大小设置，填充将不会添加到元素的总大小中。对于自动调整大小的节点，填充将增加节点的大小，并偏移任何子节点的位置。 Border(边框)边框也就是元素的四条边，可以设置边框的厚度、颜色、以及四个角的圆角半径。 更多的UIElement知识点文章，还在进行中，如有相关内容需要介绍的，可以在下方留言，抽空更新文章~ 以上知识分享，如有错误，欢迎指出，共同学习，共同进步，欢迎留言评论!]]></content>
      <categories>
        <category>Unity</category>
        <category>UIElement</category>
      </categories>
      <tags>
        <tag>UIElement</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UIElement入门]:2.UQuery介绍]]></title>
    <url>%2F2020%2F05%2F12%2Fuielement-ru-men-2-uquery-jie-shao%2F</url>
    <content type="text"><![CDATA[本系列文章介绍UIElement知识点，欢迎访问😉 UIElement官方文档 本系列文章使用的Unity版本为2019.3.7f1 本系列文章目录：UIElement : EditorWindow简单介绍UIElement : UXML元素介绍UIElement : UQuery介绍UIElement : Layout EngineUIElement : 自定义元素后续待更新内容：UIElement : Editor Demo Quick ToolUIElement : Layout Engine YogaLayoutUIElement : UIBuilder的使用介绍UIElement : 使用UIBuilder开发Editor Demo QuickToolUIElement : 使用UIElement开发GF框架的AssetBundlBuilderUIElement : Runtime Demo Tank 前言首先我们来理解一下为什么官方提供UQuery这一套东西。UQuery是一组扩展方法，允许您在复杂的层次结构中选择单独的或集合的visualelement。为了从任何UIElements元素可视树中检索也就是找到业务逻辑中想要的元素，提供的UQuery这一组拓展方法。官方解释说UQuery基于JQuery，那么从JQuery入手来理解一下原理。学过前端的同学应该都清楚JQuery的用法（我没学过，这里现学现用一下🤣🤣🤣，如有错误，请见谅）。 什么是JQuery？JQuery是一个轻量级的JavaScript函数库，包含以下功能： HTML元素选取 HTML元素操作 CSS操作 HTML事件函数 JavaScript特效和动画 HTML DOM遍历和修改 AJAX Utilities 粗略看来，JQuery可以检索到HTML中的元素并进行操作，这跟UQuery提供的功能是一致的，至于JQuery提供的别的功能，UQuery以后的发展目前不得而知。 为什么需要提供UQuery？UIElement的结构是通过UXML+USS的形式完成一个元素可视树（也就是UI）的绘制，这跟传统的Prefab工作模式有很大的区别。UIElement制作出来的UI以UXML+USS两类文件存在于工程中，并不存在Prefab，也不能在Hierarchy下看到UI的层级，可以通过UIElements Debugger（Window-&gt;Analysns-&gt;UIElements Debugger）或者后面会讲到的UI Builder进行查看。既然不存在Prefab，传统的Prefab+MonoBehavior做法也就不再适用了，Prefab+Mono Find Child就没啥说的了，一样。那以前的Prefab+非Mono Find Child的模式呢？ 其实我的理解呢，Find Child的模式，就是在一个UI里检索业务逻辑需要的元素，进而进行业务逻辑的开发，这就跟UQuery一样了，都是要在UI中检索元素，只是两者的检索方式不一样罢了。 使用UQuery的好处？以前通过Find Child检索元素的方式，弊端在于代码中检索元素时使用的Path被层级位置所限制，这样无法做到UI Prefab制作工作与业务逻辑脚本开发工作的完全分离。而使用Prefab+Mono脚本（非Find，直接序列化绑定）的方式，也有弊端，手动拖费时费力（因此网上目前也有开源的自动绑定UI元素的开源库）。使用UIElement后，通过UQuery这一套接口，只需要UI制作人员与程序制定好交互UI元素的命名、UI界面上各区域的划分，更好的做到工作内容分离。至于Runtime下如何打开一个UI，以及打开后的事件绑定等后续业务逻辑开发工作，后续更新Runtime Demo进行介绍。 UQueryExtensions UQueryExtensions官方接口文档 UQueryExtensions.Q根据检索条件，查找符合条件的第一个元素，Query&lt;T&gt;.Build().First()方法的简写。 Function12public static T Q(this UIElements.VisualElement e, string name, string className);public static T Q(this UIElements.VisualElement e, string name, params string[] classes); Parameters UIElements.VisualElement e：在该元素上使用条件检索，理解为使用该检索条件的root，不一定是整个UI的Root string name：限制检索元素的name string className：限制检索元素的class，并不是面向对象的class string[] classes：限制检索元素的class（多个），并不是面向对象的class Return返回符合检索条件的第一个元素，如果找不到则为null。 UQueryExtensions.Q&lt;T&gt;UQueryExtensions.Q的泛型接口 UQueryExtensions.Query返回一个UQueryBuilder&lt;VisualElement&gt;，UQueryBuilder类里包括一些Style选择器、RuleMatcher匹配规则，然后通过First、Last、ToList、AtIndex等接口根据检索规则查找符合规则的元素并返回，ForEach接口主要是对符合匹配规则的检索出来的元素都执行一遍传入的Function。 UQueryExtensions.Query&lt;T&gt;UQueryExtensions.Query的泛型接口 举例新建一个UQueryDemo.uxml文件 123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;engine:UXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:engine="UnityEngine.UIElements" xmlns:editor="UnityEditor.UIElements" xsi:noNamespaceSchemaLocation="../../UIElementsSchema/UIElements.xsd"&gt; &lt;engine:Button text="Button1" name="Button1" /&gt; &lt;engine:Button text="Button2" name="Button2" /&gt; &lt;engine:Box&gt; &lt;engine:Label text="This is Label in Box" /&gt; &lt;engine:Button text="Button3" name="Button3" /&gt; &lt;/engine:Box&gt;&lt;/engine:UXML&gt; C# 代码 12345678910111213141516171819202122var queryDemo = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;("Assets/Editor/UQueryDemo.uxml");root.Add(queryDemo.CloneTree());//检索到命名为Button1的按钮，添加点击事件root.Q&lt;Button&gt;("Button1").clickable.clicked += delegate&#123; Debug.LogError("Click1");&#125;;//检索到类型为Button的第一个元素，添加点击事件root.Query&lt;Button&gt;().First().clickable.clicked += delegate&#123; Debug.LogError("Click1");&#125;;//检索所有Button类型，使用ForEach遍历检索出的Button，给这些Button均添加点击事件//尽管Button3放在了一个Box元素里，依然被下面的的代码检索到了。root.Query&lt;Button&gt;().ForEach(delegate(Button button)&#123; button.clickable.clicked += delegate &#123; Debug.LogError(button.text); &#125;;&#125;); 更多的UIElement知识点文章，还在进行中，如有相关内容需要介绍的，可以在下方留言，抽空更新文章~ 以上知识分享，如有错误，欢迎指出，共同学习，共同进步，欢迎留言评论!]]></content>
      <categories>
        <category>Unity</category>
        <category>UIElement</category>
      </categories>
      <tags>
        <tag>UIElement</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UIElement入门]:1.UXML元素介绍]]></title>
    <url>%2F2020%2F05%2F11%2Fuielement-ru-men-1-uxml-yuan-su-jie-shao%2F</url>
    <content type="text"><![CDATA[本系列文章介绍UIElement知识点，欢迎访问😉 UIElement官方文档 本系列文章使用的Unity版本为2019.3.7f1 本系列文章目录：UIElement : EditorWindow简单介绍UIElement : UXML元素介绍UIElement : UQuery介绍UIElement : Layout EngineUIElement : 自定义元素后续待更新内容：UIElement : Editor Demo Quick ToolUIElement : Layout Engine YogaLayoutUIElement : UIBuilder的使用介绍UIElement : 使用UIBuilder开发Editor Demo QuickToolUIElement : 使用UIElement开发GF框架的AssetBundlBuilderUIElement : Runtime Demo Tank 以下内容中，可能某些元素的属性解释的不是很充分，这些还需要后面的实际使用才更好了解。 UIElements Samples官方提供的内置元素使用demo，在Window-&gt;UI-&gt;UIElements Samples下。通过这个工具，可以很方便地查询到各个内置元素的使用方法。 UXML elements referenceUIElement提供了一些常用的UXML元素供我们使用，在UnityEngine.UIElements和UnityEditor.UIElements命名空间下。 UXML elements Reference 官方文档 这些自带的元素分为以下几大类： Base elements Utilities Templates Controls Text input Complex widgets Toolbar Views and windows Base elementsVisualElement 所有元素的基类 命名空间：UnityEngine.UIElements 子元素数量：无数量限制 属性 class style name picking-mode tooltip focusable tabindex view-data-key BindableElement 可以绑定到一个SerializedProperty上，属性的值和显示的值是同步的 命名空间：UnityEngine.UIElements 子元素数量：无数量限制 属性 binding-path: 此元素绑定的属性的路径。 UtilitiesBox Box类似于VisualElement，在内容周围多了一个方框 命名空间：UnityEngine.UIElements 子元素数量：无数量限制 属性： VisualElement的所有属性 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;engine:UXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:engine="UnityEngine.UIElements" xmlns:editor="UnityEditor.UIElements" xsi:noNamespaceSchemaLocation="../../UIElementsSchema/UIElements.xsd"&gt; &lt;engine:Box&gt; &lt;engine:Label text="This is Label in Box" /&gt; &lt;/engine:Box&gt;&lt;/engine:UXML&gt; TextElement 显示文本 命名空间：UnityEngine.UIElements 子元素数量：0 属性： VisualElement的所有属性 text：显示的文本 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;engine:UXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:engine="UnityEngine.UIElements" xmlns:editor="UnityEditor.UIElements" xsi:noNamespaceSchemaLocation="../../UIElementsSchema/UIElements.xsd"&gt; &lt;engine:Box&gt; &lt;engine:Label text="This is Label in Box" /&gt; &lt;engine:TextElement text="This is TextElement in Box" /&gt; &lt;/engine:Box&gt;&lt;/engine:UXML&gt; Label 文本标签 命名空间：UnityEngine.UIElements 子元素数量：0 属性： VisualElement的所有属性 示意图和实例代码同TextElement Image 显示图片 命名空间：UnityEngine.UIElements 子元素数量：0 属性： VisualElement的所有属性 12345Image imageElement = new Image();imageElement.image = AssetDatabase.LoadAssetAtPath&lt;Texture&gt;("Assets/quit_icon.png");imageElement.sourceRect = new Rect(0,0,128,128);imageElement.scaleMode = ScaleMode.ScaleToFit;root.Add(imageElement); IMGUIContainer 绘制一个IMGUI的内容， 命名空间：UnityEngine.UIElements 子元素数量：0 属性： VisualElement的所有属性 focus-index：默认值是0 focusable：默认值是true 123456789IMGUIContainer imguiContainer = new IMGUIContainer();imguiContainer.onGUIHandler = delegate&#123; if (GUILayout.Button("This is IMGUI Button")) &#123; Debug.LogError("Click"); &#125;&#125;;root.Add(imguiContainer); Foldout 绘制一个具有显示或隐藏其内容的切换按钮。 命名空间：UnityEngine.UIElements 子元素数量：无数量限制 属性： VisualElement的所有属性 123456789101112131415//定义一个imgui的buttonIMGUIContainer imguiContainer = new IMGUIContainer();imguiContainer.onGUIHandler = delegate &#123; if (GUILayout.Button("This is IMGUI Button")) &#123; Debug.LogError("Click"); &#125; &#125;; //定义一个FoldoutFoldout foldout = new Foldout();foldout.text = "FoldOut";//将button加到foldout下foldout.Add(imguiContainer);root.Add(foldout); TemplatesTemplate 对另一个UXML模板的引用 命名空间：UnityEngine.UIElements 子元素数量：0 属性： name: 元素的唯一字符串标识符 path: 要加载的UXML文件路径 Instance 模板实例 命名空间：UnityEngine.UIElements 子元素数量：0 属性： template: 要实例化的模板的名称 TemplateContainer 模板容器 命名空间：UnityEngine.UIElements 子元素数量：0 属性： BindableElement的所有属性 template: 该模板的字符串标识符 Template 简单案例 新建一个Template.uxml文件，组件命名为Player，其中包含两个Label 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;engine:UXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:engine="UnityEngine.UIElements" xmlns:editor="UnityEditor.UIElements" xsi:noNamespaceSchemaLocation="../../UIElementsSchema/UIElements.xsd"&gt; &lt;engine:VisualElement class="Player"&gt; &lt;engine:Label name="nameLabel" text="Name"/&gt; &lt;engine:Label name="ageLabel" text="Age"/&gt; &lt;/engine:VisualElement&gt;&lt;/engine:UXML&gt; 新建一个TemplateDemo.uxml文件，用以实例化该模板。 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;engine:UXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:engine="UnityEngine.UIElements" xmlns:editor="UnityEditor.UIElements" xsi:noNamespaceSchemaLocation="../../UIElementsSchema/UIElements.xsd"&gt; &lt;!--注意模板文件的路径--&gt; &lt;engine:Template path="Assets/Editor/Template.uxml" name="Player"/&gt; &lt;engine:VisualElement name="players"&gt; &lt;!--实例化该模板 并命名--&gt; &lt;!--template的值要跟前面定义的一致--&gt; &lt;engine:Instance template="Player" name="player1"/&gt; &lt;engine:Instance template="Player" name="player2"/&gt; &lt;engine:Instance template="Player" name="player3"/&gt; &lt;/engine:VisualElement&gt;&lt;/engine:UXML&gt; 使用C#加载TemplateDemo.uxml 123var visualTree = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;("Assets/Editor/TemplateDemo.uxml");VisualElement labelFromUXML = visualTree.CloneTree();root.Add(labelFromUXML); ControlsBaseField 所有Field类型元素的抽象基类 命名空间：UnityEngine.UIElements 子元素数量：0 属性 BindableElement的所有属性 focus-index：默认值为0 focusable：默认值为true label：与field关联的标签文本 BaseFieldTraits&lt;ValueType, UxmlType&gt; 继承自 BaseField&lt; ValueType &gt; 属性 BaseField&lt; ValueType &gt;的所有属性 value：字段的初始值，类型为 ValueType Button 标准按钮 命名空间：UnityEngine.UIElements 子元素数量：0 属性 TextElement的所有属性 RepeatButton 按下时重复执行动作的按钮 命名空间：UnityEngine.UIElements 子元素数量：0 属性 TextElement的所有属性 delay：按钮执行动作之前的初始延迟(毫秒)。默认值是0 interval：重复每个动作之间的毫秒间隔。默认值是0 Toggle 解释，略 命名空间：UnityEngine.UIElements 子元素数量：0 属性 BaseFieldTraits&lt; bool, UxmlBoolAttributeDescription &gt;的所有属性 text：开关右侧的标签文本 Scroller 滚动条 命名空间：UnityEngine.UIElements 子元素数量：0 属性 VisualElement的所有属性 low-value: 滚动条的最小值 high-value: 滚动条的最大值 direction: 滑动方向是水平还是竖直，默认是竖直的 value：滚动条的位置 Slider 滑动条，值为浮点数 命名空间：UnityEngine.UIElements 子元素数量：0 属性 BaseFieldTraits&lt; float, UxmlFloatAttributeDescription&gt;的所有属性 low-value:滑动条的最小值 high-value:滑动条的最大值 direction:滑动方向是水平还是竖直，默认是水平的 page-size:滑块的页面大小 SliderInt Int数值的滑动条 命名空间：UnityEngine.UIElements 子元素数量：0 属性 BaseFieldTraits&lt; int, UxmlIntAttributeDescription&gt;的所有属性 low-value、high-value、direction、page-size等属性同Slider，只是Value类型是int MinMaxSlider 允许用户指定最小值和最大值范围的slider 命名空间：UnityEngine.UIElements 子元素数量：0 属性 BaseField&lt; Vector2&gt;的所有属性 low-limit:最小值限制 high-limit:最大值限制 min-value:滑块的最小值 max-value:滑块的最大值 EnumField 绘制一个枚举类型的字段 命名空间：UnityEngine.UIElements 子元素数量：0 属性 BaseField&lt; Enum &gt;的所有属性 MaskField 多选菜单 命名空间：UnityEngine.UIElements 子元素数量：0 属性 choices: List&lt; string &gt;类型，显示在弹出菜单上选项 value: 一个整数，将字段的值表示为32位掩码 12MaskField maskField = new MaskField(new List&lt;string&gt;(2) &#123;"Mask1", "Mask2"&#125;,0);root.Add(maskField); LayerField 下拉菜单，选择一个Layer 命名空间：UnityEngine.UIElements 子元素数量：0 属性 BaseField&lt; int&gt;的所有属性 value: 表示字段值(所选层号)的整数。 12LayerField layerField = new LayerField();root.Add(layerField); LayerMaskField 下拉菜单，可以从中选择多个Layer 命名空间：UnityEngine.UIElements 子元素数量：0 属性 MaskField的所有属性 TagField 下拉菜单，可以从中选择一个Tag 命名空间：UnityEngine.UIElements 子元素数量：0 属性 BaseField的所有属性 value：选择的Tag 12TagField tagField = new TagField();root.Add(tagField); ProgressBar 进度条 命名空间：UnityEngine.UIElements 子元素数量：0 属性 BindableElement的所有属性 low-value：表示进度条的最小值的浮动。默认值是0 high-value：表示进度条的最大值的浮动。默认值是100。 title：表示进度条标题的字符串。 1234ProgressBar progressBar = new ProgressBar();progressBar.value = 50;progressBar.title = "Progress Bar";root.Add(progressBar); Text input各种类型的输入型元素，不一一介绍了。以下元素只能在Editor下使用。 TextField：可编辑的文本元素 IntegerField：32位整数的文本元素 LongField：64位整数的文本元素 FloatField：Float类型的文本元素 DoubleField：Double类型的文本元素 Vector2Field：Vector2类型的文本元素（float） Vector2IntField：Vector2类型的文本元素（int） Vector3Field：Vector3类型的文本元素（float） Vector3IntField：Vector3类型的文本元素（int） Vector4Field：Vector4类型的文本元素（float） RectField：包含四个文本字段的集合，它们接受浮点值来编辑矩形的值 RectIntField：包含四个文本字段的集合，它们接受整数值来编辑矩形的值。 BoundsField：一组六个文本字段，接受浮点值来编辑边框的值。 BoundsIntField：包含六个文本字段的集合，它们接受整数值来编辑边框的值。 Complex widgets以下几个元素只能在Editor下使用 ColorField：颜色选择器 CurveField：曲线编辑器 GradientField：渐变编辑器 ObjectField：对象选择器 InspectorElement：在Inspector窗口中显示属性的元素 Toolbar Toolbar：保存工具栏项的容器 ToolbarButton：工具栏按钮 ToolbarToggle：工具栏开关 ToolbarMenu：工具栏的下拉菜单 ToolbarSearchField：工具栏搜索框 ToolbarPopupSearchField：带有搜索选项弹出菜单的搜索字段 ToolbarSpacer：在工具栏之间插入固定数量的空白元素 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;engine:UXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:engine="UnityEngine.UIElements" xmlns:editor="UnityEditor.UIElements" xsi:noNamespaceSchemaLocation="../../UIElementsSchema/UIElements.xsd"&gt; &lt;editor:Toolbar&gt; &lt;editor:ToolbarButton text="Button"/&gt; &lt;editor:ToolbarToggle text="Toggle"/&gt; &lt;editor:ToolbarMenu text="Menu"/&gt; &lt;editor:ToolbarSearchField text="SearchField"/&gt; &lt;editor:ToolbarSpacer /&gt; &lt;editor:ToolbarPopupSearchField text="popupSearchField"/&gt; &lt;/editor:Toolbar&gt;&lt;/engine:UXML&gt; Views and windows ListView:元素列表 ScrollView:带有水平和垂直滚动条的可滚动视图。 TreeView:用于在树层次结构中显示元素的视图。 PopupWindow:一个UIElements窗口，显示在其他内容的顶部。（Editor） 更多的UIElement知识点文章，还在进行中，如有相关内容需要介绍的，可以在下方留言，抽空更新文章~ 以上知识分享，如有错误，欢迎指出，共同学习，共同进步，欢迎留言评论!]]></content>
      <categories>
        <category>Unity</category>
        <category>UIElement</category>
      </categories>
      <tags>
        <tag>UIElement</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UIElement入门]:0.UIElement EditorWindow简单介绍]]></title>
    <url>%2F2020%2F05%2F10%2Fuielement-ru-men-0-uielement-jian-dan-jie-shao%2F</url>
    <content type="text"><![CDATA[本系列文章介绍UIElement知识点，欢迎访问😉 UIElement官方文档 本系列文章使用的Unity版本为2019.3.7f1 本系列文章目录：UIElement : EditorWindow简单介绍UIElement : UXML元素介绍UIElement : UQuery介绍UIElement : Layout EngineUIElement : 自定义元素后续待更新内容：UIElement : Editor Demo Quick ToolUIElement : Layout Engine YogaLayoutUIElement : UIBuilder的使用介绍UIElement : 使用UIBuilder开发Editor Demo QuickToolUIElement : 使用UIElement开发GF框架的AssetBundlBuilderUIElement : Runtime Demo Tank UIElement EditorWindow本篇文章介绍如何在Editor下使用UIElement开发编辑器。 新建Editor文件夹，找到Assets-&gt;Create-&gt;UIElements菜单，或者在Project窗口鼠标右键Create-&gt;UIElements，该菜单下包含了以下三个菜单项。 USS File UXML Template Editor Window USSUSS全称Unity Style Sheets，定义设置视觉元素的尺寸和外观的样式属性。使用该菜单，会在当前目录下新建一个uss后缀的文件。 UXMLUXML文件是定义用户界面逻辑结构的文本文件。UXML文件中使用的格式受到HTML(超文本标记语言)、XAML(可扩展应用程序标记语言)和XML(可扩展标记语言)的启发。使用该菜单，会在当前目录下新建一个uxml后缀的文件。 Editor Window使用该菜单，会弹出以下窗口，显而易见，通过这个窗口能够快速创建图中的三类文件。 Open files in Editor once created:一旦创建好后就打开文件。 创建完后，Unity已经帮我们加上了三行文字，然后工程里多了三个相应的文件，并在菜单栏中也多了一条：Window-&gt;UIElements—&gt;TestEditor(我在创建时输入的测试名TestEditor)。 那么，接下来详细说明一下这个EditorWindow是如何工作的。 C#部分代码介绍会以注释的形式写在下方。 1234567891011121314151617181920212223242526272829303132333435363738using UnityEditor;using UnityEngine;using UnityEngine.UIElements;using UnityEditor.UIElements;public class TestEditor : EditorWindow&#123; //基础的MenuItem做法，不介绍了 [MenuItem("Window/UIElements/TestEditor")] public static void ShowExample() &#123; TestEditor wnd = GetWindow&lt;TestEditor&gt;(); wnd.titleContent = new GUIContent("TestEditor"); &#125; public void OnEnable() &#123; //在编辑器中，每个EditorWindow都有一个rootVisualElement属性，它表示层次结构的顶层VisualElement。元素需要作为子元素添加到这个根，以便系统绘制它们。 VisualElement root = rootVisualElement; //创建一个Label并加到root中进行绘制，Label的文字内容是Hello World! From C#，正如我们在示意图看到的第一行。 VisualElement label = new Label("Hello World! From C#"); root.Add(label); //加载创建出来的UXML文件，并克隆到root中。 var visualTree = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;("Assets/Editor/TestEditor.uxml"); VisualElement labelFromUXML = visualTree.CloneTree(); root.Add(labelFromUXML); //加载创建出来的USS文件 var styleSheet = AssetDatabase.LoadAssetAtPath&lt;StyleSheet&gt;("Assets/Editor/TestEditor.uss"); //创建一个Label，并使用加载USS样式 VisualElement labelWithStyle = new Label("Hello World! With Style"); //加到root上进行渲染。 labelWithStyle.styleSheets.Add(styleSheet); root.Add(labelWithStyle); &#125;&#125; 从这部分代码中可以看出来，使用代码创建了两个Label，其中一个没有使用USS样式，后面一个使用了USS样式，正如示意图中看到的那样，第一行无样式（默认样式），第三行是蓝色的字号偏大。那么问题来，中间一行Label，从哪里来？ [ps:再以不用手写Layout了🤣🤣🤣] UXML部分UXML文件内容如下： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;engine:UXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:engine="UnityEngine.UIElements" xmlns:editor="UnityEditor.UIElements" xsi:noNamespaceSchemaLocation="../../UIElementsSchema/UIElements.xsd"&gt; &lt;engine:Label text="Hello World! From UXML" /&gt;&lt;/engine:UXML&gt; 我们目前只关注其中的&lt;engine:Label text=”Hello World! From UXML” /&gt;，这行代码创建了一个Label，文字内容为Hello World! From UXML。那么很显然了，C#部分代码中是在创建两个Label中间Load并add的UXML文件，因此该Label渲染在那两个Label中间。那如果把Load UXML的相关代码放到最前面，这行UXML Label就应该渲染在最前面了。 USS部分UXML文件内容如下： 12345Label &#123; font-size: 20px; -unity-font-style: bold; color: rgb(68, 138, 255);&#125; 该样式文件里定义了一个Label,其中字号20，粗体，颜色（68、138、255）。更多的样式及其属性，后面另行介绍。 更多的UIElement知识点文章，还在进行中，如有相关内容需要介绍的，可以在下方留言，抽空更新文章~ 以上知识分享，如有错误，欢迎指出，共同学习，共同进步，欢迎留言评论!]]></content>
      <categories>
        <category>Unity</category>
        <category>UIElement</category>
      </categories>
      <tags>
        <tag>UIElement</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之三十一:获取PlayerPrefs所有键值对]]></title>
    <url>%2F2020%2F05%2F05%2Funity-bian-ji-qi-tuo-zhan-zhi-san-shi-yi-huo-qu-playerprefs-suo-you-jian-zhi-dui%2F</url>
    <content type="text"><![CDATA[本文介绍如何在Editor下获取PlayerPrefs所有键值对，欢迎访问😁 本篇文章，如果有不懂，欢迎留言~click here! PlayerPrefs官方文档，请戳这里~click here! 正文关于PlayerPrefs使用细节就不介绍了，实际上，在开发中，已经没怎么使用PlayerPrefs了，这里只是单纯的介绍一下如何获取所有的键值对，毕竟Unity并没有提供直接的接口。 只有DeleteAll接口，没有GetAll接口。 本篇文章的主要代码来源于PlayerPrefs Editor插件，插件自行下载。 数据存储 官方文档中有介绍，MacOS下存储在~/Library/Preferences文件夹下的unity.[company name].[product name].plist文件中，而Window下\Software[company name][product name]注册表中，因此待会儿获取代码中，MacOS下需要解析到plist文件，而Window下则需要读取注册表。 定义一个结构体PlayerPrefPair对应keyvalue键值对。 123456789using System;[Serializable]public struct PlayerPrefPair&#123; public string Key &#123; get; set; &#125; public object Value &#123; get; set; &#125;&#125; 获取键值对的主要代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132using System;using System.Collections.Generic;using System.IO;using Sabresaurus.PlayerPrefsExtensions;using UnityEditor;using UnityEngine;public static class PlayerPrefsExtension&#123; public static PlayerPrefPair[] GetAll() &#123; return GetAll(PlayerSettings.companyName, PlayerSettings.productName); &#125; public static PlayerPrefPair[] GetAll(string companyName, string productName) &#123; if (Application.platform == RuntimePlatform.OSXEditor) &#123; // From Unity docs: On Mac OS X PlayerPrefs are stored in ~/Library/Preferences folder, in a file named unity.[company name].[product name].plist, where company and product names are the names set up in Project Settings. The same .plist file is used for both Projects run in the Editor and standalone players. // Construct the plist filename from the project's settings string plistFilename = string.Format("unity.&#123;0&#125;.&#123;1&#125;.plist", companyName, productName); // Now construct the fully qualified path string playerPrefsPath = Path.Combine(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Personal), "Library/Preferences"), plistFilename); // Parse the player prefs file if it exists if (File.Exists(playerPrefsPath)) &#123; // Parse the plist then cast it to a Dictionary object plist = Plist.readPlist(playerPrefsPath); Dictionary&lt;string, object&gt; parsed = plist as Dictionary&lt;string, object&gt;; // Convert the dictionary data into an array of PlayerPrefPairs PlayerPrefPair[] tempPlayerPrefs = new PlayerPrefPair[parsed.Count]; int i = 0; foreach (KeyValuePair&lt;string, object&gt; pair in parsed) &#123; if (pair.Value.GetType() == typeof(double)) &#123; // Some float values may come back as double, so convert them back to floats tempPlayerPrefs[i] = new PlayerPrefPair() &#123;Key = pair.Key, Value = (float) (double) pair.Value&#125;; &#125; else &#123; tempPlayerPrefs[i] = new PlayerPrefPair() &#123;Key = pair.Key, Value = pair.Value&#125;; &#125; i++; &#125; // Return the results return tempPlayerPrefs; &#125; else &#123; // No existing player prefs saved (which is valid), so just return an empty array return new PlayerPrefPair[0]; &#125; &#125; else if (Application.platform == RuntimePlatform.WindowsEditor) &#123; // From Unity docs: On Windows, PlayerPrefs are stored in the registry under HKCU\Software\[company name]\[product name] key, where company and product names are the names set up in Project Settings.#if UNITY_5_5_OR_NEWER // From Unity 5.5 editor player prefs moved to a specific location Microsoft.Win32.RegistryKey registryKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey("Software\\Unity\\UnityEditor\\" + companyName + "\\" + productName);#else Microsoft.Win32.RegistryKey registryKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey("Software\\" + companyName + "\\" + productName);#endif // Parse the registry if the specified registryKey exists if (registryKey != null) &#123; // Get an array of what keys (registry value names) are stored string[] valueNames = registryKey.GetValueNames(); // Create the array of the right size to take the saved player prefs PlayerPrefPair[] tempPlayerPrefs = new PlayerPrefPair[valueNames.Length]; // Parse and convert the registry saved player prefs into our array int i = 0; foreach (string valueName in valueNames) &#123; string key = valueName; // Remove the _h193410979 style suffix used on player pref keys in Windows registry int index = key.LastIndexOf("_"); key = key.Remove(index, key.Length - index); // Get the value from the registry object ambiguousValue = registryKey.GetValue(valueName); // Unfortunately floats will come back as an int (at least on 64 bit) because the float is stored as // 64 bit but marked as 32 bit - which confuses the GetValue() method greatly! if (ambiguousValue.GetType() == typeof(int)) &#123; // If the player pref is not actually an int then it must be a float, this will evaluate to true // (impossible for it to be 0 and -1 at the same time) if (PlayerPrefs.GetInt(key, -1) == -1 &amp;&amp; PlayerPrefs.GetInt(key, 0) == 0) &#123; // Fetch the float value from PlayerPrefs in memory ambiguousValue = PlayerPrefs.GetFloat(key); &#125; &#125; else if (ambiguousValue.GetType() == typeof(byte[])) &#123; // On Unity 5 a string may be stored as binary, so convert it back to a string ambiguousValue = System.Text.Encoding.Default.GetString((byte[]) ambiguousValue); &#125; // Assign the key and value into the respective record in our output array tempPlayerPrefs[i] = new PlayerPrefPair() &#123;Key = key, Value = ambiguousValue&#125;; i++; &#125; // Return the results return tempPlayerPrefs; &#125; else &#123; // No existing player prefs saved (which is valid), so just return an empty array return new PlayerPrefPair[0]; &#125; &#125; else &#123; throw new NotSupportedException("PlayerPrefsEditor doesn't support this Unity Editor platform"); &#125; &#125;&#125; 其中关于MacOS下解析plist文件呢，PlayerPrefsEditor插件里使用的一个开源库：https://github.com/animetrics/PlistCS 最后，编写一点测试代码： 1234567891011121314using UnityEditor;public class PlayerPrefsTool : Editor&#123; [MenuItem("Tools/PrintAllPlayerPrefs")] public static void LogAllPlayerPrefs() &#123; PlayerPrefPair[] keyValues = PlayerPrefsExtension.GetAll(); for (int i = 0; i &lt; keyValues.Length; i++) &#123; UnityEngine.Debug.Log($"key=&#123;keyValues[i].Key&#125; value=&#123;keyValues[i].Value&#125;"); &#125; &#125;&#125; 这里并不包含如何在移动端获取到所有键值对，个人建议自行编写一个数据本地存储，方便无坑无烦恼。。。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。如果有不懂，欢迎留言评论!]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>PlayerPrefs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity接入Facebook生成keyhash]]></title>
    <url>%2F2020%2F05%2F02%2Funity-jie-ru-facebook-sheng-cheng-keyhash%2F</url>
    <content type="text"><![CDATA[记录如何为Unity工程接入Facebook SDK时生成keyhash，欢迎访问😋 本篇文章，如果有不懂，欢迎留言~click here! 以下步骤在Facebook中为Unity应用程序生成Key Hash：（我正在使用Mac OSX 10.8 ） 首先打开一个terminal（在Windows中打开一个命令提示符）。在terminal中导航到您的Unity工程下工程的keystore所在的目录。 进入keystore所在的目录，运行以下命令。 1keytool -exportcert -alias &#123;这里填keystore的别名&#125; -keystore &#123;这里填keystore文件名&#125;.keystore | openssl sha1 -binary | openssl base64 keystore的别名可以在unity工程中下图位置中找到 当它提示你输入密码时，输入创建keystore的密码并按回车。 复制以“=”结尾的打印在terminal中的值，并将其粘贴到Facebook中的Key Hash字段中。 然后点击保存更改。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。如果有不懂，欢迎留言评论!]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Facebook keyhash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity每天一个小技巧-Image组件转换RawImage组件]]></title>
    <url>%2F2020%2F05%2F02%2Funity-mei-tian-yi-ge-xiao-ji-qiao-image-zu-jian-ti-huan-cheng-rawimage-zu-jian%2F</url>
    <content type="text"><![CDATA[Image组件转换为RawImage组件，方便快捷~ 写在开头 本篇文章，如果有不懂，欢迎留言~click here! 源码1234567891011121314151617181920212223242526using System.Collections;using System.Collections.Generic;using UnityEditor;using UnityEngine;using UnityEngine.UI;public class UnityComponentExtensionMenu : UnityEditor.Editor&#123; [MenuItem("CONTEXT/Image/转换成RawImage")] public static void ReplaceImageToRawImage() &#123; Image imageCom = Selection.activeGameObject.GetComponent&lt;Image&gt;(); if (imageCom != null) &#123; Texture2D texture2D = imageCom.sprite.texture; bool ray = imageCom.raycastTarget; Material material = imageCom.material; DestroyImmediate(imageCom); RawImage rawImage = Selection.activeGameObject.AddComponent&lt;RawImage&gt;(); rawImage.texture = texture2D; rawImage.raycastTarget = ray; rawImage.material = material; EditorUtility.SetDirty(Selection.activeGameObject); &#125; &#125;&#125; 写在结尾 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。如果有不懂，欢迎留言评论!]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity每天一个小技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python:爬取FaceBook用户头像]]></title>
    <url>%2F2020%2F05%2F02%2Fpython-pa-qu-facebook-yong-hu-tou-xiang%2F</url>
    <content type="text"><![CDATA[使用Python批量爬取下载FB用户头像，欢迎访问😂 本篇文章，如果有不懂，欢迎留言~click here! Python爬取源码本文介绍的爬取方法是基于已经有一些用户的sns_id了，然后通过头像链接进行头像下载。 以下是一些用户的sns_id和用户名 123456789101110157645719968407,Samer Khalil Zeidan2332954523430968,Ly Chanheng296879167966753,Larbas Ramy2207530449281477,Ryan Sparks125162838732018,Louis Harrison598577013979694,Noja1035700643475774,Mannie Smith1375390332610824,RaiiMz 187925459051038,Kerstin Mrowka955693851449409,Dany Trentini801025260289121,Caleb M Fiene 头像下载链接是一个固定格式，https://graph.facebook.com/{sns_id}/picture?type=large ，将sns_id填到链接中即可。那么接下来，只需要批量下载即可，这里使用的是urlretrieve下载。 12345678910111213141516171819202122232425262728293031#!/usr/bin/python# -*- coding: UTF-8 -*- import osfrom urllib.request import urlretrieveos.makedirs('./image/', exist_ok=True) def urllib_download(sns_id, user_name): try: urlretrieve("https://graph.facebook.com/&#123;&#125;/picture?type=large".format(sns_id), './image/&#123;&#125;.png'.format(user_name)) except BaseException: print(sns_id,user_name)# 打开文件# 这里是sns_user的一个CSV文件fo = open("/Users/teitomonari/Desktop/sns_user.csv", "r")print("文件名为: ", fo.name)for line in fo.readlines(): #依次读取每行 line = line.strip() #去掉每行头尾空白 infos = line.split(',',1) print(infos[0],infos[1]) urllib_download(infos[0],infos[1])# 关闭文件fo.close() FB用户文件下载链接https://github.com/JingFengJi/JingFengJi.github.io/blob/master/sns_user.csv 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。如果有不懂，欢迎留言评论!]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo-theme-butterfly拓展友链分类]]></title>
    <url>%2F2020%2F04%2F05%2Fhexo-theme-butterfly-tuo-zhan-you-lian-fen-lei%2F</url>
    <content type="text"><![CDATA[hexo-theme-butterfly创建友链界面关于如何创建友链界面查看官方文档 https://jerryc.me/posts/dc584b87/#%E5%8F%8B%E6%83%85%E9%8F%88%E6%8E%A5 创建后的效果就像这样：http://www.jingfengji.tech/link/ 其中”友情链接”这四个字是在link.yml的class_name，可以自行修改。link.yml里的link_list就是友链的数据了。 拓展友链分类新建一个跟link.yml一样结构的文件，我这里举例为gamedeveloper.yml，放在source/_data中，class_name我改为Game Developer。 然后找到flink.pug文件，复制下面这一段代码 修改复制那一段的site.data.link 中的link为前面新建的gamedeveloper.yml的文件名，如下所示： 1234567891011121314151617181920212223242526272829303132#page .flink#article-container each i in site.data.gamedeveloper h2= i.class_name .post-cards .md-links each item in i.link_list .md-links-item a(href=item.link title=item.name target="_blank") if theme.lazyload.enable img.lazyload(data-src=item.avatar onerror=`this.onerror=null;this.src='` + url_for(theme.lodding_bg.flink) + `'` alt=item.name ) else img(src=item.avatar onerror=`this.onerror=null;this.src='` + url_for(theme.lodding_bg.flink) + `'` alt=item.name ) .md-links-title= item.name .md-links-des= item.descr .flink#article-container each i in site.data.link h2= i.class_name .post-cards .md-links each item in i.link_list .md-links-item a(href=item.link title=item.name target="_blank") if theme.lazyload.enable img.lazyload(data-src=item.avatar onerror=`this.onerror=null;this.src='` + url_for(theme.lodding_bg.flink) + `'` alt=item.name ) else img(src=item.avatar onerror=`this.onerror=null;this.src='` + url_for(theme.lodding_bg.flink) + `'` alt=item.name ) .md-links-title= item.name .md-links-des= item.descr != page.content if page.comments !== false include includes/comments/index.pug != page.content 这一行不要复制了。 最终效果：http://www.jingfengji.tech/link/ 2020.4.10 更新经群友 云玩家(https://blog.zplayer.cloud) 指教，上面方法复杂了，直接在link.yml里复制一个class即可，如下所示： 一个class对应一个分类，效果跟前面是一样的，这个方法简单得多。]]></content>
      <categories>
        <category>Hexo</category>
        <category>Hexo-Theme-Butterfly</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之三十：拓展UnityToolBar]]></title>
    <url>%2F2020%2F04%2F05%2Funity-bian-ji-qi-tuo-zhan-zhi-san-shi-tuo-zhan-unitytoolbar%2F</url>
    <content type="text"><![CDATA[Unity ToolBar拓展开源库 https://github.com/arimger/Unity-Editor-Toolbox.git https://github.com/smkplus/CustomToolbar.git https://github.com/marijnz/unity-toolbar-extender.git Unity-Editor-Toolbox这个开源库里包含了很多Editor拓展，本篇仅介绍Toolbar的拓展，关于Toolbar的介绍：https://github.com/arimger/Unity-Editor-Toolbox#toolbar- 详细代码：https://github.com/arimger/Unity-Editor-Toolbox/blob/master/Assets/Editor%20Toolbox/Editor/ToolboxEditorToolbar.cs 如果只需要Toolbar拓展，只需要把这一个脚本拷贝到工程下Editor目录，再建一个添加Toolbar菜单的脚本。 1234567891011121314using Toolbox.Editor;[UnityEditor.InitializeOnLoad]public static class MyEditorUtility&#123; static MyEditorUtility() &#123; ToolboxEditorToolbar.AddToolbarButton(new ToolbarButton(() =&gt; Debug.Log("1"), new GUIContent("1"))); ToolboxEditorToolbar.AddToolbarButton(new ToolbarButton(() =&gt; Debug.Log("2"), new GUIContent("2"))); ToolboxEditorToolbar.AddToolbarButton(new ToolbarButton(() =&gt; Debug.Log("3"), new GUIContent("3"))); ToolboxEditorToolbar.AddToolbarButton(new ToolbarButton(() =&gt; Debug.Log("4"), new GUIContent("4"))); ToolboxEditorToolbar.AddToolbarButton(new ToolbarButton(() =&gt; Debug.Log("5"), new GUIContent("5"))); &#125;&#125; 这个仓库的菜单只会添加在左侧。 经过测试，按照仓库设计的按钮大小，只够放置7个按钮，当然各个unity版本的Toolbar中间的宽度不一，会有点差异。 CustomToolbar这个仓库实现的自定义Toolbar示意图如下： 仓库拓展了5个功能，是基于unity-toolbar-extender开发的。这个库支持往左右两边添加自定义菜单。 这五个功能包含在下图的脚本中 保留ToolbarCallback和ToolbarExtender脚本，通过往ToolbarExtender.RightToolbarGUI和ToolbarExtender.LeftToolbarGUI添加Action，即可绘制自定义的菜单。 unity-toolbar-extender CustomToolbar库是基于unity-toolbar-extender的，那么如何使用跟前面讲的一样。这个库自带的是 切换场景运行 Focus Scene开关，如果打开，则运行游戏后，自动Focus Scene View 核心代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static class ToolbarCallback&#123; //反射获取Toolbar类型 static Type m_toolbarType = typeof(Editor).Assembly.GetType("UnityEditor.Toolbar"); //反射获取GUIView类型 static Type m_guiViewType = typeof(Editor).Assembly.GetType("UnityEditor.GUIView"); static PropertyInfo m_viewVisualTree = m_guiViewType.GetProperty("visualTree", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance); static FieldInfo m_imguiContainerOnGui = typeof(IMGUIContainer).GetField("m_OnGUIHandler", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance); static ScriptableObject m_currentToolbar; /// &lt;summary&gt; /// Callback for toolbar OnGUI method. /// &lt;/summary&gt; public static Action OnToolbarGUI; static ToolbarCallback() &#123; EditorApplication.update -= OnUpdate; EditorApplication.update += OnUpdate; &#125; static void OnUpdate() &#123; // Relying on the fact that toolbar is ScriptableObject and gets deleted when layout changes if (m_currentToolbar == null) &#123; //获取到原有的Toolbar var toolbars = Resources.FindObjectsOfTypeAll(m_toolbarType); m_currentToolbar = toolbars.Length &gt; 0 ? (ScriptableObject) toolbars[0] : null; if (m_currentToolbar != null) &#123; //获取Toolbar的VisualTree var visualTree = (VisualElement) m_viewVisualTree.GetValue(m_currentToolbar, null); // Get first child which 'happens' to be toolbar IMGUIContainer var container = (IMGUIContainer) visualTree[0]; //重新注册handler var handler = (Action) m_imguiContainerOnGui.GetValue(container); handler -= OnGUI; handler += OnGUI; m_imguiContainerOnGui.SetValue(container, handler); &#125; &#125; &#125; //自定义的绘制函数 static void OnGUI() &#123; var handler = OnToolbarGUI; if (handler != null) handler(); &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>ToolBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity每天一个小技巧-UnityPackage的导入开始、完成、取消、失败回调事件]]></title>
    <url>%2F2020%2F04%2F03%2Funity-mei-tian-yi-ge-xiao-ji-qiao-unitypackage-de-dao-ru-kai-shi-wan-cheng-qu-xiao-shi-bai-hui-diao-shi-jian%2F</url>
    <content type="text"><![CDATA[UnityPackage的导入开始、完成、取消、失败回调事件123456789101112131415161718192021222324252627282930using UnityEditor;using UnityEngine;[InitializeOnLoad]public static class UnityPackageImportListener&#123; static UnityPackageImportListener() &#123; // .unitypackage开始导入 AssetDatabase.importPackageStarted += packageName =&gt; &#123; Debug.Log( packageName ); &#125;; // .unitypackage导入完成 AssetDatabase.importPackageCompleted += packageName =&gt; &#123; Debug.Log( packageName ); &#125;; // .unitypackage取消导入 AssetDatabase.importPackageCancelled += packageName =&gt; &#123; Debug.Log( packageName ); &#125;; // .unitypackage导入失败 AssetDatabase.importPackageFailed += ( packageName, errorMessage ) =&gt; &#123; Debug.Log( errorMessage ); &#125;; &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity每天一个小技巧</category>
      </categories>
      <tags>
        <tag>UnityPackage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之SpriteAtlas详解]]></title>
    <url>%2F2020%2F03%2F29%2Funity-zhi-spriteatlas-xiang-jie%2F</url>
    <content type="text"><![CDATA[Unity之SpriteAtlas详解Unity官方介绍：https://docs.unity3d.com/Manual/class-SpriteAtlas.html SpriteAtlas Inspector面板如下图： 创建方法： 1、Project面板鼠标右键Create-&gt;Sprite Atlas 2、菜单栏Asset-&gt;Create-&gt;Sprite Atlas 属性介绍:TypeSpriteAtlas有两种类型，Master或者Variant，默认类型是MAster；Variant是变体类型，创建一个变体图集，并声明它是项目中一个现有SpriteAtlas的变体，如下图，变体图集将复制母版图集的纹理，然后根据scale调整变体图集的大小。 Include in Build选中此复选框以将Sprite Atlas资产包含在当前版本中。默认情况下启用此选项。Scale变体图集缩放数值，值可以从0.1到1Allow Rotation是否允许Unity将打包到SpriteAtlas中的Sprite进行旋转，如果允许，可以最大化提高图集中Sprite的密度，默认允许旋转。如果是在UGUI中使用SpriteAtlas，应该禁用旋转Tight Packing根据Sprite轮廓而不是默认的矩形轮廓打包Sprite，进一步提高图集中Sprite的密度，默认是启用的，在UGUI中使用SpriteAtlas应该禁用Padding图集中各个Sprite之间的像素距离，避免图集中彼此相邻的Sprite发生像素重叠。默认为4像素，支持2、4、8三种选择。Objects For PackingUnity将此列表中的所有内容打包成一个图集。支持拖入一个文件夹或者一个单独的Sprite。Sprite PackerSpritePacker默认是关闭的状态，在Edit -&gt; Project Settings -&gt; Editor中将SpritePacker Mode更改为Enable，Always Enabled选项始终打开。打开后回到SpriteAtlas Inspector面板，点击Pack Preview按钮就可以在预览窗口看到图集了。Late Binding从语义来看称之为后期绑定，也就是说在运行时以不引用图集的形式启动，并且在绑定图集之前将显示为空白。如果在启动过程中图集来源于网络下载，这样就允许用户进行后期绑定了。Late Binding via callback1、Sprite打包到SpriteAtlas中，SpriteAtlas未选中Include In Build，sprite在场景中就不可见 2、SpriteAtlas.atlasRequested这个委托方法提供一个告知上层逻辑要绑定的图集标签和包含SpriteAtlas资产的Action，通过这个委托，上层逻辑根据图集标签自行加载管理图集，并将加载好的图集通过第二个参数Action告知给底层。至于如何根据图集标签加载图集，不在本篇文章范围内。SpriteAtlas.atlasRequested的第一个参数string类型的tag就是需要加载的图集文件名，SpriteAtlas本身无法指定Tag。 SpriteAtlas &amp; AssetBundle取消Inclue in build选项打包，运行时使用SpriteAtlas.atlasRequested回调得到需要加载的图集Tag，使用自己项目中的资源模块进行SpriteAtlas加载后并执行回调传给底层。 参考文章https://forum.unity.com/threads/about-include-in-build-behaviour.481433/]]></content>
      <categories>
        <category>Unity</category>
        <category>SpriteAtlas</category>
      </categories>
      <tags>
        <tag>SpriteAtlas详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UnityTips——Unity小技巧集合]]></title>
    <url>%2F2019%2F12%2F21%2Funitytips-unity-xiao-ji-qiao-ji-he%2F</url>
    <content type="text"><![CDATA[AttributeRequiredAttribute效果图如下：当引用类型的property为空时，使用红色提示。 代码如下： 1、RequiredAttribute.cs 12345using UnityEngine;public class RequiredAttribute : PropertyAttribute&#123; &#125; 2、RequiredDrawer.cs 1234567891011121314151617using UnityEditor;using UnityEngine;[CustomPropertyDrawer(typeof(RequiredAttribute))]public class RequiredDrawer : PropertyDrawer&#123; public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) &#123; Color c = GUI.backgroundColor; if ((property.propertyType == SerializedPropertyType.ObjectReference || property.propertyType == SerializedPropertyType.ExposedReference) &amp;&amp; property.objectReferenceValue == null) &#123; GUI.backgroundColor = Color.red; &#125; EditorGUI.PropertyField(position, property); GUI.backgroundColor = c; &#125;&#125; 3、测试脚本RequiredAttributeDemo.cs 12345using UnityEngine;public class RequiredAttributeDemo : MonoBehaviour&#123; [Required] public Transform _transform;&#125; TipsDebug.Log日志点击Debug.Log 官方文档介绍地址：https://docs.unity3d.com/ScriptReference/Debug.Log.html 脚本改类名，同时修改文件名Rider、VS使用快捷键Ctrl+R+R，弹出改名框 离开编辑模式，进入运行模式时，保存Scene和Assets 12345678910111213141516171819202122using UnityEditor; using UnityEditor.SceneManagement; using UnityEngine; [InitializeOnLoad] public class AutoSave &#123; static AutoSave() &#123; EditorApplication.playModeStateChanged += SaveOnPlay; &#125; private static void SaveOnPlay(PlayModeStateChange state) &#123; if (state == PlayModeStateChange.ExitingEditMode) &#123; Debug.Log("Exiting Edit Mode,Auto Save..."); EditorSceneManager.SaveOpenScenes(); AssetDatabase.SaveAssets(); &#125; &#125; &#125; Unity多语言修改起因：群友想修改AudioSource组件的Inspector面板中Volume字段的提示内容。 然后我一查Editor脚本，https://github.com/Unity-Technologies/UnityCsReference/blob/2019.3/Editor/Mono/Inspector/AudioSourceInspector.cs 这写死了，，，怎么改。。。 后来群友提醒到Unity现在支持多语言，那就下载一个中文包看看。 中文包下载下来是上图中的一个.po文件 看样子是以一个msgid对应一个msgstr，msgid就是英文的内容，msgstr就是各语言的内容了。 接着找”Sets the overall volume of the sound.” 对应的中文内容就是上面了。。 那么.po文件自己修改后，重启Unity后就可以应用上去了。 测试以下: msgstr “设置声音的整体音量。” 修改成 msgstr “设置声音的整体音量。（修改版）” 如上图，修改成功。 那么，回到那位群友的问题，如果只修改那个Volume的提示文本呢，很简单，把.po文件的其他内容都删掉，文件头的内容别删了，只留下这个msgid和msgstr，别的都id和str都删了，这样就实现了修改Volume的提示文本了。 如下图： 不过中文的.po文件 是用的 中文的字体，总之，看着就是别扭。。。 添加自定义HeaderGUI官方链接说明 123456789101112131415161718192021222324using UnityEditor;[InitializeOnLoadAttribute]static class EditorHeaderGUID&#123; static EditorHeaderGUID() &#123; Editor.finishedDefaultHeaderGUI += DisplayGUIDIfPersistent; &#125; static void DisplayGUIDIfPersistent(Editor editor) &#123; if (!EditorUtility.IsPersistent(editor.target)) return; var guid = AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(editor.target)); var totalRect = EditorGUILayout.GetControlRect(); var controlRect = EditorGUI.PrefixLabel(totalRect, EditorGUIUtility.TrTempContent("GUID")); if (editor.targets.Length &gt; 1) EditorGUI.LabelField(controlRect, EditorGUIUtility.TrTempContent("[Multiple objects selected]")); else EditorGUI.SelectableLabel(controlRect, guid); &#125;&#125; OnValidata数据检查OnValidata官方文档介绍 在编辑器中可以使用 OnValidate() 对输入的数据进行检查。（仅编辑状态下有效） 12345678910using UnityEngine;using System.Collections; public class OnValidateExample : MonoBehaviour &#123; public float validateTestValue; void OnValidate() &#123; //Check validateTestValue &#125;&#125; 拖拽多个元素到 inspector可以拖拽元素直接加到 inspector 中去，但是选择多个元素的时候就不容易做到了，其实有一个方法，就是先锁定 inspector，就可以轻易的将多个元素（对象）拖拽到 inspector 中了。 使用代码赋值androidSplashScreen Unity没有提供直接的接口给这个赋值，以下提供几种方法，给它赋值。 反射 使用File.ReadAllText读取ProjectSettings.asset文件，替换掉androidSplashScreen: {fileID: 2800000, guid: 8d7f092f78c6bcb429a60803a22bf208, type: 3}其中的guid为自己图片的guid，然后保存即可 加载ProjectSetting，使用SerializedProperty修改其androidSplashScreen.m_FileID的intValue。 第三种方法的代码如下： 123456789101112131415//加载图片，替换自己的图片路径Texture2D tex = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;("Assets/Logo/logo_default.png");//加载ProjectSettingsconst string projectSettings = "ProjectSettings/ProjectSettings.asset";UnityEngine.Object obj = AssetDatabase.LoadAllAssetsAtPath(projectSettings)[0];SerializedObject psObj = new SerializedObject(obj);//获取到androidSplashScreen PropertySerializedProperty androidSplashFileId = psObj.FindProperty("androidSplashScreen.m_FileID");if (androidSplashFileId != null)&#123; androidSplashFileId.intValue = tex.GetInstanceID();&#125;//保存修改psObj.ApplyModifiedProperties();AssetDatabase.SaveAssets(); 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。本主题持续更新。。。]]></content>
      <categories>
        <category>Unity</category>
        <category>UnityTips</category>
      </categories>
      <tags>
        <tag>UnityTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GameFramework框架源码解读（一）：Editor篇]]></title>
    <url>%2F2019%2F10%2F26%2Fgameframework-kuang-jia-yuan-ma-jie-du-yi-editor-pian%2F</url>
    <content type="text"><![CDATA[笔记目录@[toc] 前言本文将使用StarForce案例，结合源码和Editor界面介绍一下GF中所有的Editor界面（包括Inspector），持续更新。 StarForce地址：https://github.com/EllanJiang/StarForceGameFramework地址：https://github.com/EllanJiang/GameFrameworkUnityGameFramework地址：https://github.com/EllanJiang/UnityGameFrameworkGameFramework官方网站：http://gameframework.cn/ 本文所讲解的内容如与你使用的框架版本有所差异，请阅读源码，源码即文档。。 菜单栏Game FrameworkOpen Folder待续 Scenes in Build Settings待续 Log Scripting Define Symbols待续 AssetBundle Tools AssetBundle工具相关配置AB的XML配置一共有三个，分别是AssetBundleEditor.xml、AssetBundleCollection.xml、AssetBundleBuilder.xml在StarForce案例中，它们在Assets/GameMain/Configs文件中，然而配置的默认路径并不在这里，这个路径是可以自定义的。 123456//AssetBundleEditorController.cs文件中public AssetBundleEditorController()&#123; m_ConfigurationPath = Type.GetConfigurationPath&lt;AssetBundleEditorConfigPathAttribute&gt;() ?? Utility.Path.GetCombinePath(Application.dataPath, "GameFramework/Configs/AssetBundleEditor.xml"); //...省略&#125; 1234567//AssetBundleCollection.cs文件中public AssetBundleCollection()&#123; m_ConfigurationPath = Type.GetConfigurationPath&lt;AssetBundleCollectionConfigPathAttribute&gt;() ?? Utility.Path.GetCombinePath(Application.dataPath, "GameFramework/Configs/AssetBundleCollection.xml"); m_AssetBundles = new SortedDictionary&lt;string, AssetBundle&gt;(); m_Assets = new SortedDictionary&lt;string, Asset&gt;();&#125; 123456//AssetBundleBuilderController.cs文件中public AssetBundleBuilderController()&#123; m_ConfigurationPath = Type.GetConfigurationPath&lt;AssetBundleBuilderConfigPathAttribute&gt;() ?? Utility.Path.GetCombinePath(Application.dataPath, "GameFramework/Configs/AssetBundleBuilder.xml"); //...省略&#125; 从上面摘抄的源码中可以看出，会先通过Type.GetConfigurationPath接口（AssetBundleEditorConfigPathAttribute、AssetBundleCollectionConfigPathAttribute、AssetBundleBuilderConfigPathAttribute）找到本地定义的路径，如果没有找到，则使用后面的默认路径。【注：Type.GetConfigurationPath接口自行看源码】 而在StarForce案例中，GameFrameworkConfigs.cs案例中定义了这几个路径 AssetBundleEditor.xml配置格式介绍 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;UnityGameFramework&gt; &lt;AssetBundleEditor&gt; &lt;Settings&gt; &lt;!--配置资源搜索的根目录，可以从Assets根部全部查找，可以配置成子目录--&gt; &lt;SourceAssetRootPath&gt;Assets/GameMain&lt;/SourceAssetRootPath&gt; &lt;!--配置资源搜索的子目录，相对于根目录的路径，支持配置多个子目录，如果为空，则搜索所有子目录--&gt; &lt;SourceAssetSearchPaths&gt; &lt;SourceAssetSearchPath RelativePath="" /&gt; &lt;/SourceAssetSearchPaths&gt; &lt;!--筛选并包含的资源类型--&gt; &lt;SourceAssetUnionTypeFilter&gt;t:Scene t:Prefab t:Shader t:Model t:Material t:Texture t:AudioClip t:AnimationClip t:AnimatorController t:Font t:TextAsset t:ScriptableObject&lt;/SourceAssetUnionTypeFilter&gt; &lt;!--筛选并包含的标签类型--&gt; &lt;SourceAssetUnionLabelFilter&gt;l:AssetBundleInclusive&lt;/SourceAssetUnionLabelFilter&gt; &lt;!--筛选并排除的资源类型--&gt; &lt;SourceAssetExceptTypeFilter&gt;t:Script&lt;/SourceAssetExceptTypeFilter&gt; &lt;!--筛选并排除的标签类型--&gt; &lt;SourceAssetExceptLabelFilter&gt;l:AssetBundleExclusive&lt;/SourceAssetExceptLabelFilter&gt; &lt;!--编辑器中资源列表的排序，可以是Name(资源文件名），Path（资源全路径），Guid（资源Guid）--&gt; &lt;AssetSorter&gt;Path&lt;/AssetSorter&gt; &lt;/Settings&gt; &lt;/AssetBundleEditor&gt;&lt;/UnityGameFramework&gt; AssetBundleEditorController.cs中的ScanSourceAssets就是通过以上配置搜索筛选的资源。 12345678910111213141516171819202122232425262728293031323334353637383940public void ScanSourceAssets()&#123; m_SourceAssets.Clear(); m_SourceAssetRoot.Clear(); string[] sourceAssetSearchPaths = m_SourceAssetSearchPaths.ToArray(); HashSet&lt;string&gt; tempGuids = new HashSet&lt;string&gt;(); //AssetDatabase.FindAssets接口返回的是搜索到的资源列表的guid数组，在Project的搜索栏中输入t:prefab也是进行这个接口的操作 //筛选并包含指定类型的资源 tempGuids.UnionWith(AssetDatabase.FindAssets(SourceAssetUnionTypeFilter, sourceAssetSearchPaths)); //筛选并包含指定标签的资源 tempGuids.UnionWith(AssetDatabase.FindAssets(SourceAssetUnionLabelFilter, sourceAssetSearchPaths)); //筛选并排除指定类型的资源 tempGuids.ExceptWith(AssetDatabase.FindAssets(SourceAssetExceptTypeFilter, sourceAssetSearchPaths)); //筛选并排除指定标签的资源 tempGuids.ExceptWith(AssetDatabase.FindAssets(SourceAssetExceptLabelFilter, sourceAssetSearchPaths)); string[] assetGuids = new List&lt;string&gt;(tempGuids).ToArray(); foreach (string assetGuid in assetGuids) &#123; string fullPath = AssetDatabase.GUIDToAssetPath(assetGuid); if (AssetDatabase.IsValidFolder(fullPath)) &#123; // Skip folder. continue; &#125; string assetPath = fullPath.Substring(SourceAssetRootPath.Length + 1); string[] splitPath = assetPath.Split('/'); SourceFolder folder = m_SourceAssetRoot; for (int i = 0; i &lt; splitPath.Length - 1; i++) &#123; SourceFolder subFolder = folder.GetFolder(splitPath[i]); folder = subFolder == null ? folder.AddFolder(splitPath[i]) : subFolder; &#125; SourceAsset asset = folder.AddAsset(assetGuid, fullPath, splitPath[splitPath.Length - 1]); m_SourceAssets.Add(asset.Guid, asset); &#125;&#125; 目前官方没有提供这个配置的编辑工具，需手动编辑xml文件。打开AssetBundleEditor窗口后，根据以上配置筛选资源形成界面的右侧树状图。 AssetBundleCollection.xml这个文件是通过AssetBundleEditor工具编辑好AB后，生成的文件。里面用来记录包含了哪些AB，AB中分别又包含了哪些资源，也就是对应了AssetBundleEditor窗口的左侧列表。 其中看一下AssetBundle和Asset中包含的内容： AssetBundle：（1）Name：AB的名称，主持路径（2）LoadType：AB的加载方式，对应下面的枚举 12345678910111213141516171819202122232425/// &lt;summary&gt;/// 资源加载方式类型。/// &lt;/summary&gt;public enum AssetBundleLoadType&#123; /// &lt;summary&gt; /// 从文件加载。 /// &lt;/summary&gt; LoadFromFile = 0, /// &lt;summary&gt; /// 从内存加载。 /// &lt;/summary&gt; LoadFromMemory, /// &lt;summary&gt; /// 从内存快速解密加载。 /// &lt;/summary&gt; LoadFromMemoryAndQuickDecrypt, /// &lt;summary&gt; /// 从内存解密加载。 /// &lt;/summary&gt; LoadFromMemoryAndDecrypt,&#125; （3）Variant：变体（4）ResourceGroups：资源组 Asset:（1）Guid：资源的guid（2）AssetBundleName：配置中上面所记录的AssetBundleName（3）AssetBundleVariant：变体 打开AssetBundleEditor窗口后，解析该配置，形成窗口左侧的树状图。 AssetBundleBuilder.xml该配置用来存储AB打包配置。界面如下图： 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;UnityGameFramework&gt; &lt;AssetBundleBuilder&gt; &lt;Settings&gt; &lt;!--内部资源版本号（Internal Resource Version）建议每次自增 1 即可，Game Framework 判定资源包是否需要更新，是使用此编号作为判定依据的。--&gt; &lt;InternalResourceVersion&gt;0&lt;/InternalResourceVersion&gt; &lt;!--打包平台--&gt; &lt;Platforms&gt;1&lt;/Platforms&gt; &lt;!--Zip All AssetBundles是否勾选，true为勾选，false为不勾选--&gt; &lt;ZipSelected&gt;True&lt;/ZipSelected&gt; &lt;!--以下几个配置分别对应AssetBundleOptions的几个Option是否勾选，true为勾选，false为不勾选--&gt; &lt;UncompressedAssetBundleSelected&gt;False&lt;/UncompressedAssetBundleSelected&gt; &lt;DisableWriteTypeTreeSelected&gt;False&lt;/DisableWriteTypeTreeSelected&gt; &lt;DeterministicAssetBundleSelected&gt;True&lt;/DeterministicAssetBundleSelected&gt; &lt;ForceRebuildAssetBundleSelected&gt;False&lt;/ForceRebuildAssetBundleSelected&gt; &lt;IgnoreTypeTreeChangesSelected&gt;False&lt;/IgnoreTypeTreeChangesSelected&gt; &lt;AppendHashToAssetBundleNameSelected&gt;False&lt;/AppendHashToAssetBundleNameSelected&gt; &lt;ChunkBasedCompressionSelected&gt;True&lt;/ChunkBasedCompressionSelected&gt; &lt;!--Package输出路径是否勾选，True表示勾选即输出，False表示不勾选即不输出--&gt; &lt;OutputPackageSelected&gt;True&lt;/OutputPackageSelected&gt; &lt;!--Full输出路径是否勾选，True表示勾选即输出，False表示不勾选即不输出--&gt; &lt;OutputFullSelected&gt;False&lt;/OutputFullSelected&gt; &lt;!--Packed输出路径是否勾选，True表示勾选即输出，False表示不勾选即不输出--&gt; &lt;OutputPackedSelected&gt;False&lt;/OutputPackedSelected&gt; &lt;!--Build Event Handler类型名称--&gt; &lt;BuildEventHandlerTypeName&gt;StarForce.Editor.StarForceBuildEventHandler&lt;/BuildEventHandlerTypeName&gt; &lt;!--AB输出路径--&gt; &lt;OutputDirectory&gt;&lt;/OutputDirectory&gt; &lt;/Settings&gt; &lt;/AssetBundleBuilder&gt;&lt;/UnityGameFramework&gt; AssetBundle Editor菜单路径：Game Framework/AssetBundle Tools/AssetBundle Editor界面分为三个部分:AssetBundleList、AssetBundleContent、Asset ListAssetBundleList是通过读取解析AssetBundleCollection.xml，Asset List是通过AssetBundleEditor.xml里的配置筛选资源而来，而AssetBundleContent部分在是选中AssetBundleList里的一个AB后显示被选中的AB里包含的资源。这三个部分下面都有对应的工具菜单。 官方文档：使用 AssetBundle 编辑工具 AssetBundleList（1）以AssetBundles为根结点（2）这些AB的结点层级路径表示打包后的资源相对路径（3）AB的层级路径参考AssetBundle的Name属性，也就是AssetBundleCollection.xml配置中的AssetBundle的Name（4）AB结点的名称前缀[Packed]表示其Packed，参考AssetBundleEditor脚本中的DrawAssetBundleItem函数（5）AB结点的名称后面 “.{变体名}”，例如StarForce例子中的Dictionaries.en-us这个AB中的en-us表示其变体名（6）通过选中AB后，点击下方的Rename按钮，在第一个输入框中输入层级名称，即可更改其相对路径，第二个输入框是变体名。点击后面ok按钮或者按回车均可改名。（7）不支持多选、不支持拖拽修改相对路径。 AssetBundleContent（1）显示左侧选中的AB里所包含的资源清单（2）All：全部选中（3）None：全部不选中（4）AssetSorterType枚举下拉框 123456public enum AssetSorterType&#123; Path, Name, Guid,&#125; 除了修改排序外，还会修改这个界面显示的内容，Path对应资源路径，Name对应资源名，Guid自然是资源的Guid。（5）右边的 0 &gt;&gt; 按钮，数字表示勾选的资源数量，&gt;&gt; 表示将选中的资源移除这个AB，还给右侧的Asset List。（又没有借，哪来的还。。不过&gt;&gt;很形象嘛。。） Asset List资源树状视图，支持多选（1）资源如果包含在某个AB里，其后面会有AssetBundle Name（2）&lt;&lt;0 按钮：同理，数字表示选中的资源数量。功能在于将选中的资源 给左侧选中的A版中，如果此前资源已经在别的AB中，则会先移出。未选中资源 和 未选中AB 这两种情况均无法点击该按钮。（3）&lt;&lt;&lt; 0 按钮：同理，数字表示选中的资源数量。那么与上面按钮有什么区别呢？（不就多了一个 &lt; 吗，难道一个 &lt;&lt; 表示移到中间的Asset List，多了一个 &lt; 还能移到 AssetBundleList 中吗。。）这个按钮用于批量添加AB，将选中的一个或多个资源作为 AssetBundle 名来创建 AssetBundle，并将自身加入到对应的 AssetBundle 里。（4）Hie Assigne：隐藏已经存在于 AssetBundle 中的资源，只列出尚未指定 AssetBundle 的资源。（5）Clean：从所有的 AssetBundle 中清理无效的资源，并移除所有空的 AssetBundle。建议 Save 前总是点一下 Clean 按钮，因为构建 AssetBundle 的时候，Unity 不允许存在无效的资源或者空的 AssetBundle。空的AB在左侧中会显示成灰色，会导致打包失败。（6）Save：保存当前所有 AssetBundle 和资源的状态。注意保存 AssetBundle Analyzer待续。 AssetBundle Builder 界面分为以下几个部分： Environment Information：工程的基本信息（1）ProductName：PlayerSettings.productName（2）Company Name：PlayerSettings.companyName（3）Game Identifier： 1234567891011public string GameIdentifier&#123; get &#123;#if UNITY_5_6_OR_NEWER return PlayerSettings.applicationIdentifier;#else return PlayerSettings.bundleIdentifier;#endif &#125;&#125; （4）Applicable Game Version：Application.version以上这些数据在File-&gt;Build Settings-&gt;Player Settings中可以看到 Platforms：打包平台勾选，支持多选如果一个平台都不勾选，界面下方会出现红色警告：Platform undefined. AssetBundle Options：参考UnityEditor.BuildAssetBundleOptions枚举官方文档介绍：https://docs.unity3d.com/ScriptReference/BuildAssetBundleOptions.html，此处不再赘述AssetBundleBuilderController.cs脚本中的GetBuildAssetBundleOptions函数会将这里勾选的选项转换为BuildAssetBundleOptions 123456789101112131415161718192021222324252627282930313233private BuildAssetBundleOptions GetBuildAssetBundleOptions()&#123; BuildAssetBundleOptions buildOptions = BuildAssetBundleOptions.None; if (UncompressedAssetBundleSelected) &#123; buildOptions |= BuildAssetBundleOptions.UncompressedAssetBundle; &#125; if (DisableWriteTypeTreeSelected) &#123; buildOptions |= BuildAssetBundleOptions.DisableWriteTypeTree; &#125; if (DeterministicAssetBundleSelected) &#123; buildOptions |= BuildAssetBundleOptions.DeterministicAssetBundle; &#125; if (ForceRebuildAssetBundleSelected) &#123; buildOptions |= BuildAssetBundleOptions.ForceRebuildAssetBundle; &#125; if (IgnoreTypeTreeChangesSelected) &#123; buildOptions |= BuildAssetBundleOptions.IgnoreTypeTreeChanges; &#125; if (AppendHashToAssetBundleNameSelected) &#123; buildOptions |= BuildAssetBundleOptions.AppendHashToAssetBundleName; &#125; if (ChunkBasedCompressionSelected) &#123; buildOptions |= BuildAssetBundleOptions.ChunkBasedCompression; &#125; return buildOptions;&#125; 这个BuildAssetBundleOptions最终是传给了BuildPipeline.BuildAssetBundle函数。由于构建过程需要对生成的 AssetBundle 名称进行处理，故这里不允许使用 Append Hash To AssetBundle Name 选项。 Zip All AssetBundles : 压缩所有 AssetBundles（Zip All AssetBundles）用于指定构建 AssetBundle 后，是否进一步使用 Zip 压缩 AssetBundle 包。 Build部分: Build Event Handler：这里会显示一个实现了IBuildEventHandler接口的所有TypeName的下拉框，例如StarForce工程中StarForceBuildEventHandler类接口包含以下部分：（1）ContinueOnFailure：获取当某个平台生成失败时，是否继续生成下一个平台。（2）PreprocessAllPlatforms：所有平台生成开始前的预处理事件（3）PostprocessAllPlatforms：所有平台生成结束后的后处理事件（4）PreprocessPlatform：某个平台生成开始前的预处理事件（5）PostprocessPlatform：某个平台生成结束后的后处理事件大家可以根据自己的需求定义不同的Handler。例如：StarForce案例中：PreprocessAllPlatforms函数中清空了StreamingAssets文件夹。PostprocessPlatform函数中把outputPackagePath里的文件给拷贝到工程的StreamingAssets目录下。 Internal Resource Version:内部资源版本号（Internal Resource Version）建议每次自增 1 即可，Game Framework 判定资源包是否需要更新，是使用此编号作为判定依据的。 Resource Version:资源版本号（Resource Version）根据当前 App 版本号和内部资源版本号自动生成，并不会存储在AssetBundleBuilder.xml中。 Output Directory：输出目录（Output Directory）用于指定构建过程的结果输出目录，绝对路径，支持直接输入（记得回车）,右边Browse按钮可以选择路径。如果路径无效，下方会提示Output directory is invalid. Output Directory选中后，下方会出现Working Path、Output Package Path、Output Full Path、Output Packed Path、Build Report Path这五个子路径。 当这些配置都配好后，就会出现提示：Ready to build.点击Start Build AssetBundles按钮开始打包，点击Save按钮保存配置到AssetBundleBuilder.xml配置中。 打包成功： 打包完后，再来介绍这五个目录:（1）BuildReport：该目录包含了两个文件，BuildLog.txt和BuildReport.xml。BuildLog.txt用来记录打包日志，打包失败的时候可以通过查看该日志来判断是哪一步出现了问题。AssetBundleBuilderController脚本中通过m_BuildReport.LogInfo接口进行日志记录。而BuildReport.xml文件则用来记录本次打包设置、本次打包的AB信息、AB中包含的Asset信息等等。（2）Full:为可更新模式生成的完整文件包（3）Package：为单机模式生成的文件，若游戏是单机游戏，生成结束后将此目录中对应平台的文件拷贝至 StreamingAssets 后打包 App 即可。（4）Packed：为可更新模式生成的文件（5）Working：Unity生成AssetBundle时的工作目录 请注意：不知道从哪个版本开始，GameResourceVersion_x_x_x.xml文件不再生成。相关数据可以在BuildReport目录下的BuildLog.txt中查看到，如下： 1[15:51:32.383][INFO] Process version list for &#39;MacOS&#39; complete, version list path is &#39;&#x2F;Users&#x2F;teitomonari&#x2F;Documents&#x2F;WorkSpace&#x2F;UnityProjects&#x2F;Study&#x2F;StarForce&#x2F;StarForce&#x2F;AssetBundle&#x2F;Full&#x2F;0_1_0_1&#x2F;MacOS&#x2F;version.7fe1ca32.dat&#39;, length is &#39;11641&#39;, hash code is &#39;2145503794[0x7FE1CA32]&#39;, zip length is &#39;4100&#39;, zip hash code is &#39;111937434[0x06AC079A]&#39;. Build AssetBundle待续。 Documentation待续。 API Reference待续。 使用UnityGameFramework编辑器出现的常见问题记录1. AssetBundleEditor界面中的Asset列表是空的？待续。]]></content>
      <categories>
        <category>Unity</category>
        <category>GameFramework框架</category>
      </categories>
      <tags>
        <tag>GameFramework框架源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之二十九：资源弱引用文件选择器]]></title>
    <url>%2F2019%2F09%2F27%2Funity-bian-ji-qi-tuo-zhan-zhi-er-shi-jiu-zi-yuan-ruo-yin-yong-wen-jian-xuan-ze-qi%2F</url>
    <content type="text"><![CDATA[笔记目录@[toc] 写在开头AdvancedDropdown只在Unity 2019下才可用。。。 工具介绍文件选择器顾名思义是用来选中文件用的，那么与上图中Unity自带的点击右边的小圆点 弹出文件搜索框有什么区别呢？ 工具界面如下： 其中点击Select按钮，弹出文件搜索框（类比Add Component按钮点击后弹出的框）,根据资源类型筛选后形成的资源树状结构显示在下面的框中，点击其中一个结点进入子树，点击右侧的X按钮进行清空。（小声哔哔：看起来好像没啥用） gif动图： 资源弱引用首先说明一下个人理解的资源弱引用：不直接引用游戏资源，通过序列化存储一些用来从资源管理系统中加载资源的参数，来间接引用资源，这些参数可以称之为地址（不要强行沾边Addressable）。使用一个地址来加载资源，资源如何更改，地址都不要变，保证地址唯一性。无论是使用Resources文件夹进行资源加载管理、还是使用AssetBundle进行资源加载管理，都可以使用弱引用。 弱引用需要存储的数据： GuidEditor可使用Guid来加载资源、定位资源，保证资源的路径修改后依然可以定位到资源。 用来加载的数据取决于你的资源管理系统如何加载资源，如果使用Resources加载，可以存储Resources文件夹下的路径 WeakReference弱引用基类，其中存储了Guid 各种资源类型对应的弱引用类型 文件选择器该文件选择器参考的Editor源码中AddComponent部分 Unity-Technologies Add Component Editor源码地址 AdvancedDropdown官方介绍 AdvancedDropdown部分此文不过多介绍，可能会另外开篇。本例中只存储了guid，其余数据在文件被选择的时候也可以赋值。 源码地址Github仓库地址 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。 最近在用hexo 和 github page搭 个人博客，地址如下：http://www.jingfengji.tech/欢迎大家关注。 最近的一些博客 还是会更新在 CSDN这边，后续以自己个人的博客站点会主。【实在是没空去整那边，要学习的东西真是太多了。。。】]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>资源弱引用文件选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python工具之一：九宫格图片极致裁剪]]></title>
    <url>%2F2019%2F08%2F15%2Fpython-gong-ju-zhi-yi-jiu-gong-ge-tu-pian-ji-zhi-cai-jian%2F</url>
    <content type="text"><![CDATA[Python工具之一：九宫格图片极致裁剪工具用途在读到文章(https://blog.uwa4d.com/archives/PSD4UGUI.html)时，文章中提到“e.通过设定参数即可自动生成九宫图片，优化九宫图片面积”，引发的思考：如何优化九宫图片面积？九宫图片作为拉伸图片使用，拉伸区域越小越能缩小图片面积，达到优化的目的。进一步找到文章（https://gameinstitute.qq.com/community/detail/103423) 文章中提到下图 将连续相同的行（列）裁剪掉，只保留一行（列）即可，依次达到九宫图片面积缩小的目的。 （ps：讲道理，图片处理软件里应该能精准控制裁剪的，为啥要程序写工具来做这件事？美术表示我不会…） 本文中并没有写的上文中那么详细，我的最终目的是给Unity中使用的九宫图片做裁剪，因此文章中有部分内容跟Unity沾边，不过不影响工具的使用，工具使用Python开发。 如下图：Unity中两纯色像素之间有颜色过渡，因此工具没有将图片的连续相同行（列）裁剪到只保留一行（列），而是三行（列）。 开发思考（1）如何加载、保存、读写一个image，本工具使用OpenCV2 （2）如何判断图片的两行（列）是否完全相同 （3）如何计算出图片的最佳九宫区域 （4）如何裁剪九宫区域 裁剪结果看起来很像变成了一个圆形，其实四条边上有三行（列）像素是九宫区域 代码介绍123456789101112131415# 比较两行是否相等# 相等返回true，否则返回falsedef equal_row_pixel(img,row1,row2): height &#x3D; img.shape[0] #将tuple中的元素取出，赋值给height，width，channels width &#x3D; img.shape[1] channels &#x3D; img.shape[2] if(row1 &lt; 0 or row1 &gt;&#x3D; height): return False if(row2 &lt; 0 or row2 &gt;&#x3D; height): return False for col in range(width): for channel in range(channels): if(img[row1][col][channel] !&#x3D; img[row2][col][channel]): return False return True 123456789101112131415# 比较两列是否相等# 相等返回true，否则返回falsedef equal_col_pixel(img,col1,col2): height &#x3D; img.shape[0] #将tuple中的元素取出，赋值给height，width，channels width &#x3D; img.shape[1] channels &#x3D; img.shape[2] if(col1 &lt; 0 or col1 &gt;&#x3D; width): return False if(col2 &lt; 0 or col2 &gt;&#x3D; width): return False for row in range(height): for channel in range(channels): if(img[row][col1][channel] !&#x3D; img[row][col2][channel]): return False return True 12345678910111213141516171819202122232425262728# 横向是否可以处理九宫# img:图片# continuous_col_num:连续的列数，大于等于这个值判定为横向可以九宫处理def horizontal_slice(img,continuous_col_num): cur_begin_col_index &#x3D; 0 cur_end_col_index &#x3D; 0 slice_begin_col_index &#x3D; 0 slice_end_col_index &#x3D; 0 height &#x3D; img.shape[0] width &#x3D; img.shape[1] channels &#x3D; img.shape[2] for col in range(width): if(col &lt; width - 1): if(equal_col_pixel(img,col,col+1) &#x3D;&#x3D; False): # begin与end指向不是同一列时，判断连续列数是否满足九宫条件 if((cur_begin_col_index !&#x3D; cur_end_col_index) and (cur_end_col_index - cur_begin_col_index &gt;&#x3D; continuous_col_num) and (cur_end_col_index - cur_begin_col_index &gt; slice_end_col_index - slice_begin_col_index)): # 已经达到了连续列数，满足九宫条件 slice_begin_col_index &#x3D; cur_begin_col_index slice_end_col_index &#x3D; cur_end_col_index cur_begin_col_index &#x3D; col + 1 cur_end_col_index &#x3D; col + 1 else: # 相等，end后移一位 cur_end_col_index &#x3D; col + 1 if(slice_end_col_index - slice_begin_col_index &gt;&#x3D; continuous_col_num): return True,slice_begin_col_index,slice_end_col_index else: return False,0,0 1234567891011121314151617181920212223# 纵向是否可以处理九宫def vertical_slice(img,continuous_row_num): cur_begin_row_index &#x3D; 0 cur_end_row_index &#x3D; 0 slice_begin_row_index &#x3D; 0 slice_end_row_index &#x3D; 0 height &#x3D; img.shape[0] width &#x3D; img.shape[1] channels &#x3D; img.shape[2] for row in range(height): if(row &lt; height - 1): if(equal_row_pixel(img,row,row+1) &#x3D;&#x3D; False): if((cur_begin_row_index !&#x3D; cur_end_row_index) and (cur_end_row_index - cur_begin_row_index &gt;&#x3D; continuous_row_num) and (cur_end_row_index - cur_begin_row_index &gt; slice_end_row_index - slice_begin_row_index)): slice_begin_row_index &#x3D; cur_begin_row_index slice_end_row_index &#x3D; cur_end_row_index cur_begin_row_index &#x3D; row + 1 cur_end_row_index &#x3D; row + 1 else: cur_end_row_index &#x3D; row + 1 if(slice_end_row_index - slice_begin_row_index &gt;&#x3D; continuous_row_num): return True,slice_begin_row_index,slice_end_row_index else: return False,0,0 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*- import cv2from PIL import Imageimport numpy as npimport osimport tkFileDialogimport Tkinterimport tkMessageBox# 比较两行是否相等# 相等返回true，否则返回falsedef equal_row_pixel(img,row1,row2): height &#x3D; img.shape[0] #将tuple中的元素取出，赋值给height，width，channels width &#x3D; img.shape[1] channels &#x3D; img.shape[2] if(row1 &lt; 0 or row1 &gt;&#x3D; height): return False if(row2 &lt; 0 or row2 &gt;&#x3D; height): return False for col in range(width): for channel in range(channels): if(img[row1][col][channel] !&#x3D; img[row2][col][channel]): return False return True# 比较两列是否相等# 相等返回true，否则返回falsedef equal_col_pixel(img,col1,col2): height &#x3D; img.shape[0] #将tuple中的元素取出，赋值给height，width，channels width &#x3D; img.shape[1] channels &#x3D; img.shape[2] if(col1 &lt; 0 or col1 &gt;&#x3D; width): return False if(col2 &lt; 0 or col2 &gt;&#x3D; width): return False for row in range(height): for channel in range(channels): if(img[row][col1][channel] !&#x3D; img[row][col2][channel]): return False return True# 横向是否可以处理九宫# img:图片# continuous_col_num:连续的列数，大于等于这个值判定为横向可以九宫处理def horizontal_slice(img,continuous_col_num): cur_begin_col_index &#x3D; 0 cur_end_col_index &#x3D; 0 slice_begin_col_index &#x3D; 0 slice_end_col_index &#x3D; 0 height &#x3D; img.shape[0] width &#x3D; img.shape[1] channels &#x3D; img.shape[2] for col in range(width): if(col &lt; width - 1): if(equal_col_pixel(img,col,col+1) &#x3D;&#x3D; False): # begin与end指向不是同一列时，判断连续列数是否满足九宫条件 if((cur_begin_col_index !&#x3D; cur_end_col_index) and (cur_end_col_index - cur_begin_col_index &gt;&#x3D; continuous_col_num) and (cur_end_col_index - cur_begin_col_index &gt; slice_end_col_index - slice_begin_col_index)): # 已经达到了连续列数，满足九宫条件 slice_begin_col_index &#x3D; cur_begin_col_index slice_end_col_index &#x3D; cur_end_col_index cur_begin_col_index &#x3D; col + 1 cur_end_col_index &#x3D; col + 1 else: # 相等，end后移一位 cur_end_col_index &#x3D; col + 1 if(slice_end_col_index - slice_begin_col_index &gt;&#x3D; continuous_col_num): return True,slice_begin_col_index,slice_end_col_index else: return False,0,0# 纵向是否可以处理九宫def vertical_slice(img,continuous_row_num): cur_begin_row_index &#x3D; 0 cur_end_row_index &#x3D; 0 slice_begin_row_index &#x3D; 0 slice_end_row_index &#x3D; 0 height &#x3D; img.shape[0] width &#x3D; img.shape[1] channels &#x3D; img.shape[2] for row in range(height): if(row &lt; height - 1): if(equal_row_pixel(img,row,row+1) &#x3D;&#x3D; False): if((cur_begin_row_index !&#x3D; cur_end_row_index) and (cur_end_row_index - cur_begin_row_index &gt;&#x3D; continuous_row_num) and (cur_end_row_index - cur_begin_row_index &gt; slice_end_row_index - slice_begin_row_index)): slice_begin_row_index &#x3D; cur_begin_row_index slice_end_row_index &#x3D; cur_end_row_index cur_begin_row_index &#x3D; row + 1 cur_end_row_index &#x3D; row + 1 else: cur_end_row_index &#x3D; row + 1 if(slice_end_row_index - slice_begin_row_index &gt;&#x3D; continuous_row_num): return True,slice_begin_row_index,slice_end_row_index else: return False,0,0# 标记Sprite的九宫区域def tag_image_slice_area(img,slice_row_begin,slice_row_end,slice_col_begin,slice_col_end,color): height &#x3D; img.shape[0] width &#x3D; img.shape[1] channels &#x3D; img.shape[2] for row in range(height): #遍历每一行 for col in range(width): #遍历每一列 if((row &gt;&#x3D; slice_row_begin and row &lt;&#x3D; slice_row_end and slice_row_begin !&#x3D; slice_row_end) or (col &gt;&#x3D; slice_col_begin and col &lt;&#x3D; slice_col_end and slice_col_begin !&#x3D; slice_col_end)): alter_image_pixel_color(img,row,col,color) return img# 修改img指定像素的颜色# img:修改的img# row:行索引# col:列索引# color:颜色rgb数组def alter_image_pixel_color(img,row,col,color): img.itemset((row, col, 0), color[0]) img.itemset((row, col, 1), color[1]) img.itemset((row, col, 2), color[2])# 九宫区域裁剪def tailor_image_slice_area(img,slice_row_begin,slice_row_end,slice_col_begin,slice_col_end): height &#x3D; img.shape[0] width &#x3D; img.shape[1] new_width &#x3D; width - (slice_col_end - slice_col_begin) new_height &#x3D; height - (slice_row_end - slice_row_begin) target &#x3D; np.zeros(shape&#x3D;(new_height,new_width,img.shape[2]), dtype&#x3D;np.uint8) # img[0:4,0:3] 第0行-第4行，第0列到第3列的交叉区域 # 左上 roiImg &#x3D; img[0:slice_row_begin,0:slice_col_begin] target[0:slice_row_begin,0:slice_col_begin] &#x3D; roiImg # 右上 roiImg &#x3D; img[0:slice_row_begin,slice_col_end:width] target[0:slice_row_begin,slice_col_begin:new_width] &#x3D; roiImg # 左下 roiImg &#x3D; img[slice_row_end:height,0:slice_col_begin] target[slice_row_begin:new_height,0:slice_col_begin] &#x3D; roiImg # 右下 roiImg &#x3D; img[slice_row_end:height,slice_col_end:width] target[slice_row_begin:new_height,slice_col_begin:new_width] &#x3D; roiImg return targetdef load_sprite(): continuous_row_num_input_str &#x3D; continuous_row_num_input.get() #获取文本框内容 continuous_col_num_input_str &#x3D; continuous_col_num_input.get() continuous_row_num &#x3D; 0 continuous_col_num &#x3D; 0 try: if continuous_row_num_input_str !&#x3D; &quot;&quot;: continuous_row_num &#x3D; float(continuous_row_num_input_str) if continuous_col_num_input_str !&#x3D; &quot;&quot;: continuous_col_num &#x3D; float(continuous_col_num_input_str) except ValueError: tkMessageBox.showinfo( &quot;Error&quot;, &quot;无效的线宽输入&quot;) return if continuous_row_num &lt;&#x3D; 0 or continuous_col_num &lt;&#x3D; 0: tkMessageBox.showinfo( &quot;Error&quot;, &quot;无效的线宽输入&quot;) return fname &#x3D; tkFileDialog.askopenfilename(title&#x3D;u&quot;选择文件&quot;) img1 &#x3D; cv2.imread(fname,cv2.IMREAD_UNCHANGED) a1,b1,c1 &#x3D; horizontal_slice(img1,continuous_col_num) a2,b2,c2 &#x3D; vertical_slice(img1,continuous_row_num) # 九宫区域保留在3像素的宽高 b1 &#x3D; b1 + 1 c1 &#x3D; c1 - 1 b2 &#x3D; b2 + 1 c2 &#x3D; c2 - 1 if toggle_tailor_hor.get() &#x3D;&#x3D; 0: b1 &#x3D; 0 c1 &#x3D; 0 if toggle_tailor_ver.get() &#x3D;&#x3D; 0: b2 &#x3D; 0 c2 &#x3D; 0 new_sprite &#x3D; tailor_image_slice_area(img1,b2,c2,b1,c1) cv2.imwrite(fname, new_sprite) print(fname)root &#x3D; Tkinter.Tk()root.geometry(&#39;400x300&#39;)root.title(&quot;Sprite九宫区域极致裁剪修改器&quot;)frame &#x3D; Tkinter.Frame(root)frame.pack()toggle_tailor_hor &#x3D; Tkinter.IntVar()toggle_tailor_ver &#x3D; Tkinter.IntVar()Tkinter.Checkbutton(root, text &#x3D; &quot;是否横向九宫处理&quot;, variable &#x3D; toggle_tailor_hor,onvalue &#x3D; 1, offvalue &#x3D; 0).pack()Tkinter.Checkbutton(root, text &#x3D; &quot;是否纵向九宫迷宫&quot;, variable &#x3D; toggle_tailor_ver,onvalue &#x3D; 1, offvalue &#x3D; 0).pack()Tkinter.Label(frame, text&#x3D;&quot;横向最小连续列数&quot;).pack()continuous_row_num_input &#x3D; Tkinter.Entry(frame)continuous_row_num_input.pack()Tkinter.Label(frame, text&#x3D;&quot;纵向最小连续行数&quot;).pack()continuous_col_num_input &#x3D; Tkinter.Entry(frame)continuous_col_num_input.pack()load_sprite_button &#x3D; Tkinter.Button(root, text&#x3D;&quot;加载Sprite文件并修改&quot;,command&#x3D;load_sprite)load_sprite_button.pack()root.mainloop() 工具界面 点击按钮”加载Sprite文件并修改“后，打开文件框选中要处理的图片后进行处理，覆盖原图片，可以根据自己的需要进行修改。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。 最近在用hexo 和 github page搭 个人博客，地址如下：http://www.jingfengji.tech/欢迎大家关注。 最近的一些博客 还是会更新在 CSDN这边，后续以自己个人的博客站点会主。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>九宫格图片极致裁剪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之二十八：Sprite Border自动设置工具]]></title>
    <url>%2F2019%2F08%2F13%2Funity-bian-ji-qi-tuo-zhan-zhi-er-shi-ba-sprite-border-zi-dong-she-zhi-gong-ju%2F</url>
    <content type="text"><![CDATA[Unity编辑器拓展之二十八：Sprite Border自动设置工具1.0 功能介绍自动计算出九宫格Sprite 的border数据并直接赋值保存的工具。【纯属偷懒，可能各位觉得没啥用吧，哈哈】 当需要为一个九宫格Sprite 设置Border数据时，需要打开Sprite Editor，然后输入Border数据。 工具会直接计算横向、纵向连续完全相同的列数、行数（当然连续区域取最大的），当计算出的九宫区域满足条件时（我设定的条件是连续列数或者行数有个最小值设定），就任务该图可以处理为九宫格Sprite。 以上九宫格Sprite，又称为 点九图【废话】。 2.0 源码脚本放置在Editor文件夹下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206using System.IO;using UnityEditor;using UnityEngine;public class SpriteImporterTool : UnityEditor.Editor&#123; public static int continuousColNum &#x3D; 10; &#x2F;&#x2F;continuousColNum:连续的列数，大于等于这个值判定为横向可以九宫处理 public static int continuousRowNum &#x3D; 10; &#x2F;&#x2F;continuousRowNum:连续的行数，大于等于这个值判定为纵向可以九宫处理 &#x2F;&#x2F;自动计算Sprite Border数据 [MenuItem(&quot;Assets&#x2F;SpriteBorder&#x2F;AutoSetSpriteBorder&quot;, false, 500)] public static void AutoSetSpriteBorder() &#123; foreach (var spriteAsset in Selection.objects) &#123; AutoSetSpriteBorder(AssetDatabase.GetAssetPath(spriteAsset)); &#125; &#125; &#x2F;&#x2F;设置Sprite Border为Zero [MenuItem(&quot;Assets&#x2F;SpriteBorder&#x2F;Reset Zero&quot;, false)] public static void AutoSetSpriteBorderZero() &#123; foreach (var spriteAsset in Selection.objects) &#123; SetSpriteBorder(AssetDatabase.GetAssetPath(spriteAsset), Vector4.zero); &#125; &#125; private static void AutoSetSpriteBorder(string spriteAssetPath) &#123; TextureImporter textureImporter &#x3D; AssetImporter.GetAtPath(spriteAssetPath) as TextureImporter; if (textureImporter !&#x3D; null &amp;&amp; textureImporter.textureType &#x3D;&#x3D; TextureImporterType.Sprite) &#123; Sprite sprite &#x3D; AssetDatabase.LoadAssetAtPath&lt;Sprite&gt;(spriteAssetPath); Vector4 border &#x3D; Vector4.zero; GetBorderSliceInfo(sprite.texture, continuousColNum, continuousRowNum, ref border); if (border !&#x3D; Vector4.zero) &#123; textureImporter.spriteBorder &#x3D; border; EditorUtility.SetDirty(sprite); AssetDatabase.SaveAssets(); AssetDatabase.Refresh(); &#125; &#125; &#125; private static void SetSpriteBorder(string spriteAssetPath, Vector4 border) &#123; TextureImporter textureImporter &#x3D; AssetImporter.GetAtPath(spriteAssetPath) as TextureImporter; if (textureImporter !&#x3D; null &amp;&amp; textureImporter.textureType &#x3D;&#x3D; TextureImporterType.Sprite) &#123; Sprite sprite &#x3D; AssetDatabase.LoadAssetAtPath&lt;Sprite&gt;(spriteAssetPath); textureImporter.spriteBorder &#x3D; border; EditorUtility.SetDirty(sprite); AssetDatabase.SaveAssets(); AssetDatabase.Refresh(); &#125; &#125; public static void GetBorderSliceInfo(Texture2D texture, int continuousColNum, int continuousRowNum, ref Vector4 border) &#123; int width &#x3D; texture.width; int height &#x3D; texture.height; &#x2F;&#x2F;咳咳，这里的命名规则请忽略，从另一个python工具拷贝过来 int cur_begin_col_index &#x3D; 0; int cur_end_col_index &#x3D; 0; int slice_begin_col_index &#x3D; 0; int slice_end_col_index &#x3D; 0; Texture2D readTexture2D &#x3D; GetReadTexture2D(texture); for (int col &#x3D; 0; col &lt; width - 1; col++) &#123; if (EqualColPixel(readTexture2D, col, col + 1) &#x3D;&#x3D; false) &#123; if ((cur_begin_col_index !&#x3D; cur_end_col_index) &amp;&amp; (cur_end_col_index - cur_begin_col_index &gt;&#x3D; continuousColNum) &amp;&amp; (cur_end_col_index - cur_begin_col_index &gt; slice_end_col_index - slice_begin_col_index)) &#123; slice_begin_col_index &#x3D; cur_begin_col_index; slice_end_col_index &#x3D; cur_end_col_index; &#125; cur_begin_col_index &#x3D; col + 1; cur_end_col_index &#x3D; col + 1; &#125; else &#123; cur_end_col_index &#x3D; col + 1; &#125; &#125; int cur_begin_row_index &#x3D; 0; int cur_end_row_index &#x3D; 0; int slice_begin_row_index &#x3D; 0; int slice_end_row_index &#x3D; 0; for (int row &#x3D; 0; row &lt; height - 1; row++) &#123; if (EqualRowPixel(readTexture2D, row, row + 1) &#x3D;&#x3D; false) &#123; if ((cur_begin_row_index !&#x3D; cur_end_row_index) &amp;&amp; (cur_end_row_index - cur_begin_row_index &gt;&#x3D; continuousRowNum) &amp;&amp; (cur_end_row_index - cur_begin_row_index &gt; slice_end_row_index - slice_begin_row_index)) &#123; slice_begin_row_index &#x3D; cur_begin_row_index; slice_end_row_index &#x3D; cur_end_row_index; &#125; cur_begin_row_index &#x3D; row + 1; cur_end_row_index &#x3D; row + 1; &#125; else &#123; cur_end_row_index &#x3D; row + 1; &#125; &#125; if (slice_end_col_index - slice_begin_col_index &lt; continuousColNum) &#123; slice_begin_col_index &#x3D; 0; slice_end_col_index &#x3D; width - 1; &#125; if (slice_end_row_index - slice_begin_row_index &lt; continuousRowNum) &#123; slice_begin_row_index &#x3D; 0; slice_end_row_index &#x3D; height - 1; &#125; &#x2F;&#x2F;LTRB &#x2F;&#x2F;row 是纵向的 T B &#x2F;&#x2F;col 是横向的 L R border &#x3D; new Vector4(slice_begin_col_index, slice_begin_row_index, width - slice_end_col_index - 1, height - slice_end_row_index - 1); &#125; public static string GetAssetFullPath(UnityEngine.Object asset) &#123; return System.Environment.CurrentDirectory + Path.DirectorySeparatorChar + AssetDatabase.GetAssetPath(asset); &#125; public static Texture2D GetReadTexture2D(Texture texture) &#123; string textureFilePath &#x3D; GetAssetFullPath(texture); FileStream fileStream &#x3D; new FileStream(textureFilePath, FileMode.Open, FileAccess.Read); fileStream.Seek(0, SeekOrigin.Begin); byte[] bytes &#x3D; new byte[fileStream.Length]; fileStream.Read(bytes, 0, (int) fileStream.Length); fileStream.Close(); fileStream.Dispose(); Texture2D new_texture &#x3D; new Texture2D(texture.width, texture.height); new_texture.LoadImage(bytes); return new_texture; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 比较两行像素是否完全相等 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;texture&quot;&gt;isReadable为true，可读的texture&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;row1&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;row2&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; public static bool EqualRowPixel(Texture2D texture, int row1, int row2) &#123; Color[] row1Colors &#x3D; texture.GetPixels(0, row1, texture.width, 1); Color[] row2Colors &#x3D; texture.GetPixels(0, row2, texture.width, 1); for (int i &#x3D; 0; i &lt; row1Colors.Length; i++) &#123; if (!row1Colors[i].Equals(row2Colors[i])) &#123; return false; &#125; &#125; return true; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 比较两列像素是否完全相等 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;texture&quot;&gt;isReadable为true，可读的texture&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;col1&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;col2&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; public static bool EqualColPixel(Texture2D texture, int col1, int col2) &#123; Color[] col1Colors &#x3D; texture.GetPixels(col1, 0, 1, texture.height); Color[] col2Colors &#x3D; texture.GetPixels(col2, 0, 1, texture.height); for (int i &#x3D; 0; i &lt; col1Colors.Length; i++) &#123; if (!col1Colors[i].Equals(col2Colors[i])) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>SpriteBorder自动设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之二十七：TextMeshPro的TMP-SpriteAsset图文混排图集快捷更新工具]]></title>
    <url>%2F2019%2F08%2F09%2Funity-bian-ji-qi-tuo-zhan-zhi-er-shi-qi-textmeshpro-de-tmp-spriteasset-tu-wen-hun-pai-tu-ji-kuai-jie-geng-xin-gong-ju%2F</url>
    <content type="text"><![CDATA[Unity编辑器拓展之二十七：TextMeshPro的TMP_SpriteAsset图文混排图集快捷更新工具1.TextMeshPro的SpriteAsset制作此文不再赘述，参考此文：https://blog.csdn.net/qq_37057633/article/details/81120583 2.工具使用场景当图文混排图集需要加一个新图时，需要重新按照上文的流程重新打一遍Json(Array)格式和一遍Unity-Texture2D Sprite格式的，打完之后，图集里的图文位置就会发生变化，TMP_SpriteAsset里存储的spriteGlyphTable和spriteCharacterTable并不会自动更新（包括旧的sprite相关数据和新增的sprite数据），而且旧的图文混排图集里的Sprite ID也应该保持不变，如果我们手动修改了Sprite的GlyphMetrics数据，这个数据也会被重打的覆盖掉，使得之前的数据丢失。那么，开发一款快捷更新图文混排的工具就十分有必要。 3.工具介绍3.1 工具界面 3.2 工具功能1.缓存数据 主要是缓存旧的图集数据，spriteGlyphTable和spriteCharacterTable 2.一键打Json格式图集 使用命令行打图集，此文不再赘述，参考：https://blog.csdn.net/u014065445/article/details/54289787 使用命令行打json格式文件 3.一键打Unity格式图集 使用命令行打Unity格式图集 1234567891011121314151617181920212223242526272829&#x2F;&#x2F;&#x2F; &lt;summary&gt;&#x2F;&#x2F;&#x2F; 打Unity格式图集&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;private void UnitySpriteTexturePacker()&#123; curTime &#x3D; System.DateTime.Now; &#x2F;&#x2F;获取打Unity格式的TexturePacker命令 string cmd &#x3D; TexturePackerCommond.GetPackCommond(arangeSpritesFolderPath,arrangeIconAtlasPngPath,arrangeIconAtlasTpsheetFilePath); &#x2F;&#x2F;使用ShellHelper生成一个ShellRequest对象 ShellHelper.ShellRequest request &#x3D; ShellHelper.ProcessCommand(cmd,null); EditorUtility.DisplayProgressBar(&quot;批量处理中...&quot;,&quot;Shell脚本生成Json图集信息...&quot;, 0); &#x2F;&#x2F;注册命令执行完回调 request.onDone +&#x3D; ()&#x3D;&gt; &#123; &#123; &#x2F;&#x2F;打包结束 EditorUtility.DisplayProgressBar(&quot;批量处理中...&quot;,&quot;Shell脚本执行完毕...开始打图集...&quot;, 0); AssetDatabase.SaveAssets(); AssetDatabase.Refresh(); CreateUIAtlas(); &#125; &#125;; &#x2F;&#x2F;注册命令执行错误的回调 request.onError +&#x3D; ()&#x3D;&gt; &#123; Debug.LogError(&quot;Texture Packer Error!!! Please Check Your Config&quot;); EditorUtility.ClearProgressBar(); &#125;;&#125; 4.数据更新 解析Tpsheet格式文件，从中拿到所有Sprite的GlyphRect数据，【注意】Tpsheet文件中Sprite的GlyphRect数据是以SpriteName区分的，因此TMP_SpriteAsset里的spriteCharacterTable里的name一定要正确，不然数据会错位。 4.使用说明1.TexturePacker_PATH更改为自己电脑的TexturePacker路径 2.工具开发环境是mac端，windows端下自行类比修改 3.需要导入TexturePackerImporter工具配合TexturePacker打出来的图集使用 4.代码中的路径自行修改 5.工具仓库地址https://github.com/JingFengJi/UpdateSpriteAssetTool.git 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。 最近在用hexo 和 github page搭 个人博客，地址如下：http://www.jingfengji.tech/欢迎大家关注。 最近的一些博客 还是会更新在 CSDN这边，后续以自己个人的博客站点会主。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>图文混排</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之二十六：基于UGUI的Sprite引用查询]]></title>
    <url>%2F2019%2F03%2F19%2Funity-bian-ji-qi-tuo-zhan-zhi-er-shi-liu-ji-yu-ugui-de-sprite-yin-yong-cha-xun%2F</url>
    <content type="text"><![CDATA[基于UGUI的Sprite引用查询使用TexturePacker打的图集，sprite引用查询工具示意图如下。菜单栏：1、选择图集，输入sprite name，一键搜索按钮，导出搜索数据成CSV格式，一键断开所有引用2、界面下方是搜索结果的Tree视图。 下面是操作示意图。 适用场景图片从一个图集更改到别的图集，如果是用Unity的打图集方式（PackingTag），这种场景就方便多了，修改PackingTag即可。使用TexturePacker打的图集，就没办法这样了。 Code地址https://github.com/JingFengJi/SpriteReferenceCheck 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。 最近在用hexo 和 github page搭 个人博客，地址如下：http://www.jingfengji.tech/欢迎大家关注。 最近的一些博客 还是会更新在 CSDN这边，后续以自己个人的博客站点会主。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>UGUI Sprite引用查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之二十五：图集SpriteMetaData数据拷贝]]></title>
    <url>%2F2019%2F03%2F16%2Funity-bian-ji-qi-tuo-zhan-zhi-er-shi-wu-tu-ji-spritemetadata-shu-ju-kao-bei%2F</url>
    <content type="text"><![CDATA[图集SpriteMetaData数据拷贝关于SpriteMetaData类： 用于生成精灵的编辑器数据。官方文档介绍：https://docs.unity3d.com/2017.2/Documentation/ScriptReference/SpriteMetaData.html 工具界面 工具使用场景适用于游戏中存在多套皮肤图集 使用方法拖入数据源图集的texture、克隆图集的texture，然后点击Copy，就会将clone texture 的Sprite data 拷贝到clone texture 中，对应关系是按照sprite name来对比的。 具体代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192using System.Collections.Generic;using UnityEditor;using UnityEngine;namespace Editor.CopyAtlasDataTool&#123; public class CopyAtlasDataTool : EditorWindow &#123; private static CopyAtlasDataTool window &#x3D; null; [MenuItem(&quot;Tools&#x2F;CopyAtlasDataTool&quot;)] public static CopyAtlasDataTool ShowGameDataEditorWindow() &#123; if (window &#x3D;&#x3D; null) window &#x3D; EditorWindow.GetWindow(typeof(CopyAtlasDataTool)) as CopyAtlasDataTool; window.titleContent &#x3D; new GUIContent(&quot;CopyAtlasDataTool&quot;); window.Show(); return window; &#125; private UnityEngine.Object _originObject; private UnityEngine.Object _cloneObject; private void OnGUI() &#123; _originObject &#x3D; EditorGUILayout.ObjectField(&quot;数据源图集&quot;, _originObject,typeof(Texture)); _cloneObject &#x3D; EditorGUILayout.ObjectField(&quot;克隆图集&quot;, _cloneObject, typeof(Texture)); if (GUILayout.Button(&quot;Copy&quot;)) &#123; if (_originObject !&#x3D; null &amp;&amp; _cloneObject !&#x3D; null) &#123; CopyData(_originObject, _cloneObject); &#125; &#125; &#125; public void CopyData(Object origin, Object clone) &#123; string originAssetPath &#x3D; AssetDatabase.GetAssetPath(origin); string cloneAssetPath &#x3D; AssetDatabase.GetAssetPath(clone); TextureImporter originTi &#x3D; AssetImporter.GetAtPath(originAssetPath) as TextureImporter; TextureImporter cloneTi &#x3D; AssetImporter.GetAtPath(cloneAssetPath) as TextureImporter; if (originTi !&#x3D; null &amp;&amp; cloneTi !&#x3D; null) &#123; &#x2F;&#x2F;打开读写，才能写入数据 cloneTi.isReadable &#x3D; true; List &lt; SpriteMetaData &gt; newData &#x3D; new List &lt; SpriteMetaData &gt; (); List&lt;string&gt; hasAddData &#x3D; new List&lt;string&gt;(); for (int i &#x3D; 0; i &lt; originTi.spritesheet.Length; i++) &#123; for (int j &#x3D; 0; j &lt; cloneTi.spritesheet.Length; j++) &#123; SpriteMetaData oSm &#x3D; originTi.spritesheet[i]; SpriteMetaData cSm &#x3D; cloneTi.spritesheet[j]; &#x2F;&#x2F;根绝sprite name进行匹配的 if (oSm.name &#x3D;&#x3D; cSm.name) &#123; cSm.border &#x3D; oSm.border; cSm.pivot &#x3D; oSm.pivot; cSm.alignment &#x3D; oSm.alignment; newData.Add(cSm); hasAddData.Add(cSm.name); &#125; &#125; &#125; for (int j &#x3D; 0; j &lt; cloneTi.spritesheet.Length; j++) &#123; SpriteMetaData cSm &#x3D; cloneTi.spritesheet[j]; if (!hasAddData.Contains(cSm.name)) &#123; newData.Add(cSm); &#125; &#125; cloneTi.spritesheet &#x3D; newData.ToArray(); AssetDatabase.ImportAsset(cloneAssetPath, ImportAssetOptions.ForceUpdate); cloneTi &#x3D; AssetImporter.GetAtPath(cloneAssetPath) as TextureImporter; if(cloneTi !&#x3D; null) cloneTi.isReadable &#x3D; false; AssetDatabase.ImportAsset(cloneAssetPath, ImportAssetOptions.ForceUpdate); &#125; &#125; &#125;&#125; 注意点（1）克隆图集的TextureImporter的isReadable要在复制前打开，不然不能写入数据（2）SpriteMetaData是结构体，要注意结构体和类的区别（3）copy完后，注意检查两个图集的读写是否正确关闭了 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。 最近在用hexo 和 github page搭 个人博客，地址如下：http://www.jingfengji.tech/欢迎大家关注。 最近的一些博客 还是会更新在 CSDN这边，后续以自己个人的博客站点会主。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>SpriteMetaData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之二十四：基于Unity Node Editor、ScriptableObject的配置化新手引导系统]]></title>
    <url>%2F2019%2F02%2F01%2Funity-bian-ji-qi-tuo-zhan-zhi-er-shi-si-ji-yu-unity-node-editor-scriptableobject-de-pei-zhi-hua-xin-shou-yin-dao-xi-tong%2F</url>
    <content type="text"><![CDATA[本文主要介绍根据一款Node Editor库开发的新手引导系统git地址如下： https://github.com/luis-l/UnityNodeEditorBase 一、旧版新手引导做法 GuideCheckManager负责check各种类型的引导，判断是否达到触发条件，如果达到条件，当前无引导，则直接进行引导，否则存入缓存队列中。 GuideCheckManager注册跟引导有关的消息通知，等收到通知，做一些check工作。 一个大步引导包含多个单线的单步引导，每个单步引导又可有check条件，如果中间某一单步引导未check通过，则打断引导。 缺点： （1）配置采用CSV，可读性极差 使用CSV作为配置，为了将触发条件也配置化，就必须做一些数据解析的工作，如下图所示： 然后在程序中定义各种类型trigger的数据解析函数。从CSV中无法很直观的知道这一单步引导具体是引导什么。 填充数据也较为繁琐。 二、基于结点编辑的配置化新手引导系统 （1）基于ScriptableObject、结点编辑的配置 工具截图如下：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190201142445605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70) GuideNodeGraph：一个结点树称为一个大步引导 GuideNode：一个结点称为一个单步引导 一个GuideNodeGraph就是一个ScriptableObject文件 一个GuideNodeGraph包含多个Node，连接NextStepGuide-&gt; LastStepGuide，形成结点树。 每个GuideNode，包含一个Input（LastStepGuide，目前无实际作用，只是为了连接结点树，OutPut必与Input连接)，三个Output（NextStepGuide、Trigger、Condition） NextStepGuide：用来存储下一个单步引导结点，如果无下一单步引导结点，则当前引导结点完成时，引导结束。 Trigger：该单步引导结点触发条件，如果有多个Trigger，则只要有一个Trigger Success，则该引导则触发。 Condition：引导条件结点。单步引导结点可包含多个Condition引导条件，只有当多个Condition均成立时，才会引导。 Trigger和Condition均为Node 的子类。 库中ActionTriggerSystem类的setupNodeCreateMenu函数，实现了在NodeEditor中的右键菜单，自行修改可以实现排序，某一类node在前，某一类在后 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190201143046251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70) 根据Guide View界面类型的不同，可以定义多种Guide Node保存数据，一般有对话模式的，以及点击UI模式的，本文主要讲如何使用NodeEditor、ScriptableObject进行配置化，如果项目中不是使用ScriptableObject进行配置存储的话，该方案就不适用了。 可以NodeEditor的优点：配置引导可读性高，并且不存在配置数据解析逻辑，更改引导内顺序也很方便快捷。 最后感谢作者提供的Node Editor库git地址如下： https://github.com/luis-l/UnityNodeEditorBase 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>新手引导</tag>
        <tag>Node Editor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader编程之一：多颜色条纹背景]]></title>
    <url>%2F2018%2F12%2F22%2Funity-shader-bian-cheng-zhi-yi-duo-yan-se-tiao-wen-bei-jing%2F</url>
    <content type="text"><![CDATA[两种颜色的条纹状背景Shader &quot;Custom/Flag&quot; { Properties { [PerRendererData]_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {} _1stColor(&quot;1stColo&quot;,Color) = (0,0,0,1) _2ndColor(&quot;2ndColor&quot;,Color) = (1,1,1,1) _tileNum(&quot;tile num&quot;, Range (2, 20)) = 10 } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag // make fog work #pragma multi_compile_fog #include &quot;UnityCG.cginc&quot; struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; sampler2D _MainTex; fixed4 _1stColor; fixed4 _2ndColor; int _tileNum; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = v.uv; return o; } fixed4 frag (v2f i) : SV_Target { //i.uv * _tileNum 将uv放大 //frac函数，取其小数部分 float2 newuv = frac(i.uv*_tileNum); //step函数小于0.5返回0，否则返回1，再lerp一下，也就是uv.x小于0.5，返回_1stColor，否则返回_2ndColor fixed4 color = lerp(_1stColor,_2ndColor,step(0.5,newuv.x)); return color; } ENDCG } } }效果图： ![在这里插入图片描述](https://img-blog.csdnimg.cn/20181222145228919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70)]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>多颜色条纹背景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之二十三：基于ObjectField的FileField]]></title>
    <url>%2F2018%2F12%2F22%2Funity-bian-ji-qi-tuo-zhan-zhi-er-shi-san-ji-yu-objectfield-de-filefield%2F</url>
    <content type="text"><![CDATA[使用场景最近在做资源管理模块时，关于资源引用这方面的问题，并不想直接引用某一个asset，比如Prefab、或者sprite、material等资源，当然可以由资源管理模块统一管理，然后对业务层提供获取的接口。由业务层传入文件名、或者AssetBundleName、path之类的数据，资源管理模块内加载出来然后返回。结合ObjectFiled这个编辑器类来介绍，我们拖入某一个asset，然后序列化存储其guid和assetpath，表面上看起来是引用了该asset，实际上只是存住了guid和path（用于load，结合资源管理模块而定），guid用于绝对指向asset资源，就算路径更改，也不怕引用丢失。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20181222133749902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70) ![在这里插入图片描述](https://img-blog.csdnimg.cn/20181222133618421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70) ObjectField介绍https://docs.unity3d.com/2017.2/Documentation/ScriptReference/EditorGUI.ObjectField.html FileField实现private string[] FileField(Rect position, string label, string guid,Type type) { string[] guidPath = new string[2];//存储guid和path，这里的path是assetPath，实际存储起来需要做一步处理，处理成资源管理模块能load的path或者别的数据 string path = AssetDatabase.GUIDToAssetPath(guid); UnityEngine.Object file = AssetDatabase.LoadAssetAtPath(path,type); EditorGUI.BeginChangeCheck(); { //编辑器上显示的是ObjectField绘制出来的 file = EditorGUI.ObjectField(position, label, file, type, false); } if (EditorGUI.EndChangeCheck()) { path = AssetDatabase.GetAssetPath(file); guid = AssetDatabase.AssetPathToGUID(path); } guidPath[0] = guid; guidPath[1] = path; return guidPath; }不算完整的代码： using UnityEditor; using UnityEngine; using System; using System.IO; using IdleGames.Core.AssetManagement; [CustomPropertyDrawer(typeof(WeakReferenceAttribute), true)] public class WeakReferenceBaseDrawer : PropertyDrawer { public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) { WeakReferenceAttribute attribute = (WeakReferenceAttribute)base.attribute; Type referenceType = typeof(GameObject); if (attribute != null) { referenceType = attribute.AssetType; } SerializedProperty guidProperty = property.FindPropertyRelative(&quot;_guid&quot;); SerializedProperty pathProperty = property.FindPropertyRelative(&quot;_path&quot;); Rect guidRect = position; string[] guidPath = FileField(guidRect, property.displayName, guidProperty.stringValue,referenceType); guidProperty.stringValue = guidPath[0]; //这里演示的是把path存成了Resources文件夹下的path if (string.IsNullOrEmpty(guidPath[1]) == false &amp;&amp; guidPath[1].Contains(&quot;Resources/&quot;)) { int index = guidPath[1].LastIndexOf(&quot;Resources/&quot;) + &quot;Resources/&quot;.Length; string path = guidPath[1].Substring(index); path = path.Remove(path.LastIndexOf(&quot;.&quot;)); pathProperty.stringValue = path; } property.serializedObject.ApplyModifiedProperties(); } private string[] FileField(Rect position, string label, string guid,Type type) { string[] guidPath = new string[2]; string path = AssetDatabase.GUIDToAssetPath(guid); UnityEngine.Object file = AssetDatabase.LoadAssetAtPath(path,type); EditorGUI.BeginChangeCheck(); { file = EditorGUI.ObjectField(position, label, file, type, false); } if (EditorGUI.EndChangeCheck()) { path = AssetDatabase.GetAssetPath(file); guid = AssetDatabase.AssetPathToGUID(path); } guidPath[0] = guid; guidPath[1] = path; return guidPath; } }上述代码仅供参考，拖入的object与实际序列化存储的不是同一个东西时，可以用上述类似的思路 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之二十二：基于TexturePacker的一键打图集工具]]></title>
    <url>%2F2018%2F09%2F09%2Funity-bian-ji-qi-tuo-zhan-zhi-er-shi-er-ji-yu-texturepacker-de-yi-jian-da-tu-ji-gong-ju%2F</url>
    <content type="text"><![CDATA[Unity编辑器拓展之二十二：基于TexturePacker的一键打图集工具NGUI使用TexturePacker打图集是一件频繁且费时的工作，只要美术稍一更新图片，就需要重新打图集，而且每次打图集的操作其实都是一样的重复劳动，基于此，开发工具批量打图集时很有必要的。 使用TexturePacker打图集，会输出两个文件，一个PNG合图，一个txt图集信息文件，而到Unity中使用UIAtlas，则需要一个Material材质文件和一个Prefab预制体文件，这两个文件也由工具生成。 鉴于项目不是从一开始就用该工具进行打图集工作的，因此这些文件的命名不具有统一的规范，因此使用一个配置文件来记录每个图集的输出文件信息。 ![这里写图片描述](https://img-blog.csdn.net/20180909133119352?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) Atlas.ini图集配置文件该文件以CSV格式进行配置，共有5列，图片文件夹相对路径、PNG合图输出路径、txt图集信息文件输出路径、UIAtlasPrefab输出路径、Material材质输出路径，后面四个输出路径都是基于Unity工程的Assets目录。 命令行打图集TexturePacker支持使用命令行打图集 $TexturePacker_PATH $imgDir --max-size 4096 --allow-free-size --format unity --size-constraints POT --shape-padding 2 --border-padding 2 --common-divisor-x 1 --common-divisor-y 1 --disable-rotation --algorithm MaxRects --opt RGBA8888 --scale 1 --scale-mode Smooth --smart-update --sheet $ASSETS_PATH$atlasPng --data $ASSETS_PATH$atlasData详细命令行介绍请自行搜索相关文档 一键批量设置图片资源设置PNG合图文件输出到Unity后，通过使用Unity提供的TextureImporter类和TextImporterPlatformSetting类进行图片设置 生成材质和Prefab问阿金并自动关联引用材质使用的Shader是“Unlit/TransparentColored”，mainTexture则为TexturePacker输出的合图，创建Prefab，并Add UIAtlasComponent，给UIAtlas组件导入texture和txt图集信息文件 NGUIEditorTools.ImportTexture(uiAtlas.texture, false, false, !uiAtlas.premultipliedAlpha); NGUIJson.LoadSpriteData(uiAtlas, atlasTextAsset);UIAtlas信息拷贝创建图集后，有时需要拷贝另一个图集的border和padding信息，例如两个图集内容其实是一直的，只是皮肤颜色不一样（换肤图集），因此这两个图集的border和padding数据是一样的，提供工具进行数据拷贝。 ![这里写图片描述](https://img-blog.csdn.net/20180909131827960?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 清理Editor进度条为避免Atlas.ini配置错误，导致打图集中断，而EditorUtility.DisplayProgressBar进度条无法清除，提供Editor进度条清理功能，菜单栏Tools-&gt;清理进度条 工程下载GitHub地址： https://github.com/JingFengJi/CreateAtlas 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>一键打图集工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之二十一：拓展Unity模块，打造私人工具库（二）]]></title>
    <url>%2F2018%2F08%2F22%2Funity-bian-ji-qi-tuo-zhan-zhi-er-shi-yi-tuo-zhan-unity-mo-kuai-da-zao-si-ren-gong-ju-ku-er%2F</url>
    <content type="text"><![CDATA[拓展Unity模块，打造私人工具库（二）前言：上一篇，实现了基本Unity模块拓展的功能，本篇将介绍如何通过反射来实现导入UnityPackage Gif示意图![这里写图片描述](https://img-blog.csdn.net/20180822230440180?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 程序导入UnityPackage通过查阅UnityEditor源代码发现，UnityEditor命名空间下有个EditorWindow的子类PackageImport，该类有个静态函数ShowImportPackage如下： public static void ShowImportPackage(string packagePath, ImportPackageItem[] items, string packageIconPath, bool allowReInstall) { if (PackageImport.ValidateInput(items)) { PackageImport window = EditorWindow.GetWindow&lt;PackageImport&gt;(true, &quot;Import Unity Package&quot;); window.Init(packagePath, items, packageIconPath, allowReInstall); } }该函数除了需要传入package 的路径外，还需要传入ImportPackageItem[]（也就是该package的内容），通过在UnityEditor中搜索ShowImportPackage函数调用，发现在AssetDataBase类中有一个静态函数ImportPackage用来导入Package的，该函数中先调用PackageUtility.ExtractAndPrepareAssetList函数获取到package里内容的列表，然后在调用的导入，当然此处还用到了interactive变量来控制是否打开ImportWindow。而PackageUtility.ExtractAndPrepareAssetList详细代码则是看不到了。 public static void ImportPackage(string packagePath, bool interactive) { if (string.IsNullOrEmpty(packagePath)) { throw new ArgumentException(&quot;Path can not be empty or null&quot;, &quot;packagePath&quot;); } string packageIconPath; bool allowReInstall; ImportPackageItem[] array = PackageUtility.ExtractAndPrepareAssetList(packagePath, out packageIconPath, out allowReInstall); if (array != null) { if (interactive) { PackageImport.ShowImportPackage(packagePath, array, packageIconPath, allowReInstall); } else { string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(packagePath); PackageUtility.ImportPackageAssets(fileNameWithoutExtension, array, false); } } }通过尝试，一次导入多个UnityPackage时，后一个会将前一个覆盖掉（估计是导入资源Unity需要加载并且编译吧），所以目前工具只能单个导入。 封装一个Package2Folder类，用来导入UnityPackage，只需调用ImportPackageToFolder函数即可。 ![这里写图片描述](https://img-blog.csdn.net/20180822232606973?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) public class Package2Folder { #region reflection stuff private delegate AssetsItem[] ImportPackageStep1Delegate(string packagePath, out string packageIconPath); private static Type assetServerType; private static Type AssetServerType { get { if (assetServerType == null) { assetServerType = typeof(MenuItem).Assembly.GetType(&quot;UnityEditor.AssetServer&quot;); } return assetServerType; } } private static ImportPackageStep1Delegate importPackageStep1; private static ImportPackageStep1Delegate ImportPackageStep1 { get { if (importPackageStep1 == null) { importPackageStep1 = (ImportPackageStep1Delegate)Delegate.CreateDelegate( typeof(ImportPackageStep1Delegate), null, AssetServerType.GetMethod(&quot;ImportPackageStep1&quot;)); } return importPackageStep1; } } private static MethodInfo importPackageStep2MethodInfo; private static MethodInfo ImportPackageStep2MethodInfo { get { if (importPackageStep2MethodInfo == null) { importPackageStep2MethodInfo = AssetServerType.GetMethod(&quot;ImportPackageStep2&quot;); } return importPackageStep2MethodInfo; } } private delegate object[] ExtractAndPrepareAssetListDelegate(string packagePath, out string packageIconPath, out bool allowReInstall); private static Type packageUtilityType; private static Type PackageUtilityType { get { if (packageUtilityType == null) { packageUtilityType = typeof(MenuItem).Assembly.GetType(&quot;UnityEditor.PackageUtility&quot;); } return packageUtilityType; } } private static ExtractAndPrepareAssetListDelegate extractAndPrepareAssetList; private static ExtractAndPrepareAssetListDelegate ExtractAndPrepareAssetList { get { if (extractAndPrepareAssetList == null) { extractAndPrepareAssetList = (ExtractAndPrepareAssetListDelegate)Delegate.CreateDelegate( typeof(ExtractAndPrepareAssetListDelegate), null, PackageUtilityType.GetMethod(&quot;ExtractAndPrepareAssetList&quot;)); } return extractAndPrepareAssetList; } } private static FieldInfo destinationAssetPathFieldInfo; private static FieldInfo DestinationAssetPathFieldInfo { get { if (destinationAssetPathFieldInfo == null) { Type importPackageItem = typeof(MenuItem).Assembly.GetType(&quot;UnityEditor.ImportPackageItem&quot;); destinationAssetPathFieldInfo = importPackageItem.GetField(&quot;destinationAssetPath&quot;); } return destinationAssetPathFieldInfo; } } private static MethodInfo importPackageAssetsMethodInfo; private static MethodInfo ImportPackageAssetsMethodInfo { get { if (importPackageAssetsMethodInfo == null) { // ImportPackageAssetsImmediately 是同步的导入5.4以上版本可用 importPackageAssetsMethodInfo = PackageUtilityType.GetMethod(&quot;ImportPackageAssetsImmediately&quot;) ?? PackageUtilityType.GetMethod(&quot;ImportPackageAssets&quot;); } return importPackageAssetsMethodInfo; } } private static MethodInfo showImportPackageMethodInfo; private static MethodInfo ShowImportPackageMethodInfo { get { if (showImportPackageMethodInfo == null) { Type packageImport = typeof(MenuItem).Assembly.GetType(&quot;UnityEditor.PackageImport&quot;); showImportPackageMethodInfo = packageImport.GetMethod(&quot;ShowImportPackage&quot;); } return showImportPackageMethodInfo; } } #endregion reflection stuff public static void ImportPackageToFolder(string packagePath, string selectedFolderPath, bool interactive) { string packageIconPath; bool allowReInstall; if (AssetServerType != null &amp;&amp; AssetServerType.GetMethod(&quot;ImportPackageStep1&quot;) != null) IsOlder53VersionAPI = true; else IsOlder53VersionAPI = false; //IsOlder53VersionAPI = false; object[] assetsItems = ExtractAssetsFromPackage(packagePath, out packageIconPath, out allowReInstall); if (assetsItems == null) return; foreach (object item in assetsItems) { ChangeAssetItemPath(item, selectedFolderPath); } if (interactive) { ShowImportPackageWindow(packagePath, assetsItems, packageIconPath, allowReInstall); } else { ImportPackageSilently(assetsItems); } } private static bool IsOlder53VersionAPI = false; public static object[] ExtractAssetsFromPackage(string path, out string packageIconPath, out bool allowReInstall) { if (IsOlder53VersionAPI) { AssetsItem[] array = ImportPackageStep1(path, out packageIconPath); allowReInstall = false; return array; } else { object[] array = ExtractAndPrepareAssetList(path, out packageIconPath, out allowReInstall); return array; } } private static void ChangeAssetItemPath(object assetItem, string selectedFolderPath) { if (IsOlder53VersionAPI) { AssetsItem item = (AssetsItem)assetItem; item.exportedAssetPath = selectedFolderPath + item.exportedAssetPath.Remove(0, 6); item.pathName = selectedFolderPath + item.pathName.Remove(0, 6); } else { string destinationPath = (string)DestinationAssetPathFieldInfo.GetValue(assetItem); destinationPath = selectedFolderPath + destinationPath.Remove(0, 6); DestinationAssetPathFieldInfo.SetValue(assetItem, destinationPath); } } public static void ShowImportPackageWindow(string path, object[] array, string packageIconPath, bool allowReInstall) { if (IsOlder53VersionAPI) { ShowImportPackageMethodInfo.Invoke(null, new object[] { path, array, packageIconPath }); } else { ShowImportPackageMethodInfo.Invoke(null, new object[] { path, array, packageIconPath, allowReInstall }); } } public static void ImportPackageSilently(object[] assetsItems) { if (IsOlder53VersionAPI) { ImportPackageStep2MethodInfo.Invoke(null, new object[] { assetsItems, false }); } else { ImportPackageAssetsMethodInfo.Invoke(null, new object[] { assetsItems, false }); } } private static string GetSelectedFolderPath() { UnityEngine.Object obj = Selection.activeObject; if (obj == null) return null; string path = AssetDatabase.GetAssetPath(obj.GetInstanceID()); return !Directory.Exists(path) ? null : path; } }参考文献【UnityEditor 编辑器间快速复制粘贴】： https://539go.com/2018/02/04/Unity-QuickCopy/ 引用了该文章中的UnityPackage导入代码。 工具下载git仓库： https://github.com/JingFengJi/UnityCenterTool 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>私人工具库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之二十：拓展Unity模块，打造私人工具库（一）]]></title>
    <url>%2F2018%2F08%2F20%2Funity-bian-ji-qi-tuo-zhan-zhi-er-shi-tuo-zhan-unity-mo-kuai-da-zao-si-ren-gong-ju-ku-yi%2F</url>
    <content type="text"><![CDATA[拓展Unity模块，打造私人工具库（一）功能介绍经过平时的项目积累，使用以及自己编写的编辑器工具越来越多，有些工具在别的项目中同样用的上，但是不希望每次都重新拷贝新代码到项目中，于是就希望能够拓展Unity模块，实现自己的工具库，方便导入工具到项目中。 通过查阅资料发现，在Unity的安装目录 Unity2017.3.1f1\Editor\Data\UnityExtensions\Unity(我的版本是2017.3.1f1)下，有一些Unity自带的模块，可以通过在该路径下放入自己的模块，就可以实现Unity新建的项目都拥有该拓展模块的功能。那么，接下来就写一个工具导入模块放入该文件夹中。 UnityExtensions文件结构基本介绍1、ivy.xml文件 其中：version、unityVersion均为当前Unity的版本号；artifact name 标签为我们的DLL文件的相对路径。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;ivy-module version=&quot;2.0&quot;&gt; &lt;info version=&quot;2017.3.1&quot; organisation=&quot;Unity&quot; module=&quot;UnityToolCenter&quot; e:packageType=&quot;UnityExtension&quot; e:unityVersion=&quot;2017.3.1f1&quot; xmlns:e=&quot;http://ant.apache.org/ivy/extra&quot; /&gt; &lt;publications xmlns:e=&quot;http://ant.apache.org/ivy/extra&quot;&gt; &lt;artifact name=&quot;Editor/UnityToolCenter&quot; type=&quot;dll&quot; ext=&quot;dll&quot; e:guid=&quot;adebbd281f1a4ef3a30be7f21937e02f&quot; /&gt; &lt;/publications&gt; &lt;/ivy-module&gt;2、Editor文件夹放入dll 代码中属于编辑器拓展的代码 逻辑说明工具初版示意图： ![这里写图片描述](https://img-blog.csdn.net/20180820223019383?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 通过勾选UnityPackage，直接导入到项目中，简单快捷。 为了不直接将UnityPackage文件放入到Unity安装目录下，因此新增一个config.ini文件，里面配置UnityPackage文件的路径（绝对路径），例如下图：![这里写图片描述](https://img-blog.csdn.net/2018082022321790?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) ![这里写图片描述](https://img-blog.csdn.net/2018082022325173?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 通过读取该配置文件，加载配置下所有路径的所有后缀名为unitypackage文件，然后显示在编辑器中。 使用介绍将脚本打成dll后，将UnityToolCenter.dll和UnityToolCenter.pdb文件放入安装目录下 ![这里写图片描述](https://img-blog.csdn.net/2018082022350796?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 修改ivy.xml文件为 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;ivy-module version=&quot;2.0&quot;&gt; &lt;info version=&quot;2017.3.1&quot; organisation=&quot;Unity&quot; module=&quot;UnityToolCenter&quot; e:packageType=&quot;UnityExtension&quot; e:unityVersion=&quot;2017.3.1f1&quot; xmlns:e=&quot;http://ant.apache.org/ivy/extra&quot; /&gt; &lt;publications xmlns:e=&quot;http://ant.apache.org/ivy/extra&quot;&gt; &lt;artifact name=&quot;Editor/UnityToolCenter&quot; type=&quot;dll&quot; ext=&quot;dll&quot; e:guid=&quot;adebbd281f1a4ef3a30be7f21937e02f&quot; /&gt; &lt;/publications&gt; &lt;/ivy-module&gt;【注意】版本号，以及dll的路径 此时，新建另一个Unity工程（同版本），就会发现菜单栏也带有Tools/UnityToolCenter，具体导入UnityPackage逻辑见下期 参考文献 https://539go.com/2017/10/20/UnityEditor-Unity%E7%9A%84%E6%A8%A1%E5%9D%97/ 工具终版见下期以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之十九：NGUI UISprite预览图Preview拓展]]></title>
    <url>%2F2018%2F08%2F10%2Funity-bian-ji-qi-tuo-zhan-zhi-shi-jiu-ngui-uisprite-yu-lan-tu-preview-tuo-zhan%2F</url>
    <content type="text"><![CDATA[NGUI UISprite预览图Preview拓展功能说明1、拓展UISprite的Preview视图，同时显示UIAtlas Texture和Sprite2、支持在UIAtlas上直接点选Sprite3、无需打开Atlas选择框和Sprite选择框两步操作 Gif示意图![这里写图片描述](https://img-blog.csdn.net/20180810224120831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 逻辑介绍1、找到UISpriteInspector脚本，其脚本的OnPreView函数逻辑，源码如下： public override void OnPreviewGUI (Rect rect, GUIStyle background) { UISprite sprite = target as UISprite; if (sprite == null || !sprite.isValid) return; Texture2D tex = sprite.mainTexture as Texture2D; if (tex == null) return; UISpriteData sd = sprite.atlas.GetSprite(sprite.spriteName); NGUIEditorTools.DrawSprite(tex, rect, sd, sprite.color); }其中NGUIEditorTools.DrawSprite函数负责绘制Sprite，包括背景、border line、out line、sizelabel等，如下图所示： 2、PreView区域为左右两边，分别绘制Atlas Texture和Sprite，并且AtlasTexture在绘制时依然采用sprite的绘制样式，底图背景 + 黑色轮廓，再次基础上使用的Sprite采用绿色轮廓 public override void OnPreviewGUI (Rect rect, GUIStyle background) { UISprite sprite = target as UISprite; if (sprite == null || !sprite.isValid) return; Texture2D tex = sprite.mainTexture as Texture2D; if (tex == null) return; float interval = 10f; float width = (rect.width - interval) / 2; Rect leftRect = new Rect(rect.x,rect.y,width,rect.height); Rect rightRect = new Rect(rect.x + width + interval,rect.y,width,rect.height); UISpriteData sd = sprite.atlas.GetSprite(sprite.spriteName); NGUIEditorTools.DrawAtlas(tex,leftRect,sd); NGUIEditorTools.DrawSprite(tex, rightRect, sd, sprite.color); } static public void DrawAtlas(Texture2D tex,Rect drawRect,UISpriteData sprite) { if (!tex) return; // Create the texture rectangle that is centered inside rect. Rect outerRect = drawRect; outerRect.width = tex.width; outerRect.height = tex.height; if (tex.width &gt; 0) { float f = drawRect.width / outerRect.width; outerRect.width *= f; outerRect.height *= f; } if (drawRect.height &gt; outerRect.height) { outerRect.y += (drawRect.height - outerRect.height) * 0.5f; } else if (outerRect.height &gt; drawRect.height) { float f = drawRect.height / outerRect.height; outerRect.width *= f; outerRect.height *= f; } if (drawRect.width &gt; outerRect.width) outerRect.x += (drawRect.width - outerRect.width) * 0.5f; // Draw the background NGUIEditorTools.DrawTiledTexture(outerRect, NGUIEditorTools.backdropTexture); Handles.color = Color.black; Handles.DrawLine(new Vector3(outerRect.xMin, outerRect.yMin), new Vector3(outerRect.xMin, outerRect.yMax)); Handles.DrawLine(new Vector3(outerRect.xMax, outerRect.yMin), new Vector3(outerRect.xMax, outerRect.yMax)); Handles.DrawLine(new Vector3(outerRect.xMin, outerRect.yMin), new Vector3(outerRect.xMax, outerRect.yMin)); Handles.DrawLine(new Vector3(outerRect.xMin, outerRect.yMax), new Vector3(outerRect.xMax, outerRect.yMax)); if(sprite != null) { Handles.color = Color.green; Rect spriteOutlineRect = outerRect; float r = outerRect.width / tex.width; spriteOutlineRect.x = outerRect.xMin + sprite.x * r; spriteOutlineRect.y = outerRect.yMin + sprite.y * r; spriteOutlineRect.width = sprite.width * r; spriteOutlineRect.height = sprite.height * r; Handles.DrawLine(new Vector3(spriteOutlineRect.xMin, spriteOutlineRect.yMin), new Vector3(spriteOutlineRect.xMin, spriteOutlineRect.yMax)); Handles.DrawLine(new Vector3(spriteOutlineRect.xMax, spriteOutlineRect.yMin), new Vector3(spriteOutlineRect.xMax, spriteOutlineRect.yMax)); Handles.DrawLine(new Vector3(spriteOutlineRect.xMin, spriteOutlineRect.yMin), new Vector3(spriteOutlineRect.xMax, spriteOutlineRect.yMin)); Handles.DrawLine(new Vector3(spriteOutlineRect.xMin, spriteOutlineRect.yMax), new Vector3(spriteOutlineRect.xMax, spriteOutlineRect.yMax)); } Rect uv = new Rect(0, 0, tex.width, tex.height); uv = NGUIMath.ConvertToTexCoords(uv, tex.width, tex.height); GUI.DrawTextureWithTexCoords(outerRect, tex, uv, true); // Sprite size label string text = string.Format(&quot;Atlas Size: {0}x{1}&quot;, Mathf.RoundToInt(tex.width), Mathf.RoundToInt(tex.height)); EditorGUI.DropShadowLabel(GUILayoutUtility.GetRect(Screen.width, 18f), text); }示意图如下：![这里写图片描述](https://img-blog.csdn.net/20180810223913392?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 3、点选功能实现 public override void OnPreviewGUI (Rect rect, GUIStyle background) { UISprite sprite = target as UISprite; if (sprite == null || !sprite.isValid) return; Texture2D tex = sprite.mainTexture as Texture2D; if (tex == null) return; float interval = 10f; float width = (rect.width - interval) / 2; Rect leftRect = new Rect(rect.x,rect.y,width,rect.height); Rect rightRect = new Rect(rect.x + width + interval,rect.y,width,rect.height); UISpriteData sd = sprite.atlas.GetSprite(sprite.spriteName); NGUIEditorTools.DrawAtlas(tex,leftRect,sd); NGUIEditorTools.DrawSprite(tex, rightRect, sd, sprite.color); //点选图片 Event e = Event.current; if(e.type == EventType.MouseDown) { //下面函数通过点击的坐标，和texture、texture draw rect等信息计算出被点选的sprite UISpriteData click = NGUIEditorTools.GetUISpriteData(tex,sprite.atlas,leftRect,e.mousePosition); if(click != null) { sprite.spriteName = click.name; EditorUtility.SetDirty(sprite); } } } //获取sprite在preview中的区域 static public Rect GetAreaInPreview(Texture2D tex,Rect drawRect,UISpriteData sprite) { // Create the texture rectangle that is centered inside rect. Rect outerRect = drawRect; outerRect.width = tex.width; outerRect.height = tex.height; if (tex.width &gt; 0) { float f = drawRect.width / outerRect.width; outerRect.width *= f; outerRect.height *= f; } if (drawRect.height &gt; outerRect.height) { outerRect.y += (drawRect.height - outerRect.height) * 0.5f; } else if (outerRect.height &gt; drawRect.height) { float f = drawRect.height / outerRect.height; outerRect.width *= f; outerRect.height *= f; } if (drawRect.width &gt; outerRect.width) outerRect.x += (drawRect.width - outerRect.width) * 0.5f; Rect spriteOutlineRect = outerRect; float r = outerRect.width / tex.width; spriteOutlineRect.x = outerRect.xMin + sprite.x * r; spriteOutlineRect.y = outerRect.yMin + sprite.y * r; spriteOutlineRect.width = sprite.width * r; spriteOutlineRect.height = sprite.height * r; return spriteOutlineRect; } //根据点击的坐标，循环遍历出哪个Sprite的Area包含了该pos即可 static public UISpriteData GetUISpriteData(Texture2D tex, UIAtlas atlas,Rect drawRect,Vector2 pos) { List&lt;UISpriteData&gt; sprites = atlas.spriteList; if(sprites == null || sprites.Count &lt;= 0) return null; for (int i = 0; i &lt; sprites.Count; i++) { UISpriteData sprite = sprites[i]; Rect area = GetAreaInPreview(tex,drawRect,sprite); if(area.Contains(pos)) { return sprite; } } return null; }以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>UISprite组件预览拓展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用软件集锦]]></title>
    <url>%2F2018%2F08%2F06%2Fchang-yong-ruan-jian-ji-jin%2F</url>
    <content type="text"><![CDATA[1、图片查重文件查重，如果只是文件名或者md5码的匹配查重，功能就不全面了，尤其是图片查重。图片查重应该更侧重于图片内容相似度查重。最近项目中使用TexturePacker&amp; NGUI，发现存在一些图片重复，新人对业务逻辑不熟悉，导致图片乱放等问题，使得图片存在重复、浪费资源等。因此收集了Windows 和Mac下使用的两款图片查重软件。 Win http://www.newrain.cn/app/info/1 ![这里写图片描述](https://img-blog.csdn.net/20180806211702519?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 支持修改相似度进行匹配查重 MacSnapSelect软件 官网： https://skylum.com/snapselect pojie版请自行下载 ![这里写图片描述](https://img-blog.csdn.net/20180806212314576?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 支持四个级别的相似度查重 （Low、High、、、） 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>常用软件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之十八：NGUI批量替换图集工具 2.0版本]]></title>
    <url>%2F2018%2F08%2F04%2Funity-bian-ji-qi-tuo-zhan-zhi-shi-ba-ngui-pi-liang-ti-huan-tu-ji-gong-ju-2.0-ban-ben%2F</url>
    <content type="text"><![CDATA[Unity编辑器拓展之十五：NGUI批量替换图集工具 2.0版本1.0版本 https://blog.csdn.net/qq_26999509/article/details/81256493 新增内容工具1.0版本，同事在使用过程中，发现批量替换图集时，不一定是全部都替换，这样的话，工具就没法使用了。2.0版本新增功能：对于替换图集的Sprite支持可选择性的是否替换。 工具截图![这里写图片描述](https://img-blog.csdn.net/20180804224118848?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 在之前的右下角空白区域，增加了预制体所有UISprite的列表显示，使用的TreeView编写的。 TreeView介绍目前，TreeView我还没有单独写文字来介绍该内容，后续会更新。官方文档： https://docs.unity3d.com/Manual/TreeViewAPI.html 代码Git地址 https://github.com/JingFengJi/ReplaceAtlas 欢迎加星 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。 2018.8.5日更新更新内容1、支持Sprite预览 Gif示例图![这里写图片描述](https://img-blog.csdn.net/20180805211815279?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 重要代码介绍Sprite的绘制，是通过查看UISpriteInspector类（NGUI）发现的，该类中在使用OnPreviewGUI接口绘制示意图的时候，调用了NGUIEdiotrTools.DrawSprite接口 public override void OnPreviewGUI (Rect rect, GUIStyle background) { UISprite sprite = target as UISprite; if (sprite == null || !sprite.isValid) return; Texture2D tex = sprite.mainTexture as Texture2D; if (tex == null) return; UISpriteData sd = sprite.atlas.GetSprite(sprite.spriteName); NGUIEditorTools.DrawSprite(tex, rect, sd, sprite.color); }![这里写图片描述](https://img-blog.csdn.net/20180805212237230?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 那里这次更新的内容，也使用该接口进行绘制。详情请看NGUI源码。 但是，该处PreviewGUI在底部绘制了 SpriteSize的Label，而本工具不需要将图和尺寸信息绘制在一起，因此修改了源码，增加了一个bool类型的needSizeLabel参数，来控制是否显示尺寸信息 ![这里写图片描述](https://img-blog.csdn.net/20180805212621503?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 代码Git地址 https://github.com/JingFengJi/ReplaceAtlas 欢迎加星 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>批量替换NGUI预制图集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之十七：NGUI ComponentSelector增加搜索框]]></title>
    <url>%2F2018%2F07%2F31%2Funity-bian-ji-qi-tuo-zhan-zhi-shi-qi-ngui-componentselector-zeng-jia-sou-suo-kuang%2F</url>
    <content type="text"><![CDATA[NGUI ComponentSelector增加搜索框目的最近在使用NGUI，给Sprite选择图集的时候，没有搜索框要挨个找挺麻烦，因此修改一下ComponentSelector组件，增加一个搜索框，便于搜索图集 ![这里写图片描述](https://img-blog.csdn.net/20180731230908117?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) Gif动图展示![这里写图片描述](https://img-blog.csdn.net/20180731232015407?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) SearchField介绍关于SearchField介绍请看 Unity编辑器拓展之九 代码以下代码是修改的NGUI里的ComponentSelector脚本 private SearchField search; private bool isInit = false; private string searchStr = &quot;&quot;; private void IfNeedInit() { if(isInit == false) search = new SearchField(); isInit = true; } void OnGUI () { IfNeedInit(); searchStr = search.OnGUI(new Rect(10,10,200,10),searchStr); searchStr = searchStr.ToLower(); //省略后面源码 } bool DrawObject (Object obj) { if (obj == null) return false; //搜索 if(!string.IsNullOrEmpty(searchStr) &amp;&amp; !obj.name.ToLower().Contains(searchStr)) return false; bool retVal = false; Component comp = obj as Component; GUILayout.BeginHorizontal(); { string path = AssetDatabase.GetAssetPath(obj); if (string.IsNullOrEmpty(path)) { path = &quot;[Embedded]&quot;; GUI.contentColor = new Color(0.7f, 0.7f, 0.7f); } else if (comp != null &amp;&amp; EditorUtility.IsPersistent(comp.gameObject)) GUI.contentColor = new Color(0.6f, 0.8f, 1f); retVal |= GUILayout.Button(obj.name, &quot;AS TextArea&quot;, GUILayout.Width(160f), GUILayout.Height(20f)); retVal |= GUILayout.Button(path.Replace(&quot;Assets/&quot;, &quot;&quot;), &quot;AS TextArea&quot;, GUILayout.Height(20f)); GUI.contentColor = Color.white; retVal |= GUILayout.Button(&quot;Select&quot;, &quot;ButtonLeft&quot;, GUILayout.Width(60f), GUILayout.Height(16f)); } GUILayout.EndHorizontal(); return retVal; }以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>NGUI ComponentSelector增加搜索框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之十六：监听Scene Drag事件]]></title>
    <url>%2F2018%2F07%2F30%2Funity-bian-ji-qi-tuo-zhan-zhi-shi-liu-jian-ting-scene-drag-shi-jian%2F</url>
    <content type="text"><![CDATA[监听Scene Drag事件Gif动图展示![这里写图片描述](https://img-blog.csdn.net/20180730212155553?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 目的通过该监听，获取到被Drag进Scene的物体的类型，可以做一些预处理，例如：Drag一张图片，直接生成一个GameObject（带Image，前提是UGUI）的放在Canvas下 代码using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; public class SceneManager { [InitializeOnLoadMethod] static void Init() { SceneView.onSceneGUIDelegate += OnSceneGUI; } private static void OnSceneGUI(SceneView sceneView) { Event e = Event.current; if(e.type == EventType.DragUpdated || e.type == EventType.DragPerform) { DragAndDrop.visualMode = DragAndDropVisualMode.Copy; if(e.type == EventType.DragPerform) { DragAndDrop.AcceptDrag(); for (int i = 0; i &lt; DragAndDrop.objectReferences.Length; i++) { Object handleObj = DragAndDrop.objectReferences[i]; if(handleObj != null) { Debug.LogError(handleObj.GetType()); } } } } } }以上知识分享，如有错误，欢迎指出，共同学习，共同进步]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>SceneDrag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之十五：NGUI批量替换图集工具]]></title>
    <url>%2F2018%2F07%2F28%2Funity-bian-ji-qi-tuo-zhan-zhi-shi-wu-ngui-pi-liang-ti-huan-tu-ji-gong-ju%2F</url>
    <content type="text"><![CDATA[NGUI批量替换图集工具工具目的因项目需要实现换肤的功能，也就是多套UI图集，提供工具批量换图集，方便查看Prebab各皮肤（图集）下的效果 示意图Gif 操作动图：![这里写图片描述](https://img-blog.csdn.net/20180728004232812?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 工具截图：![这里写图片描述](https://img-blog.csdn.net/20180728004352956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 工具左侧是工程所有Prefab列表，右侧是替换图集的功能菜单，从指定原图集替换成目标图集 逻辑与上文：Unity编辑器之十四：字体替换工具 https://blog.csdn.net/qq_26999509/article/details/81106083 一样，其实找到Prebfab下所有UISprite，并将其所有指定原图集 替换成指定的目标图集，以此实现换肤的功能，当然两图集的SpriteName应该保持一致，不然没办法知道要换成目标图集里的那张图。 重点代码private void ReplacePrefabAtalas(GameObject prefab , UIAtlas atlas,UIAtlas targetAtlas) { if(prefab == null || atlas == null) return; UISprite[] sprites = prefab.GetComponentsInChildren&lt;UISprite&gt;(true); if(sprites != null &amp;&amp; sprites.Length &gt; 0) { int num = sprites.Length; for (int i = 0; i &lt; num; i++) { UISprite s = sprites[i]; if(s != null &amp;&amp; s.atlas == atlas) { s.atlas = targetAtlas; EditorUtility.SetDirty(s); } } } AssetDatabase.SaveAssets(); }使用1、Tools-&gt;ReplaceAtalas 打开工具 ![这里写图片描述](https://img-blog.csdn.net/20180728005410396?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 2、选中待处理预制体，鼠标右键-&gt;替换图集 ![这里写图片描述](https://img-blog.csdn.net/20180728005536617?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 3、![这里写图片描述](https://img-blog.csdn.net/20180728005711218?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 4、 ![这里写图片描述](https://img-blog.csdn.net/20180728010026779?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 工具代码using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using System.IO; using UnityEditor.IMGUI.Controls; public class ReplaceAtalas : EditorWindow { private static ReplaceAtalas window = null; private static List&lt;string&gt; prefabPathList = new List&lt;string&gt; (); private static string assetPath; Rect SearchFieldRect { get { return new Rect(interval,interval,position.width * 0.3f,20f); } } Rect prefabListRect { get { return new Rect (interval, interval + SearchFieldRect.yMax, SearchFieldRect.width, window.position.height - SearchFieldRect.yMax - 2 * interval); } } Rect replaceAtalsRect { get{return new Rect(prefabListRect.xMax + interval,interval,window.position.width - SearchFieldRect.width - 3 * interval,window.position.height - 2 * interval);} } private Vector2 scrollWidgetPos; private float interval = 20f; private string searchStr = &quot;&quot;; private SearchField searchField; private bool initialized = false; [MenuItem(&quot;Assets/替换图集&quot;, false, 2001)] public static void OpenWindow() { string selectedAssetPath = AssetDatabase.GetAssetPath (Selection.activeObject); if(!string.IsNullOrEmpty(selectedAssetPath) &amp;&amp; selectedAssetPath.EndsWith(&quot;.prefab&quot;)) { ReplaceAtalas window = ShowWindow(); if(window != null) { window.AutoSelctPrefab(selectedAssetPath); } } } [MenuItem(&quot;Tools/ReplaceAtalas&quot;)] public static ReplaceAtalas ShowWindow() { prefabPathList.Clear (); assetPath = Application.dataPath; GetFiles (new DirectoryInfo (assetPath), &quot;*.prefab&quot;, ref prefabPathList); if (window == null) window = EditorWindow.GetWindow(typeof(ReplaceAtalas)) as ReplaceAtalas; window.titleContent = new GUIContent(&quot;ReplaceAtalas&quot;); window.Show(); return window; } public static void GetFiles (DirectoryInfo directory, string pattern, ref List&lt;string&gt; fileList) { if (directory != null &amp;&amp; directory.Exists &amp;&amp; !string.IsNullOrEmpty (pattern)) { try { foreach (FileInfo info in directory.GetFiles (pattern)) { string path = info.FullName.ToString (); fileList.Add (path.Substring (path.IndexOf (&quot;Assets&quot;))); } } catch (System.Exception) { throw; } foreach (DirectoryInfo info in directory.GetDirectories ()) { GetFiles (info, pattern, ref fileList); } } } private void OnGUI() { InitIfNeeded(); DrawWindow(); } private void DrawWindow() { DrawSearchField(); DrawPrefabList(); DrawReplaceAtalasTool(); } private void InitIfNeeded() { if(!initialized) { if (null == searchField) searchField = new SearchField (); } initialized = true; } private void DrawSearchField() { GUI.backgroundColor = Color.white; searchStr = searchField.OnGUI (SearchFieldRect, searchStr); searchStr = searchStr.ToLower(); } private void DrawPrefabList() { GUI.backgroundColor = Color.white; GUI.Box(prefabListRect,&quot;&quot;); GUILayout.BeginArea(prefabListRect); scrollWidgetPos = EditorGUILayout.BeginScrollView(scrollWidgetPos); for (int i = 0; i &lt; prefabPathList.Count; i++) { if(CheckShowPrefab(prefabPathList[i],searchStr)) { if(GUILayout.Button(prefabPathList[i])) { curReplacePrefabPath = prefabPathList[i]; curPrefabAtlas = GetPrefabAllAtlas(curReplacePrefabPath); } } } EditorGUILayout.EndScrollView(); GUILayout.EndArea(); } private string curReplacePrefabPath = &quot;&quot;; private bool CheckShowPrefab(string path,string searchstr) { if(string.IsNullOrEmpty(searchStr)) return true; if(string.IsNullOrEmpty(path)) return false; return GetFileNameWithSuffix(path.ToLower()).Contains(searchStr); } //包括后缀名 private string GetFileNameWithSuffix(string path) { if(string.IsNullOrEmpty(path)) return string.Empty; return path.Substring(path.LastIndexOf(&quot;/&quot;)+1); } private UIAtlas curAtlas; private UIAtlas targetAtlas; void OnSelectAtlas (Object obj) { UIAtlas atlas = obj as UIAtlas; if(isSelectCurAtlas) { curAtlas = obj as UIAtlas; } else if(isSelectTargetAtlas) { targetAtlas = obj as UIAtlas; } isSelectCurAtlas = false; isSelectTargetAtlas = false; } private bool isSelectCurAtlas = false; private bool isSelectTargetAtlas = false; private List&lt;UIAtlas&gt; curPrefabAtlas = new List&lt;UIAtlas&gt;(); private void DrawReplaceAtalasTool() { GUI.backgroundColor = Color.white; GUILayout.BeginArea(replaceAtalsRect); EditorGUILayout.LabelField(curReplacePrefabPath); GUILayout.BeginHorizontal(); EditorGUILayout.LabelField(&quot;该预制体含有的所有图集:&quot;,GUILayout.Width(150)); if(curPrefabAtlas.Count &gt; 0) { for (int i = 0; i &lt; curPrefabAtlas.Count; i++) { if(GUILayout.Button(curPrefabAtlas[i].name)) { curAtlas = curPrefabAtlas[i]; } if(GUILayout.Button(&quot;Edit&quot;)) { //NGUISettings.atlas = mFont.atlas; //NGUISettings.selectedSprite = sym.spriteName; NGUIEditorTools.Select(curPrefabAtlas[i].gameObject); } } } GUILayout.EndHorizontal(); //原图集 GUILayout.BeginHorizontal(); curAtlas = (UIAtlas)EditorGUILayout.ObjectField(&quot;被替换图集&quot;, curAtlas, typeof(UIAtlas), true); if (NGUIEditorTools.DrawPrefixButton(&quot;选择Atlas&quot;,GUILayout.Width(200))) { isSelectCurAtlas = true; ComponentSelector.Show&lt;UIAtlas&gt;(OnSelectAtlas); } GUILayout.EndHorizontal(); //目标图集 GUILayout.BeginHorizontal(); targetAtlas = (UIAtlas)EditorGUILayout.ObjectField(&quot;目标图集&quot;, targetAtlas, typeof(UIAtlas), true); if (NGUIEditorTools.DrawPrefixButton(&quot;选择Atlas&quot;,GUILayout.Width(200))) { isSelectTargetAtlas = true; ComponentSelector.Show&lt;UIAtlas&gt;(OnSelectAtlas); } GUILayout.EndHorizontal(); if(GUILayout.Button(&quot;互换&quot;)) { UIAtlas tmpCurAtlas = curAtlas; curAtlas = targetAtlas; targetAtlas = tmpCurAtlas; } //替换按钮 if(GUILayout.Button(&quot;替换图集&quot;)) { if(string.IsNullOrEmpty(curReplacePrefabPath)) { EditorUtility.DisplayDialog(&quot;提示&quot;, &quot;请先选择一个预制体!&quot;, &quot;确定&quot;); } else if (curAtlas == null) { EditorUtility.DisplayDialog(&quot;提示&quot;, &quot;请先指定被替换图集!&quot;, &quot;确定&quot;); } else { if(targetAtlas == null) { if(EditorUtility.DisplayDialog(&quot;提示&quot;, &quot;原图集将被清空，确定替换吗？&quot;, &quot;确定&quot;,&quot;取消&quot;)) { ReplacePrefabAtalas(curReplacePrefabPath); } } else { ReplacePrefabAtalas(curReplacePrefabPath); } } } //保存按钮 //撤销按钮 GUILayout.EndArea(); } private void ReplacePrefabAtalas(string path) { if(string.IsNullOrEmpty(path)) return; GameObject gameObj = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path); ReplacePrefabAtalas(gameObj,curAtlas,targetAtlas); } private List&lt;UIAtlas&gt; GetPrefabAllAtlas(string path) { if(string.IsNullOrEmpty(path)) return null; GameObject gameObj = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path); return GetPrefabAllAtlas(gameObj); } private List&lt;UIAtlas&gt; GetPrefabAllAtlas(GameObject prefab) { if(null == prefab) return null; List&lt;UIAtlas&gt; atlass = new List&lt;UIAtlas&gt;(); UISprite[] sprites = prefab.GetComponentsInChildren&lt;UISprite&gt;(true); if(sprites != null &amp;&amp; sprites.Length &gt; 0) { int num = sprites.Length; for (int i = 0; i &lt; num; i++) { UISprite s = sprites[i]; if(s != null &amp;&amp; !atlass.Contains(s.atlas)) { atlass.Add(s.atlas); } } } return atlass; } private void ReplacePrefabAtalas(GameObject prefab , UIAtlas atlas,UIAtlas targetAtlas) { if(prefab == null || atlas == null) return; UISprite[] sprites = prefab.GetComponentsInChildren&lt;UISprite&gt;(true); if(sprites != null &amp;&amp; sprites.Length &gt; 0) { int num = sprites.Length; for (int i = 0; i &lt; num; i++) { UISprite s = sprites[i]; if(s != null &amp;&amp; s.atlas == atlas) { s.atlas = targetAtlas; EditorUtility.SetDirty(s); } } } AssetDatabase.SaveAssets(); } public void AutoSelctPrefab(string prefabPath) { if(string.IsNullOrEmpty(prefabPath)) return; curReplacePrefabPath = prefabPath; curPrefabAtlas = GetPrefabAllAtlas(curReplacePrefabPath); curAtlas = null; targetAtlas = null; } }代码Git地址 https://github.com/JingFengJi/ReplaceAtlas 欢迎加星 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>NGUI批量替换图集工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之十四：字体替换工具]]></title>
    <url>%2F2018%2F07%2F18%2Funity-bian-ji-qi-tuo-zhan-zhi-shi-si-zi-ti-ti-huan-gong-ju%2F</url>
    <content type="text"><![CDATA[字体替换工具![这里写图片描述](https://img-blog.csdn.net/20180718215424988?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 选择NGUI还是UGUI，选择替换的字体以及字号比例，就可以替换工程目录下所有预制体的字体了 脚本using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using System.IO; using UnityEngine.UI; public class ReplaceFont : EditorWindow { private static ReplaceFont window = null; private static List&lt;string&gt; prefafbPathList = new List&lt;string&gt;(); private static Font targetFont; private static Font curFont; private static float fontSizeRatio = 1f; private static bool isUGUI = true; [MenuItem(&quot;Tools/替换字体&quot;)] public static void CSVCode() { if (window == null) window = EditorWindow.GetWindow(typeof(ReplaceFont)) as ReplaceFont; GetFiles(new DirectoryInfo(Application.dataPath), &quot;*.prefab&quot;, ref prefafbPathList); window.titleContent = new GUIContent(&quot;ReplaceFont&quot;); window.Show(); } public static void GetFiles(DirectoryInfo directory, string pattern, ref List&lt;string&gt; fileList) { if (directory != null &amp;&amp; directory.Exists &amp;&amp; !string.IsNullOrEmpty(pattern)) { try { foreach (FileInfo info in directory.GetFiles(pattern)) { string path = info.FullName.ToString(); fileList.Add(path.Substring (path.IndexOf (&quot;Assets&quot;))); } } catch (System.Exception) { throw; } foreach (DirectoryInfo info in directory.GetDirectories()) { GetFiles(info, pattern, ref fileList); } } } void OnGUI() { EditorGUILayout.BeginHorizontal(); isUGUI = EditorGUILayout.Toggle(&quot;UGUI&quot;,isUGUI); isUGUI = EditorGUILayout.Toggle(&quot;NGUI&quot;, !isUGUI); EditorGUILayout.EndHorizontal(); curFont = (Font) EditorGUILayout.ObjectField(&quot;被替换字体&quot;, curFont, typeof(Font), true); targetFont = (Font) EditorGUILayout.ObjectField(&quot;目标字体&quot;, targetFont, typeof(Font), true); EditorGUILayout.BeginHorizontal(); EditorGUILayout.LabelField(&quot;字号比例：&quot;); fontSizeRatio = EditorGUILayout.FloatField(fontSizeRatio); EditorGUILayout.EndHorizontal(); if(GUILayout.Button(&quot;一键替换&quot;)) { for (int i = 0; i&lt;prefafbPathList.Count; i++) { GameObject gameObj = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(prefafbPathList[i]); Change(gameObj); } AssetDatabase.SaveAssets(); } } public static void Change(GameObject prefab) { if(null != prefab) { Component[] labels = null; if(isUGUI) { labels = prefab.GetComponentsInChildren&lt;Text&gt;(true); } else { //labels = prefab.GetComponentsInChildren&lt;UILabel&gt;(true); } if(null != labels) foreach (Object item in labels) { if(isUGUI) { Text text = (Text)item; int newFontSize = (int)(text.fontSize * fontSizeRatio); if (text.font.name == curFont.name) { text.font = targetFont; text.fontSize = newFontSize; } } else { // UILabel label = (UILabel)item; // int newFontSize = (int)(label.fontSize * fontSizeRatio); // if (label.trueTypeFont.name == curFont.name) // { // label.trueTypeFont = targetFont; // label.fontSize = newFontSize; // } } EditorUtility.SetDirty(item); } } } }代码下载 https://github.com/JingFengJi/ReplaceFont.git 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>字体替换工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之十三：CSV文件解析代码生成工具]]></title>
    <url>%2F2018%2F07%2F17%2Funity-bian-ji-qi-tuo-zhan-zhi-shi-san-csv-wen-jian-jie-xi-dai-ma-sheng-cheng-gong-ju%2F</url>
    <content type="text"><![CDATA[CSV文件解析代码生成工具工具示意图![这里写图片描述](https://img-blog.csdn.net/20180717221145417?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 左侧是工程下所有的CSV文件列表，并提供搜索框，右侧是解析部分，上边提供了保存代码文件和拷贝代码的菜单，中间是CSV文件预解析出来的字段、数据类型（可选）等，下面是代码预览区域。 获取所有CSV文件的路径使用递归获取所有CSV文件的路径，并绘制在左侧 [MenuItem(&quot;Tools/CreateCSVParseCode&quot;)] public static void CSVCode() { csvFilesPathList.Clear (); assetPath = Application.dataPath; //获取所有CSV文件的路径 GetFiles (new DirectoryInfo (assetPath), &quot;*.csv&quot;, ref csvFilesPathList); if (window == null) window = EditorWindow.GetWindow(typeof(CreateCSVParseCode)) as CreateCSVParseCode; window.titleContent = new GUIContent(&quot;CreateCSVParseCode&quot;); if(isLimitSize) { window.minSize = new Vector2(1420,674); window.maxSize = new Vector2(1420,674); } window.Show(); } public static void GetFiles (DirectoryInfo directory, string pattern, ref List&lt;string&gt; fileList) { if (directory != null &amp;&amp; directory.Exists &amp;&amp; !string.IsNullOrEmpty (pattern)) { try { foreach (FileInfo info in directory.GetFiles (pattern)) { string path = info.FullName.ToString (); fileList.Add (path.Substring (path.IndexOf (&quot;Assets&quot;))); } } catch (System.Exception) { throw; } foreach (DirectoryInfo info in directory.GetDirectories ()) { GetFiles (info, pattern, ref fileList); } } }预解析CSV文件定义一个类存储预解析数据 public class CsvData { public string header; public DataType dataType; public bool isParse = true; } public enum DataType { Int = 0, String = 1, Double = 2, Bool = 3, //后续更新下面三种类型数据的解析 //Vector3 = 4, //Vector2 = 5, //Color = 6, }详细代码参考后面代码工程git地址 代码格式化将解析代码格式化存储在一个类中，以string format的形式存在。 using System.Collections; using System.Collections.Generic; using UnityEngine; public class CSVCodeConfig { public static string DataClassFormat = @&quot;public class {0} {{ {1}}}&quot;; //如果是带Vector3或者Vector3类型的数据需要使用带有UnityEngiine命名空间 public static string DataClassNameSpaceFormat = @&quot; using UnityEngine; public class {0} {{ {1} }}&quot;; public static string FieldFormat = &quot;\tpubilc {0} {1} {{ set; get; }}&quot;; public static string ClassNameFormat = &quot;{0}Model&quot;; public static string ModelListPrivateStatementFormat = &quot;private List&lt;{0}&gt; {1}&quot;; public static string ModelListPublicPropertyFormat = @&quot; public List&lt;{0}&gt; {1} {{ get {{ if({2} == null) {{ {3}(); }} return {4}; }} }}&quot;; public static string parseMethodNameFormat = &quot;Init{0}&quot;; public static string methodFormat = &quot;{0}();&quot;; public static string ModelDataParseMethodFormat = @&quot; private void {0}() {{ {1} = new List; string path = DEFAULT_CSV_PATH + {3}; CSVTable csvTable = CsvLoader.LoadCSV(path); foreach (CSVRecord record in csvTable.Records) {{ {4} temp = new {5}(); foreach (string header in csvTable.Headers) {{ {6} }} {7}.Add(temp); }} }}&quot;; public static string ModelDataHeaderEqualFormat_1 = @&quot;if (string.Equals(header, {0})) {{ {1} }}&quot;; public static string ModelDataHeaderEqualFormat_2 = @&quot; else if (string.Equals(header, {0})) {{ {1} }}&quot;; public static string ModelDataFieldValuationFormat_String = &quot;temp.{0} = record.GetField(header);&quot;; public static string ModelDataFieldValuationFormat_Int = &quot;temp.{0} = ConvertUtil.Str2Int(record.GetField(header));&quot;; public static string ModelDataFieldValuationFormat_Double = &quot;temp.{0} = ConvertUtil.Str2Double(record.GetField(header));&quot;; public static string ModelDataFieldValuationFormat_Bool = &quot;temp.{0} = ConvertUtil.Str2Int(record.GetField(header)) != 0;&quot;; }完整工程 https://github.com/JingFengJi/CSVParseCodeCreate 第三方ReorderableList编辑器工具Rotorz 下载地址： https://bitbucket.org/rotorz/reorderable-list-editor-field-for-unity 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>CSV文件解析代码生成工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏功能模块——新手引导]]></title>
    <url>%2F2018%2F07%2F06%2Fyou-xi-gong-neng-mo-kuai-xin-shou-yin-dao%2F</url>
    <content type="text"><![CDATA[新手引导流程图![这里写图片描述](https://img-blog.csdn.net/20180706225632527?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 数据![这里写图片描述](https://img-blog.csdn.net/20180706225847458?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 代码遮罩Shader1、圆形遮罩 // Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt) Shader &quot;UI/BeginnerGuidance/CircleGuidance&quot; { Properties { [PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; {} _Color (&quot;Tint&quot;, Color) = (1,1,1,1) _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8 _Stencil (&quot;Stencil ID&quot;, Float) = 0 _StencilOp (&quot;Stencil Operation&quot;, Float) = 0 _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255 _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255 _ColorMask (&quot;Color Mask&quot;, Float) = 15 [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0 _Center(&quot;Center&quot;,vector) = (0,0,0,0) _Slider(&quot;Slider&quot;,Range(0,1500)) = 1500 } SubShader { Tags { &quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;PreviewType&quot;=&quot;Plane&quot; &quot;CanUseSpriteAtlas&quot;=&quot;True&quot; } Stencil { Ref [_Stencil] Comp [_StencilComp] Pass [_StencilOp] ReadMask [_StencilReadMask] WriteMask [_StencilWriteMask] } Cull Off Lighting Off ZWrite Off ZTest [unity_GUIZTestMode] Blend SrcAlpha OneMinusSrcAlpha ColorMask [_ColorMask] Pass { Name &quot;Default&quot; CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma target 2.0 #include &quot;UnityCG.cginc&quot; #include &quot;UnityUI.cginc&quot; #pragma multi_compile __ UNITY_UI_CLIP_RECT #pragma multi_compile __ UNITY_UI_ALPHACLIP struct appdata_t { float4 vertex : POSITION; float4 color : COLOR; float2 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct v2f { float4 vertex : SV_POSITION; fixed4 color : COLOR; float2 texcoord : TEXCOORD0; float4 worldPosition : TEXCOORD1; UNITY_VERTEX_OUTPUT_STEREO }; fixed4 _Color; fixed4 _TextureSampleAdd; float4 _ClipRect; float2 _Center; float _Slider; v2f vert(appdata_t v) { v2f OUT; UNITY_SETUP_INSTANCE_ID(v); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT); OUT.worldPosition = v.vertex; OUT.vertex = UnityObjectToClipPos(OUT.worldPosition); OUT.texcoord = v.texcoord; OUT.color = v.color * _Color; return OUT; } sampler2D _MainTex; fixed4 frag(v2f IN) : SV_Target { half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color; #ifdef UNITY_UI_CLIP_RECT color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect); #endif #ifdef UNITY_UI_ALPHACLIP clip (color.a - 0.001); #endif color.a *= (distance(IN.worldPosition.xy, _Center.xy) &gt; _Slider); color.rgb *= color.a; return color; } ENDCG } } }2、矩形遮罩 // Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt) Shader &quot;UI/BeginnerGuidance/Rect&quot; { Properties { [PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; {} _Color (&quot;Tint&quot;, Color) = (1,1,1,1) _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8 _Stencil (&quot;Stencil ID&quot;, Float) = 0 _StencilOp (&quot;Stencil Operation&quot;, Float) = 0 _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255 _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255 _ColorMask (&quot;Color Mask&quot;, Float) = 15 [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0 _Center(&quot;Center&quot;,vector) = (0,0,0,0) _SliderX(&quot;SliderX&quot;,Range(0,1500)) = 1500 _SliderY(&quot;SliderY&quot;,Range(0,1500)) = 1500 } SubShader { Tags { &quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;PreviewType&quot;=&quot;Plane&quot; &quot;CanUseSpriteAtlas&quot;=&quot;True&quot; } Stencil { Ref [_Stencil] Comp [_StencilComp] Pass [_StencilOp] ReadMask [_StencilReadMask] WriteMask [_StencilWriteMask] } Cull Off Lighting Off ZWrite Off ZTest [unity_GUIZTestMode] Blend SrcAlpha OneMinusSrcAlpha ColorMask [_ColorMask] Pass { Name &quot;Default&quot; CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma target 2.0 #include &quot;UnityCG.cginc&quot; #include &quot;UnityUI.cginc&quot; #pragma multi_compile __ UNITY_UI_CLIP_RECT #pragma multi_compile __ UNITY_UI_ALPHACLIP struct appdata_t { float4 vertex : POSITION; float4 color : COLOR; float2 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct v2f { float4 vertex : SV_POSITION; fixed4 color : COLOR; float2 texcoord : TEXCOORD0; float4 worldPosition : TEXCOORD1; UNITY_VERTEX_OUTPUT_STEREO }; fixed4 _Color; fixed4 _TextureSampleAdd; float4 _ClipRect; float2 _Center; float _SliderX; float _SliderY; v2f vert(appdata_t v) { v2f OUT; UNITY_SETUP_INSTANCE_ID(v); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT); OUT.worldPosition = v.vertex; OUT.vertex = UnityObjectToClipPos(OUT.worldPosition); OUT.texcoord = v.texcoord; OUT.color = v.color * _Color; return OUT; } sampler2D _MainTex; fixed4 frag(v2f IN) : SV_Target { half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color; #ifdef UNITY_UI_CLIP_RECT color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect); #endif #ifdef UNITY_UI_ALPHACLIP clip (color.a - 0.001); #endif float2 dis = IN.worldPosition.xy - _Center.xy; color.a *= (abs(dis.x) &gt; _SliderX) || (abs(dis.y) &gt; _SliderY); color.rgb *= color.a; return color; } ENDCG } } }持续更新中……]]></content>
      <categories>
        <category>Unity</category>
        <category>游戏功能模块</category>
      </categories>
      <tags>
        <tag>新手引导</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之十二：预制体层级全预览]]></title>
    <url>%2F2018%2F06%2F24%2Funity-bian-ji-qi-tuo-zhan-zhi-shi-er-yu-zhi-ti-ceng-ji-quan-yu-lan%2F</url>
    <content type="text"><![CDATA[预制体层级全预览目的Asset面板下预制体并不会显示全，制作一个工具显示预制体的全部层级，这算是TreeView的一个应用 ![这里写图片描述](https://img-blog.csdn.net/2018062422144114?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) Code代码中用了 Unity编辑器拓展之十一：通过Image Name反查Prefab 中的一个类PrefabTreeView using System.Collections; using System.Collections.Generic; using UnityEditor.IMGUI.Controls; using UnityEngine; public class GameObjectTreeViewItem { public TreeViewItem viewItem; public Transform treeViewTrans; public Transform parent; public List&lt;Transform&gt; childs = new List&lt;Transform&gt; (); public bool IsChild (Transform tran) { if (null == tran) return false; if (tran.parent == treeViewTrans) return true; return false; } public void AddChildTransform (Transform childTransform) { if (null != childTransform) childs.Add (childTransform); } public bool HasChildTransform (Transform tran) { if (null == tran) return false; return childs.Contains (tran); } } public class PrefabTreeView : TreeView { private Transform[] childs; private GameObjectTreeViewItem[] items; public PrefabTreeView (TreeViewState state, GameObject go) : base (state) { treeGameObject = go; childs = treeGameObject.GetComponentsInChildren&lt;Transform&gt; (true); items = new GameObjectTreeViewItem[childs.Length]; #region Init Items Parent for (int i = 0; i &lt; childs.Length; i++) { items[i] = new GameObjectTreeViewItem (); items[i].treeViewTrans = childs[i]; if (childs[i].parent != null) items[i].parent = childs[i].parent; } #endregion #region Init Child Transform for (int i = 0; i &lt; childs.Length; i++) { for (int j = 0; j &lt; items.Length; j++) { if (items[j].IsChild (childs[i])) { items[j].AddChildTransform (childs[i]); break; } } } #endregion Reload (); } private GameObject treeGameObject; private GameObjectTreeViewItem GetGameObjectTreeViewItem (GameObjectTreeViewItem[] items, Transform trans) { if (null == items || items.Length == 0 || trans == null) return null; for (int i = 0; i &lt; items.Length; i++) { if (items[i] != null &amp;&amp; items[i].treeViewTrans == trans) return items[i]; } return null; } private GameObjectTreeViewItem GetGameObjectTreeViewItem (GameObjectTreeViewItem[] items, TreeViewItem viewItem) { if (null == items || items.Length == 0 || viewItem == null) return null; for (int i = 0; i &lt; items.Length; i++) { if (null != items &amp;&amp; items[i].viewItem == viewItem) return items[i]; } return null; } protected override TreeViewItem BuildRoot () { TreeViewItem root = new TreeViewItem { id = 0, depth = -1, displayName = &quot;root&quot; }; TreeViewItem[] childItems = new TreeViewItem[childs.Length]; for (int i = 0; i &lt; childs.Length; i++) { childItems[i] = new TreeViewItem { id = i + 1, displayName = childs[i].name }; GameObjectTreeViewItem item = GetGameObjectTreeViewItem (items, childs[i]); if (null != item) { item.viewItem = childItems[i]; } } root.AddChild (childItems[0]); for (int i = 0; i &lt; childItems.Length; i++) { GameObjectTreeViewItem temp = GetGameObjectTreeViewItem (items, childItems[i]); if (temp != null &amp;&amp; temp.childs != null) { for (int j = 0; j &lt; temp.childs.Count; j++) { GameObjectTreeViewItem childItem = GetGameObjectTreeViewItem (items, temp.childs[j]); if (childItem != null &amp;&amp; childItem.viewItem != null) { childItems[i].AddChild (childItem.viewItem); } } } } SetupDepthsFromParentsAndChildren (root); return root; } } using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEditor.IMGUI.Controls; using UnityEngine; public class PrefabViewWindow : EditorWindow { private GameObject selectPrefab = null; [SerializeField] TreeViewState treeViewState; PrefabTreeView prefabTreeView; void OnEnable () { if (null == treeViewState) treeViewState = new TreeViewState (); } [MenuItem (&quot;PrefabView/PrefabViewWindow&quot;)] private static void ShowWindow () { GetWindow&lt;PrefabViewWindow&gt; ().Show (); } private void OnGUI () { if (null != selectPrefab) { Rect rect = GUILayoutUtility.GetRect (0, 100000, 0, 100000); prefabTreeView = new PrefabTreeView (treeViewState, selectPrefab); prefabTreeView.OnGUI (rect); prefabTreeView.ExpandAll (); } else { } } void OnSelectionChange () { selectPrefab = Selection.activeObject as GameObject; Repaint(); } }Code下载 https://github.com/JingFengJi/PrefabViewWindow 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>预制体层级全预览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之十一：通过Image Name反查Prefab]]></title>
    <url>%2F2018%2F06%2F24%2Funity-bian-ji-qi-tuo-zhan-zhi-shi-yi-tong-guo-image-name-fan-cha-prefab%2F</url>
    <content type="text"><![CDATA[通过Image Name快速反查Prefab开发思路1、获取到工程中所有Prefab2、获取Prefab的所有Image和RawImage3、检测Prefab下是否存在指定名称的Image 编辑器示意图![这里写图片描述](https://img-blog.csdn.net/2018062421264348?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 编辑器包括三个部分：1、搜索框2、预制体列表3、预制体层级 Codeusing System.Collections; using System.Collections.Generic; using System.IO; using UnityEditor; using UnityEditor.IMGUI.Controls; using UnityEngine; using UnityEngine.UI; public class FindPrefabByImage : EditorWindow { private static string assetPath; private static List&lt;string&gt; prefabPaths = new List&lt;string&gt; (); private bool initialized = false; private SearchField searchField; private string searchStr; Rect toolbarRect { get { return new Rect (20f, 10f, position.width - 40f, 20f); } } Rect searchResultViewRect { get { return new Rect (20f, 40f, (position.width - 40) / 2, position.height - 40f); } } Rect selectPrefabHierarchyViewRect { get { return new Rect (position.width / 2, 40, (position.width - 40) / 2, position.height - 40f); } } Vector2 searchResultScrollViewPos = Vector2.zero; [SerializeField] TreeViewState treeViewState; PrefabTreeView prefabTreeView; private GameObject curSelectPrefab; void OnEnable () { if (null == treeViewState) treeViewState = new TreeViewState (); } [MenuItem (&quot;CommonTools/图片反查预制体引用工具&quot;)] public static FindPrefabByImage GetWindow () { prefabPaths.Clear (); assetPath = Application.dataPath; GetFiles (new DirectoryInfo (assetPath), &quot;*.prefab&quot;, ref prefabPaths); var window = GetWindow&lt;FindPrefabByImage&gt; (); window.titleContent = new GUIContent (&quot;FindPrefab&quot;); window.Focus (); window.Repaint (); return window; } public static void GetFiles (DirectoryInfo directory, string pattern, ref List&lt;string&gt; fileList) { if (directory != null &amp;&amp; directory.Exists &amp;&amp; !string.IsNullOrEmpty (pattern)) { try { foreach (FileInfo info in directory.GetFiles (pattern)) { string path = info.FullName.ToString (); fileList.Add (path.Substring (path.IndexOf (&quot;Assets&quot;))); } } catch (System.Exception) { throw; } foreach (DirectoryInfo info in directory.GetDirectories ()) { GetFiles (info, pattern, ref fileList); } } } /// &lt;summary&gt; /// 检测预制体是否包含Image组件 /// &lt;/summary&gt; /// &lt;param name=&quot;prefab&quot;&gt;检测的预制体&lt;/param&gt; /// &lt;param name=&quot;imageName&quot;&gt;Image名称，可为空&lt;/param&gt; /// &lt;returns&gt;如果Image名称为空且预制体包含Image组件，或者Image不为空预制体包含该指定Image，则返回true，否则返回false&lt;/returns&gt; public static bool CheckPrefabHasImage (GameObject prefab, string imageName = null) { if (!string.IsNullOrEmpty (imageName)) imageName = imageName.ToLower (); if (null == prefab) return false; Image[] images = prefab.GetComponentsInChildren&lt;Image&gt; (true); if (null != images &amp;&amp; images.Length &gt; 0) { if (string.IsNullOrEmpty (imageName)) { return true; } else { for (int i = 0; i &lt; images.Length; i++) { if (null != images[i] &amp;&amp; images[i].sprite != null &amp;&amp; images[i].sprite.name.ToLower() == imageName) { return true; } } } } RawImage[] rawImages = prefab.GetComponentsInChildren&lt;RawImage&gt; (true); if (null != rawImages &amp;&amp; rawImages.Length &gt; 0) { if (string.IsNullOrEmpty (imageName)) { return true; } else { for (int i = 0; i &lt; rawImages.Length; i++) { if (null != rawImages[i] &amp;&amp; null != rawImages[i].texture &amp;&amp; rawImages[i].texture.name.ToLower() == imageName) { return true; } } } } return false; } private void InitIfNeeded () { if (!initialized) { if (null == searchField) searchField = new SearchField (); initialized = true; } } void OnGUI () { InitIfNeeded (); DoSearchField (); DoSearchResultView (); DoSelectPrefabHierarchyVieww (); } private void DoSearchField () { searchStr = searchField.OnGUI (toolbarRect, searchStr); } private void DoSearchResultView () { GUILayout.BeginArea (searchResultViewRect); searchResultScrollViewPos = GUILayout.BeginScrollView (searchResultScrollViewPos); for (int i = 0; i &lt; prefabPaths.Count; i++) { GameObject gameObj = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt; (@prefabPaths[i]); if (gameObj != null) { bool result = CheckPrefabHasImage (gameObj,searchStr); if (result) { if (GUILayout.Button (prefabPaths[i])) { curSelectPrefab = gameObj; } } } } GUILayout.EndScrollView (); GUILayout.EndArea (); } private void DoSelectPrefabHierarchyVieww () { GUILayout.BeginArea (selectPrefabHierarchyViewRect); if (null != curSelectPrefab) { Rect rect = GUILayoutUtility.GetRect (0, 100000, 0, 100000); prefabTreeView = new PrefabTreeView (treeViewState, curSelectPrefab); prefabTreeView.OnGUI (rect); prefabTreeView.ExpandAll (); } else { } GUILayout.EndArea (); } } using System.Collections; using System.Collections.Generic; using UnityEditor.IMGUI.Controls; using UnityEngine; public class GameObjectTreeViewItem { public TreeViewItem viewItem; public Transform treeViewTrans; public Transform parent; public List&lt;Transform&gt; childs = new List&lt;Transform&gt; (); public bool IsChild (Transform tran) { if (null == tran) return false; if (tran.parent == treeViewTrans) return true; return false; } public void AddChildTransform (Transform childTransform) { if (null != childTransform) childs.Add (childTransform); } public bool HasChildTransform (Transform tran) { if (null == tran) return false; return childs.Contains (tran); } } public class PrefabTreeView : TreeView { private Transform[] childs; private GameObjectTreeViewItem[] items; public PrefabTreeView (TreeViewState state, GameObject go) : base (state) { treeGameObject = go; childs = treeGameObject.GetComponentsInChildren&lt;Transform&gt; (true); items = new GameObjectTreeViewItem[childs.Length]; #region Init Items Parent for (int i = 0; i &lt; childs.Length; i++) { items[i] = new GameObjectTreeViewItem (); items[i].treeViewTrans = childs[i]; if (childs[i].parent != null) items[i].parent = childs[i].parent; } #endregion #region Init Child Transform for (int i = 0; i &lt; childs.Length; i++) { for (int j = 0; j &lt; items.Length; j++) { if (items[j].IsChild (childs[i])) { items[j].AddChildTransform (childs[i]); break; } } } #endregion Reload (); } private GameObject treeGameObject; private GameObjectTreeViewItem GetGameObjectTreeViewItem (GameObjectTreeViewItem[] items, Transform trans) { if (null == items || items.Length == 0 || trans == null) return null; for (int i = 0; i &lt; items.Length; i++) { if (items[i] != null &amp;&amp; items[i].treeViewTrans == trans) return items[i]; } return null; } private GameObjectTreeViewItem GetGameObjectTreeViewItem (GameObjectTreeViewItem[] items, TreeViewItem viewItem) { if (null == items || items.Length == 0 || viewItem == null) return null; for (int i = 0; i &lt; items.Length; i++) { if (null != items &amp;&amp; items[i].viewItem == viewItem) return items[i]; } return null; } protected override TreeViewItem BuildRoot () { TreeViewItem root = new TreeViewItem { id = 0, depth = -1, displayName = &quot;root&quot; }; TreeViewItem[] childItems = new TreeViewItem[childs.Length]; for (int i = 0; i &lt; childs.Length; i++) { childItems[i] = new TreeViewItem { id = i + 1, displayName = childs[i].name }; GameObjectTreeViewItem item = GetGameObjectTreeViewItem (items, childs[i]); if (null != item) { item.viewItem = childItems[i]; } } root.AddChild (childItems[0]); for (int i = 0; i &lt; childItems.Length; i++) { GameObjectTreeViewItem temp = GetGameObjectTreeViewItem (items, childItems[i]); if (temp != null &amp;&amp; temp.childs != null) { for (int j = 0; j &lt; temp.childs.Count; j++) { GameObjectTreeViewItem childItem = GetGameObjectTreeViewItem (items, temp.childs[j]); if (childItem != null &amp;&amp; childItem.viewItem != null) { childItems[i].AddChild (childItem.viewItem); } } } } SetupDepthsFromParentsAndChildren (root); return root; } }代码中用到了TreeView的知识，请自行补充，后续会更新关系TreeView的知识点 Code下载 https://github.com/JingFengJi/FindPrefabByImage 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之十：UI对齐工具]]></title>
    <url>%2F2018%2F06%2F22%2Funity-bian-ji-qi-tuo-zhan-zhi-shi-ui-dui-qi-gong-ju%2F</url>
    <content type="text"><![CDATA[示例图![这里写图片描述](https://img-blog.csdn.net/20180622214023588?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) ![这里写图片描述](https://img-blog.csdn.net/20180622214216448?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 开发思路1、获取选中的UI2、根据对齐规则修改所选中UI的坐标 代码UGUIAlign.csusing System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; public enum AlignType { Top = 1, Left = 2, Right = 3, Bottom = 4, HorizontalCenter = 5, //水平居中 VerticalCenter = 6, //垂直居中 Horizontal = 7, //横向分布 Vertical = 8, //纵向分布 } public class UGUIAlign : Editor { [MenuItem(&quot;GameObject/UI/Align/Left 【左对齐】&quot;)] static void AlignLeft() { Align(AlignType.Left); } [MenuItem(&quot;GameObject/UI/Align/HorizontalCenter 【水平居中】&quot;)] static void AlignHorizontalCenter() { Align(AlignType.HorizontalCenter); } [MenuItem(&quot;GameObject/UI/Align/Right 【右对齐】&quot;)] static void AlignRight() { Align(AlignType.Right); } [MenuItem(&quot;GameObject/UI/Align/Top 【顶端对齐】&quot;)] static void AlignTop() { Align(AlignType.Top); } [MenuItem(&quot;GameObject/UI/Align/VerticalCenter 【垂直居中】&quot;)] static void AlignVerticalCenter() { Align(AlignType.VerticalCenter); } [MenuItem(&quot;GameObject/UI/Align/Bottom 【底端对齐】&quot;)] static void AlignBottom() { Align(AlignType.Bottom); } [MenuItem(&quot;GameObject/UI/Align/Horizontal 【横向分布】&quot;)] static void AlignHorizontal() { Align(AlignType.Horizontal); } [MenuItem(&quot;GameObject/UI/Align/Vertical 【纵向分布】&quot;)] static void AlignVertical() { Align(AlignType.Vertical); } public static void Align(AlignType type) { List&lt;RectTransform&gt; rects = new List&lt;RectTransform&gt;(); GameObject[] objects = Selection.gameObjects; if (objects != null &amp;&amp; objects.Length &gt; 0) { for (int i = 0; i &lt; objects.Length; i++) { RectTransform rect = objects[i].GetComponent&lt;RectTransform&gt;(); if (rect != null) rects.Add(rect); } } if (rects.Count &gt; 1) { Align(type, rects); } } public static void Align(AlignType type, List&lt;RectTransform&gt; rects) { RectTransform tenplate = rects[0]; float w = tenplate.sizeDelta.x * tenplate.lossyScale.x; float h = tenplate.sizeDelta.y * tenplate.localScale.y; float x = tenplate.position.x - tenplate.pivot.x * w; float y = tenplate.position.y - tenplate.pivot.y * h; switch (type) { case AlignType.Top: for (int i = 1; i &lt; rects.Count; i++) { RectTransform trans = rects[i]; float th = trans.sizeDelta.y * trans.localScale.y; Vector3 pos = trans.position; pos.y = y + h - th + trans.pivot.y * th; trans.position = pos; } break; case AlignType.Left: for (int i = 1; i &lt; rects.Count; i++) { RectTransform trans = rects[i]; float tw = trans.sizeDelta.x * trans.lossyScale.x; Vector3 pos = trans.position; pos.x = x + tw * trans.pivot.x; trans.position = pos; } break; case AlignType.Right: for (int i = 1; i &lt; rects.Count; i++) { RectTransform trans = rects[i]; float tw = trans.sizeDelta.x * trans.lossyScale.x; Vector3 pos = trans.position; pos.x = x + w - tw + tw * trans.pivot.x; trans.position = pos; } break; case AlignType.Bottom: for (int i = 1; i &lt; rects.Count; i++) { RectTransform trans = rects[i]; float th = trans.sizeDelta.y * trans.localScale.y; Vector3 pos = trans.position; pos.y = y + th * trans.pivot.y; trans.position = pos; } break; case AlignType.HorizontalCenter: for (int i = 1; i &lt; rects.Count; i++) { RectTransform trans = rects[i]; float tw = trans.sizeDelta.x * trans.lossyScale.x; Vector3 pos = trans.position; pos.x = x + 0.5f * w - 0.5f * tw + tw * trans.pivot.x; trans.position = pos; } break; case AlignType.VerticalCenter: for (int i = 1; i &lt; rects.Count; i++) { RectTransform trans = rects[i]; float th = trans.sizeDelta.y * trans.localScale.y; Vector3 pos = trans.position; pos.y = y + 0.5f * h - 0.5f * th + th * trans.pivot.y; trans.position = pos; } break; case AlignType.Horizontal: float minX = GetMinX(rects); float maxX = GetMaxX(rects); rects.Sort(SortListRectTransformByX); float distance = (maxX - minX)/(rects.Count - 1); for (int i = 1; i &lt; rects.Count - 1; i++) { RectTransform trans = rects[i]; Vector3 pos = trans.position; pos.x = minX + i * distance; trans.position = pos; } break; case AlignType.Vertical: float minY = GetMinY(rects); float maxY = GetMaxY(rects); rects.Sort(SortListRectTransformByY); float distanceY = (maxY - minY)/(rects.Count - 1); for (int i = 1; i &lt; rects.Count - 1; i++) { RectTransform trans = rects[i]; Vector3 pos = trans.position; pos.y = minY + i*distanceY; trans.position = pos; } break; } } private static int SortListRectTransformByX(RectTransform r1, RectTransform r2) { float w = r1.sizeDelta.x * r1.lossyScale.x; float x1 = r1.position.x - r1.pivot.x * w; w = r2.sizeDelta.x * r2.lossyScale.x; float x2 = r2.position.x - r2.pivot.x * w; if (x1 &gt;= x2) return 1; else return -1; } private static int SortListRectTransformByY(RectTransform r1, RectTransform r2) { float w = r1.sizeDelta.y * r1.lossyScale.y; float y1 = r1.position.y - r1.pivot.y * w; w = r2.sizeDelta.y * r2.lossyScale.y; float y2 = r2.position.y - r2.pivot.y * w; if (y1 &gt;= y2) return 1; else return -1; } private static float GetMinX(List&lt;RectTransform&gt; rects) { if (null == rects || rects.Count == 0) return 0; RectTransform tenplate = rects[0]; float minx = tenplate.position.x; float tempX = 0; for (int i = 1; i &lt; rects.Count; i++) { tempX = rects[i].position.x; if (tempX &lt; minx) minx = tempX; } return minx; } private static float GetMaxX(List&lt;RectTransform&gt; rects) { if (null == rects || rects.Count == 0) return 0; RectTransform tenplate = rects[0]; float maxX = tenplate.position.x; float tempX = 0; for (int i = 1; i &lt; rects.Count; i++) { tempX = rects[i].position.x; if (tempX &gt; maxX) maxX = tempX; } return maxX; } private static float GetMinY(List&lt;RectTransform&gt; rects) { if (null == rects || rects.Count == 0) return 0; RectTransform tenplate = rects[0]; float minY = tenplate.position.y; float tempX = 0; for (int i = 1; i &lt; rects.Count; i++) { tempX = rects[i].position.y; if (tempX &lt; minY) minY = tempX; } return minY; } private static float GetMaxY(List&lt;RectTransform&gt; rects) { if (null == rects || rects.Count == 0) return 0; RectTransform tenplate = rects[0]; float maxY = tenplate.position.y; float tempX = 0; for (int i = 1; i &lt; rects.Count; i++) { tempX = rects[i].position.y; if (tempX &gt; maxY) maxY = tempX; } return maxY; } }UGUIAlignWindow.cs为了操作更加便捷，提供一个EditorWindow类 using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; public class UGUIAlignWindow : EditorWindow { private Dictionary&lt;AlignType,Texture&gt; alignTexture = new Dictionary&lt;AlignType, Texture&gt;(); void OnEnable() { Texture leftTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/Left&quot;); Texture horizontalCenterTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/HorizontalCenter&quot;); Texture rightTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/Right&quot;); Texture topTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/Top&quot;); Texture verticalCenterTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/VerticalCenter&quot;); Texture bottomTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/Bottom&quot;); Texture horizontalTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/Horizontal&quot;); Texture verticalTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/Vertical&quot;); alignTexture.Add(AlignType.Left, leftTexture); alignTexture.Add(AlignType.HorizontalCenter, horizontalCenterTexture); alignTexture.Add(AlignType.Right, rightTexture); alignTexture.Add(AlignType.Top, topTexture); alignTexture.Add(AlignType.VerticalCenter, verticalCenterTexture); alignTexture.Add(AlignType.Bottom, bottomTexture); alignTexture.Add(AlignType.Horizontal, horizontalTexture); alignTexture.Add(AlignType.Vertical, verticalTexture); } [MenuItem(&quot;UGUIAlign/Align&quot;)] public static UGUIAlignWindow GetWindow() { var window = GetWindow&lt;UGUIAlignWindow&gt;(); window.titleContent = new GUIContent(&quot;UGUI Align&quot;); window.Focus(); window.Repaint(); return window; } void OnGUI() { GUILayout.BeginHorizontal(); GUILayout.BeginVertical(); for (int i = (int)AlignType.Top; i &lt;= (int)AlignType.Vertical; i++) { if (GUILayout.Button(alignTexture[(AlignType)i], &quot;LargeButton&quot;)) { UGUIAlign.Align((AlignType)i); } if (i%3 == 0) { GUILayout.EndVertical(); GUILayout.BeginVertical(); } } GUILayout.EndVertical(); GUILayout.EndHorizontal(); } }对齐图片资源![这里写图片描述](https://img-blog.csdn.net/2018062221455923?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) Code下载 https://github.com/JingFengJi/UGUIAlign 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>UI对齐工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之九：SearchField]]></title>
    <url>%2F2018%2F05%2F13%2Funity-bian-ji-qi-tuo-zhan-zhi-jiu-searchfield%2F</url>
    <content type="text"><![CDATA[Unity官方介绍文档： https://docs.unity3d.com/ScriptReference/IMGUI.Controls.SearchField.html Properties1、autoSetFocusOnFindCommand：当用户按下“Ctrl/Cmd + F”时，聚焦该控件，默认值为true相关代码： private bool m_AutoSetFocusOnFindCommand = true; public bool autoSetFocusOnFindCommand { get { return this.m_AutoSetFocusOnFindCommand; } set { this.m_AutoSetFocusOnFindCommand = value; } } private void CommandEventHandling() { Event current = Event.current; if (current.type == EventType.ExecuteCommand || current.type == EventType.ValidateCommand) { //UnityEngine内部应该建立了commandName与按键的对应关系 //https://docs.unity3d.com/ScriptReference/Event-commandName.html if (this.m_AutoSetFocusOnFindCommand &amp;&amp; current.commandName == &quot;Find&quot;) { if (current.type == EventType.ExecuteCommand) { this.SetFocus(); } current.Use(); } } }2、searchFieldControlID控件的ControllID，就不多介绍了，构造函数里会为它赋值。 公有函数：构造函数： public SearchField() { this.m_ControlID = GUIUtility.GetPermanentControlID(); }HasFocus： public bool HasFocus() { return GUIUtility.keyboardControl == this.m_ControlID; }SetFocus： public void SetFocus() { this.m_WantsFocus = true; }OnGUI提供了三个重载： public string OnGUI(string text, params GUILayoutOption[] options); public string OnGUI(Rect rect, string text); public string OnGUI(Rect rect, string text, GUIStyle style, GUIStyle cancelButtonStyle, GUIStyle emptyCancelButtonStyle); public string OnGUI(Rect rect, string text, GUIStyle style, GUIStyle cancelButtonStyle, GUIStyle emptyCancelButtonStyle) { this.CommandEventHandling(); this.FocusAndKeyHandling(); float fixedWidth = cancelButtonStyle.fixedWidth; Rect position = rect; position.width -= fixedWidth; text = EditorGUI.TextFieldInternal(this.m_ControlID, position, text, style); Rect position2 = rect; position2.x += rect.width - fixedWidth; position2.width = fixedWidth; //搜索框的 X 按钮 if (GUI.Button(position2, GUIContent.none, (!(text != &quot;&quot;)) ? emptyCancelButtonStyle : cancelButtonStyle) &amp;&amp; text != &quot;&quot;) { //搜索文字 置为 Empty，并取消其聚焦 text = &quot;&quot;; GUIUtility.keyboardControl = 0; } return text; } public string OnGUI(Rect rect, string text) { //EditorStyles.searchField = 搜索框样式 //EditorStyles.searchFieldCancelButton= 搜索框取消按钮样式 //EditorStyles.searchFieldCancelButtonEmpty = 搜索框 搜索关键字为空时的 样式 return this.OnGUI(rect, text, EditorStyles.searchField, EditorStyles.searchFieldCancelButton, EditorStyles.searchFieldCancelButtonEmpty); } public string OnGUI(string text, params GUILayoutOption[] options) { Rect rect = GUILayoutUtility.GetRect(36f, 1E+07f, 16f, 16f, EditorStyles.searchField, options); return this.OnGUI(rect, text); }私有函数：FocusAndKeyHandling： private void FocusAndKeyHandling() { Event current = Event.current; //SetFocus公有接口将私有变量m_WantsFocus置为true，将controlID赋值给GUIUtility.keyboardControl以此实现Focus if (this.m_WantsFocus &amp;&amp; current.type == EventType.Repaint) { GUIUtility.keyboardControl = this.m_ControlID; EditorGUIUtility.editingTextField = true; this.m_WantsFocus = false; } if (current.type == EventType.KeyDown &amp;&amp; (current.keyCode == KeyCode.DownArrow || current.keyCode == KeyCode.UpArrow) &amp;&amp; GUIUtility.keyboardControl == this.m_ControlID &amp;&amp; GUIUtility.hotControl == 0) { if (this.downOrUpArrowKeyPressed != null) { this.downOrUpArrowKeyPressed(); current.Use(); } } }Event：downOrUpArrowKeyPressed：搜索字段时检测到向上或者向下键被按下时，可以用来改变键盘焦点到另一个控件，例如TreeView，如下图 ![这里写图片描述](https://img-blog.csdn.net/20180513181705295?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) public event SearchField.SearchFieldCallback downOrUpArrowKeyPressed { add { SearchField.SearchFieldCallback searchFieldCallback = this.downOrUpArrowKeyPressed; SearchField.SearchFieldCallback searchFieldCallback2; do { searchFieldCallback2 = searchFieldCallback; searchFieldCallback = Interlocked.CompareExchange&lt;SearchField.SearchFieldCallback&gt;(ref this.downOrUpArrowKeyPressed, (SearchField.SearchFieldCallback)Delegate.Combine(searchFieldCallback2, value), searchFieldCallback); } while (searchFieldCallback != searchFieldCallback2); } remove { SearchField.SearchFieldCallback searchFieldCallback = this.downOrUpArrowKeyPressed; SearchField.SearchFieldCallback searchFieldCallback2; do { searchFieldCallback2 = searchFieldCallback; searchFieldCallback = Interlocked.CompareExchange&lt;SearchField.SearchFieldCallback&gt;(ref this.downOrUpArrowKeyPressed, (SearchField.SearchFieldCallback)Delegate.Remove(searchFieldCallback2, value), searchFieldCallback); } while (searchFieldCallback != searchFieldCallback2); } }以上代码为使用ILSpy工具反编译得来，仅供学习使用。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>SearchField</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之七：如何在PreferencesWindow中新增条目]]></title>
    <url>%2F2018%2F04%2F06%2Funity-bian-ji-qi-tuo-zhan-zhi-qi-ru-he-zai-preferenceswindow-zhong-xin-zeng-tiao-mu%2F</url>
    <content type="text"><![CDATA[本文介绍如何在PreferencesWindow中新增条目在 Unity编辑器拓展之六 中，有介绍到部分PreferencesWindow.cs的代码，而本文从源码开始给大家介绍。 PreferencesWindow.cs中： private void AddCustomSections() { Assembly[] loadedAssemblies = EditorAssemblies.loadedAssemblies; for (int i = 0; i &lt; loadedAssemblies.Length; i++) { Assembly assembly = loadedAssemblies[i]; Type[] typesFromAssembly = AssemblyHelper.GetTypesFromAssembly(assembly); Type[] array = typesFromAssembly; for (int j = 0; j &lt; array.Length; j++) { Type type = array[j]; MethodInfo[] methods = type.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic); for (int k = 0; k &lt; methods.Length; k++) { MethodInfo methodInfo = methods[k]; //关键在这一行 PreferenceItem preferenceItem = Attribute.GetCustomAttribute(methodInfo, typeof(PreferenceItem)) as PreferenceItem; if (preferenceItem != null) { PreferencesWindow.OnGUIDelegate onGUIDelegate = Delegate.CreateDelegate(typeof(PreferencesWindow.OnGUIDelegate), methodInfo) as PreferencesWindow.OnGUIDelegate; if (onGUIDelegate != null) { this.m_Sections.Add(new PreferencesWindow.Section(preferenceItem.name, onGUIDelegate)); } } } } } }代码片中标注的那一行，MSDN中的介绍是：“检索应用于程序集、 模块、 类型成员或方法参数的指定类型的自定义属性。” [ MSDN中关于该接口的介绍 ](https://msdn.microsoft.com/zh-cn/library/system.attribute.getcustomattribute%28v=vs.110%29.aspx) 那么，上述代码中检索了程序中使用 PreferenceItem的所有method，随后将带有PreferenceItem的methodInfo实例化成一个委托，进而构造一个Section对象，添加到m_Setions集合中。 接着，看Unity 文档，关于 PreferenceItem 的介绍。 https://docs.unity3d.com/2017.2/Documentation/ScriptReference/PreferenceItem.html PreferenceItem属性允许您添加首选项到preferences窗口。 解释跟源码分析的一样，接下来进行代码测试。 [PreferenceItem(&quot;Preference Item&quot;)] private static void SelfPreferenceItem() { EditorGUILayout.LabelField(&quot;Self Preference Item&quot;, EditorStyles.boldLabel); if (GUILayout.Button(&quot;Button&quot;)) { Debug.LogError(&quot;Click&quot;); } EditorGUILayout.Space(); }![这里写图片描述](https://img-blog.csdn.net/20180406153027300?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 但是，发现有点不对劲，编辑器拓展之六中提到的选中左侧，出现问题了。没有自动选中新增的那一项。 然后通过断点，查看到反射出来的m_Sections集合里，并没有新增的那一项，使得在遍历的时候，没法自动选中它。 也就是说，AddCustomSections函数在此时并没有执行到，使得新增的 “Preference Item”并没有被添加到m_Sections这个集合里。 查看一下源码中是合适调用的 AddCustomSections函数， private void OnGUI() { if (this.m_RefreshCustomPreferences) { this.AddCustomSections(); this.m_RefreshCustomPreferences = false; } //节省篇幅，后面代码省略 }也就是当m_RefreshCustomPreferences值为true时，执行一遍AddCustomSections函数。 完善代码： using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using System.Reflection; using System; public class OpenPreferencesWindow : EditorWindow { [MenuItem(&quot;Tool/OpenPreferencesWindow&quot;)] public static void Open() { OpenPreferencesWindow editor = EditorWindow.GetWindow&lt;OpenPreferencesWindow&gt;(); } private void OnGUI() { if (GUILayout.Button(&quot;打开PerferencesWindow&quot;)) { Assembly assembly = Assembly.GetAssembly(typeof(UnityEditor.EditorWindow)); Type type = assembly.GetType(&quot;UnityEditor.PreferencesWindow&quot;); type.GetMethod(&quot;ShowPreferencesWindow&quot;, BindingFlags.NonPublic | BindingFlags.Static).Invoke(null, null); EditorWindow window = EditorWindow.GetWindow(type); //解决不能自动定位 新增条目 的问题 //手动调用一遍AddCustomSections函数 FieldInfo refreshField = type.GetField(&quot;m_RefreshCustomPreferences&quot;, BindingFlags.NonPublic | BindingFlags.Instance); if ((bool)refreshField.GetValue(window)) { type.GetMethod(&quot;AddCustomSections&quot;, BindingFlags.NonPublic | BindingFlags.Instance).Invoke(window, null); refreshField.SetValue(window, false); } FieldInfo sectionsField = type.GetField(&quot;m_Sections&quot;, BindingFlags.Instance | BindingFlags.NonPublic); IList sections = sectionsField.GetValue(window) as IList; Type sectionType = sectionsField.FieldType.GetGenericArguments()[0]; FieldInfo sectionContentField = sectionType.GetField(&quot;content&quot;, BindingFlags.Instance | BindingFlags.Public); for (int i = 0; i &lt; sections.Count; i++) { GUIContent sectionContent = sectionContentField.GetValue(sections[i]) as GUIContent; if (sectionContent.text == &quot;Preference Item&quot;) { FieldInfo sectionIndexField = type.GetField(&quot;m_SelectedSectionIndex&quot;, BindingFlags.Instance | BindingFlags.NonPublic); sectionIndexField.SetValue(window, i); return; } } } } [PreferenceItem(&quot;Preference Item&quot;)] private static void SelfPreferenceItem() { EditorGUILayout.LabelField(&quot;Self Preference Item&quot;, EditorStyles.boldLabel); if (GUILayout.Button(&quot;Button&quot;)) { Debug.LogError(&quot;Click&quot;); } EditorGUILayout.Space(); } }完美收工！ 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>PreferencesWindow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之六：利用反射打开Unity Preferences Window]]></title>
    <url>%2F2018%2F04%2F05%2Funity-bian-ji-qi-tuo-zhan-zhi-liu-li-yong-fan-she-da-kai-unity-preferences-window%2F</url>
    <content type="text"><![CDATA[如何利用反射打开Unity Preferences WindowUnity Preferences Window如下图所示： ![这里写图片描述](https://img-blog.csdn.net/2018040521134474?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 作为Unity 的参数设置窗口，这个窗口支持新增项，当然本文不介绍这个内容，本次介绍如何利用反射、以及UnityEditor代码来实现用代码打开Preferences Window以及设置选中项。 使用ILSpy工具反编译UnityEditor.dll后呢，在下图目录中的PreferencesWinndow.cs脚本 ![这里写图片描述](https://img-blog.csdn.net/2018040521190433?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 里面有一个接口是”ShowPreferencesWindow”，从字面上就可以理解到是用来打开PreferencesWindow的。 private static void ShowPreferencesWindow() { EditorWindow window = EditorWindow.GetWindow&lt;PreferencesWindow&gt;(true, &quot;Unity Preferences&quot;); window.minSize = new Vector2(500f, 400f); window.maxSize = new Vector2(window.minSize.x, window.maxSize.y); window.position = new Rect(new Vector2(100f, 100f), window.minSize); window.m_Parent.window.m_DontSaveToLayout = true; }该函数是私有的，没办法直接调，利用反射试一下。 using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using System.Reflection; using System; public class OpenPreferencesWindow : EditorWindow { [MenuItem(&quot;Tool/OpenPreferencesWindow&quot;)] public static void Open() { OpenPreferencesWindow editor = EditorWindow.GetWindow&lt;OpenPreferencesWindow&gt;(); } private void OnGUI() { if (GUILayout.Button(&quot;打开PerferencesWindow&quot;)) { Assembly assembly = Assembly.GetAssembly(typeof(UnityEditor.EditorWindow)); Type type = assembly.GetType(&quot;UnityEditor.PreferencesWindow&quot;); type.GetMethod(&quot;ShowPreferencesWindow&quot;, BindingFlags.NonPublic | BindingFlags.Static).Invoke(null, null); } } }效果图： ![这里写图片描述](https://img-blog.csdn.net/20180405213022507?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 接下来，就是如何实现在打开window之后直接选中某一项。 查看一下OnEnable函数，初始化里面做了啥？ private void OnEnable() { this.prefWinExtensions = ModuleManager.GetPreferenceWindowExtensions(); this.ReadPreferences(); this.m_Sections = new List&lt;PreferencesWindow.Section&gt;(); this.m_Sections.Add(new PreferencesWindow.Section(&quot;General&quot;, new PreferencesWindow.OnGUIDelegate(this.ShowGeneral))); this.m_Sections.Add(new PreferencesWindow.Section(&quot;External Tools&quot;, new PreferencesWindow.OnGUIDelegate(this.ShowExternalApplications))); this.m_Sections.Add(new PreferencesWindow.Section(&quot;Colors&quot;, new PreferencesWindow.OnGUIDelegate(this.ShowColors))); this.m_Sections.Add(new PreferencesWindow.Section(&quot;Keys&quot;, new PreferencesWindow.OnGUIDelegate(this.ShowKeys))); this.m_Sections.Add(new PreferencesWindow.Section(&quot;GI Cache&quot;, new PreferencesWindow.OnGUIDelegate(this.ShowGICache))); this.m_Sections.Add(new PreferencesWindow.Section(&quot;2D&quot;, new PreferencesWindow.OnGUIDelegate(this.Show2D))); if (Unsupported.IsDeveloperBuild() || UnityConnect.preferencesEnabled) { this.m_Sections.Add(new PreferencesWindow.Section(&quot;Unity Services&quot;, new PreferencesWindow.OnGUIDelegate(this.ShowUnityConnectPrefs))); } this.m_RefreshCustomPreferences = true; }与PreferencesWindow图对比之后发现，m_Sections这个集合里存的Section对象应该就是Window左侧的可选项了。 接着看看Section这个类 private class Section { public GUIContent content; public PreferencesWindow.OnGUIDelegate guiFunc; public Section(string name, PreferencesWindow.OnGUIDelegate guiFunc) { this.content = new GUIContent(name); this.guiFunc = guiFunc; } public Section(string name, Texture2D icon, PreferencesWindow.OnGUIDelegate guiFunc) { this.content = new GUIContent(name, icon); this.guiFunc = guiFunc; } public Section(GUIContent content, PreferencesWindow.OnGUIDelegate guiFunc) { this.content = content; this.guiFunc = guiFunc; } }PreferencesWindow在OnEnable的时候，就有实例化几个对象，其中传入的第一个参数，例如“Colors”,就存在类的content中，那么只需要反射到这个content的，再遍历这个m_Sections，就可以实现选中左侧了。 完整代码，如下： using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using System.Reflection; using System; public class OpenPreferencesWindow : EditorWindow { [MenuItem(&quot;Tool/OpenPreferencesWindow&quot;)] public static void Open() { OpenPreferencesWindow editor = EditorWindow.GetWindow&lt;OpenPreferencesWindow&gt;(); } private void OnGUI() { if (GUILayout.Button(&quot;打开PerferencesWindow&quot;)) { Assembly assembly = Assembly.GetAssembly(typeof(UnityEditor.EditorWindow)); Type type = assembly.GetType(&quot;UnityEditor.PreferencesWindow&quot;); type.GetMethod(&quot;ShowPreferencesWindow&quot;, BindingFlags.NonPublic | BindingFlags.Static).Invoke(null, null); EditorWindow window = EditorWindow.GetWindow(type); FieldInfo sectionsField = type.GetField(&quot;m_Sections&quot;, BindingFlags.Instance | BindingFlags.NonPublic); IList sections = sectionsField.GetValue(window) as IList; Type sectionType = sectionsField.FieldType.GetGenericArguments()[0]; FieldInfo sectionContentField = sectionType.GetField(&quot;content&quot;, BindingFlags.Instance | BindingFlags.Public); for (int i = 0; i &lt; sections.Count; i++) { GUIContent sectionContent = sectionContentField.GetValue(sections[i]) as GUIContent; if (sectionContent.text == &quot;Colors&quot;) { FieldInfo sectionIndexField = type.GetField(&quot;m_SelectedSectionIndex&quot;, BindingFlags.Instance | BindingFlags.NonPublic); sectionIndexField.SetValue(window, i); return; } } } } }效果图： ![这里写图片描述](https://img-blog.csdn.net/20180405215336898?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 如果插件中有在PreferencesWindow中添加项，就可以通过这个让用户快捷打开了。 通过这篇文章，希望可以帮助大家学会如何分析反编译出的代码，分析UnityEditor如何实现的编辑器，以此来写出更加实用的插件 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>PreferencesWindow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之五：修改脚本icon]]></title>
    <url>%2F2017%2F12%2F28%2Funity-bian-ji-qi-tuo-zhan-zhi-wu-xiu-gai-jiao-ben-icon%2F</url>
    <content type="text"><![CDATA[Unity修改脚本在Project面板中显示的icon有两种方法，先看示意图：![这里写图片描述](https://img-blog.csdn.net/20171228000919910?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 方法1：修改脚本的meta文件脚本的 meta文件默认如下所示： ![这里写图片描述](https://img-blog.csdn.net/20171228001130631?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 注意到，图中的icon，填的“instanceID = 0”即为默认显示 在里面填入icon文件的fileid和guid，如下所示，即可实现。 ![这里写图片描述](https://img-blog.csdn.net/20171228001038478?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 方法二：简单粗暴，Unity直接可以设置。。。 ![这里写图片描述](https://img-blog.csdn.net/20171228001444719?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>修改脚本icon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之四：ConsoleWindow中的双击日志定位]]></title>
    <url>%2F2017%2F11%2F12%2Funity-bian-ji-qi-tuo-zhan-zhi-si-consolewindow-zhong-de-shuang-ji-ri-zhi-ding-wei%2F</url>
    <content type="text"><![CDATA[原文地址： http://blog.csdn.net/l449612236/article/details/76087616 感谢上位博主的分享。 本文在此基础上，做了分析加上了更加详细的介绍。 新建LogEditor脚本直接上源码以及注释： using System.Reflection; using UnityEditor; using UnityEngine; public class LogEditor { private class LogEditorConfig { public string logScriptPath = &quot;&quot;; //自定义日志脚本路径 public string logTypeName = &quot;&quot;; //脚本type public int instanceID = 0; public LogEditorConfig(string logScriptPath, System.Type logType) { this.logScriptPath = logScriptPath; this.logTypeName = logType.FullName; } } //配置的日志 private static LogEditorConfig[] _logEditorConfig = new LogEditorConfig[] { new LogEditorConfig(&quot;Assets/Scripts/DDebug/DDebug.cs&quot;,typeof(DDebug)) }; //处理从ConsoleWindow双击跳转 [UnityEditor.Callbacks.OnOpenAssetAttribute(-1)] private static bool OnOpenAsset(int instanceID,int line) { for (int i = _logEditorConfig.Length - 1; i &gt;= 0; --i) { var configTmp = _logEditorConfig[i]; UpdateLogInstanceID(configTmp); if (instanceID == configTmp.instanceID) { var statckTrack = GetStackTrace(); if (!string.IsNullOrEmpty(statckTrack)) { /* 举例说明：下面这段是一条ConsoleWindow的日志信息 Awake UnityEngine.Debug:Log(Object) DDebug:Log(String) (at Assets/Scripts/DDebug/DDebug.cs:13) Test:Awake() (at Assets/Scripts/Test.cs:13) 说明： 1、其中第一行的&quot;Awake&quot;:是指调用自定义打印日志函数的函数名，本例是在Test脚本中的Awake函数里调用的 2、第二行的&quot;UnityEngine.Debug:Log(Object)&quot;:是指该日志最底层是通过Debug.Log函数打印出来的 3、第三行的&quot;DDebug:Log(String) (at Assets/Scripts/DDebug/DDebug.cs:13)&quot;:指第二行的函数调用在DDebug.cs的13行 4、第四行的&quot;Test:Awake() (at Assets/Scripts/Test.cs:13)&quot;:指Test.cs脚本的Awake函数调用了第二行的DDebug.cs的Log函数，在第13行 */ //通过以上信息，不难得出双击该日志应该打开Test.cs文件，并定位到第13行 //以换行分割堆栈信息 var fileNames = statckTrack.Split(&apos;\n&apos;); //定位到调用自定义日志函数的那一行：&quot;Test:Awake() (at Assets/Scripts/Test.cs:13)&quot; var fileName = GetCurrentFullFileName(fileNames); //定位到上例的行数：13 var fileLine = LogFileNameToFileLine(fileName); //得到调用自定义日志函数的脚本：&quot;Assets/Scripts/Test.cs&quot; fileName = GetRealFileName(fileName); //根据脚本名和行数，打开脚本 //&quot;Assets/Scripts/Test.cs&quot; //13 AssetDatabase.OpenAsset(AssetDatabase.LoadAssetAtPath&lt;UnityEngine.Object&gt;(fileName), fileLine); return true; } break; } } return false; } /// &lt;summary&gt; /// 反射出日志堆栈 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static string GetStackTrace() { var consoleWindowType = typeof(EditorWindow).Assembly.GetType(&quot;UnityEditor.ConsoleWindow&quot;); var fieldInfo = consoleWindowType.GetField(&quot;ms_ConsoleWindow&quot;, BindingFlags.Static | BindingFlags.NonPublic); var consoleWindowInstance = fieldInfo.GetValue(null); if (null != consoleWindowInstance) { if ((object)EditorWindow.focusedWindow == consoleWindowInstance) { fieldInfo = consoleWindowType.GetField(&quot;m_ActiveText&quot;, BindingFlags.Instance | BindingFlags.NonPublic); string activeText = fieldInfo.GetValue(consoleWindowInstance).ToString(); return activeText; } } return &quot;&quot;; } private static void UpdateLogInstanceID(LogEditorConfig config) { if (config.instanceID &gt; 0) { return; } var assetLoadTmp = AssetDatabase.LoadAssetAtPath&lt;UnityEngine.Object&gt;(config.logScriptPath); if (null == assetLoadTmp) { throw new System.Exception(&quot;not find asset by path=&quot; + config.logScriptPath); } config.instanceID = assetLoadTmp.GetInstanceID(); } private static string GetCurrentFullFileName(string[] fileNames) { string retValue = &quot;&quot;; int findIndex = -1; for (int i = fileNames.Length - 1; i &gt;= 0; --i) { bool isCustomLog = false; for (int j = _logEditorConfig.Length - 1; j &gt;= 0; --j) { if (fileNames[i].Contains(_logEditorConfig[j].logTypeName)) { isCustomLog = true; break; } } if (isCustomLog) { findIndex = i; break; } } if (findIndex &gt;= 0 &amp;&amp; findIndex &lt; fileNames.Length - 1) { retValue = fileNames[findIndex + 1]; } return retValue; } private static string GetRealFileName(string fileName) { int indexStart = fileName.IndexOf(&quot;(at &quot;) + &quot;(at &quot;.Length; int indexEnd = ParseFileLineStartIndex(fileName) - 1; fileName = fileName.Substring(indexStart, indexEnd - indexStart); return fileName; } private static int LogFileNameToFileLine(string fileName) { int findIndex = ParseFileLineStartIndex(fileName); string stringParseLine = &quot;&quot;; for (int i = findIndex; i &lt; fileName.Length; ++i) { var charCheck = fileName[i]; if (!IsNumber(charCheck)) { break; } else { stringParseLine += charCheck; } } return int.Parse(stringParseLine); } private static int ParseFileLineStartIndex(string fileName) { int retValue = -1; for (int i = fileName.Length - 1; i &gt;= 0; --i) { var charCheck = fileName[i]; bool isNumber = IsNumber(charCheck); if (isNumber) { retValue = i; } else { if (retValue != -1) { break; } } } return retValue; } private static bool IsNumber(char c) { return c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;; } }该脚本放置在工程目录下的Editor文件夹中。 接着实现自己的日志类，我这里取名为DDebug类。我之前也介绍过一篇文章，实现自己的Debug类地址如下： http://blog.csdn.net/qq_26999509/article/details/53643564 当初写的不够成熟，大家可以按照自己意愿进行编写。本次主要是为了实现双击日志定位的功能。 下面附上本次测试写的DDebug脚本： using UnityEngine; public class DDebug { static private string errorColor = &quot;red&quot;; static private string warningColor = &quot;yellow&quot;; static private string logColor = &quot;white&quot;; public static void Log(string info) { info = string.Concat(&quot;&lt;color=&quot;, logColor, &quot;&gt;&quot;, info, &quot;&lt;/color&gt;&quot;); Debug.Log(info); } public static void LogError(string info) { info = string.Concat(&quot;&lt;color=&quot;, errorColor, &quot;&gt;&quot;, info, &quot;&lt;/color&gt;&quot;); Debug.LogError(info); } public static void LogWarning(string info) { info = string.Concat(&quot;&lt;color=&quot;, warningColor, &quot;&gt;&quot;, info, &quot;&lt;/color&gt;&quot;); Debug.LogWarning(info); } }这里只是加了颜色而已，其实还有不少功能可以拓展。 接下来写个Test测试脚本，进行代码测试。 using UnityEngine; public class Test : MonoBehaviour { private void OnEnable() { DDebug.LogWarning(&quot;OnEnable&quot;); } void Awake() { DDebug.Log(&quot;Awake&quot;); } void Start () { DDebug.LogError(&quot;Start&quot;); } }将该脚本挂在场景中。 测试如下： ![这里写图片描述](https://img-blog.csdn.net/20171112231731303?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 双击日志也能成功跳转到日志函数调用的地方。。测试通过。 最后附上工程地址：链接： http://pan.baidu.com/s/1c2La0hy 密码：ibqb 再次补充，原文地址： http://blog.csdn.net/l449612236/article/details/76087616 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>日志重定向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity插件推荐]]></title>
    <url>%2F2017%2F11%2F07%2Funity-cha-jian-tui-jian%2F</url>
    <content type="text"><![CDATA[一、可视化PlayerPrefsAdvanced PlayerPrefs Window插件是一款PlayerPrefs数据的可视化管理插件 下载地址： http://www.taidous.com/forum.php?mod=viewthread&amp;tid=59744&amp;highlight=PlayerPrefs 或者链接： http://pan.baidu.com/s/1bpg0AYF 密码：w9vm 插件界面如下图所示： ![这里写图片描述](https://img-blog.csdn.net/20171106235922648?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 插件代码分析：至于编辑器的代码就不解释了，主要来看一下该插件是如何获取到工程里关于PlayerPrefs数据的所有的key 的。先看一下官方文档中关于PlayerPrefs的解释：https://docs.unity3d.com/2017.2/Documentation/ScriptReference/PlayerPrefs.html 其中 ![这里写图片描述](https://img-blog.csdn.net/20171107000252250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 从图中可以看出Unity将这些数据在各平台下存储的位置，以Windows为例，其数据存储在注册表中的 HKCU/Software[company name][product name]中 下面是截图：![这里写图片描述](https://img-blog.csdn.net/20171107000710134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 图中可见该工程包含了5个key，其中UnityGraphicsQuality是Unity工程自带的。 下面上一段该插件从注册表中获取key的代码（Windows平台的） private string[] GetAllWindowsKeys() { RegistryKey cuKey = Registry.CurrentUser; RegistryKey unityKey; //The default location of PlayerPrefs pre Unity 5_5 #if UNITY_5_5_OR_NEWER unityKey = cuKey.CreateSubKey(&quot;Software\\Unity\\UnityEditor\\&quot; + PlayerSettings.companyName + &quot;\\&quot; + PlayerSettings.productName); #else unityKey = cuKey.CreateSubKey(&quot;Software\\&quot; + PlayerSettings.companyName + &quot;\\&quot; + PlayerSettings.productName); if (unityKey.GetValueNames().Length == 0) { //On some machines (Windows 7 &amp; 8 64bit using Unity5.4) PlayersPrefs are saved in HKEY_CURRENT_USER\SOFTWARE\AppDataLow\Software\CompanyName\ProjectName weird enough... unityKey = cuKey.CreateSubKey(&quot;Software\\AppDataLow\\Software\\&quot; + PlayerSettings.companyName + &quot;\\&quot; + PlayerSettings.productName); } #endif string[] values = unityKey.GetValueNames(); for (int i = 0; i &lt; values.Length; i++) { values[i] = values[i].Substring(0, values[i].LastIndexOf(&quot;_&quot;)); } return values; }代码不一一解释了，关于RegistryKey类和Registry类查看一下MSDN：[ https://msdn.microsoft.com/zh-cn/library/microsoft.win32.registrykey(v=vs.110).aspx](https://msdn.microsoft.com/zh-cn/library/microsoft.win32.registrykey(v=vs.110).aspx)[ https://msdn.microsoft.com/zh-cn/library/microsoft.win32.registry(v=vs.110).aspx](https://msdn.microsoft.com/zh-cn/library/microsoft.win32.registry(v=vs.110).aspx) 以上知识分享，步骤详细，如有错误，欢迎指出，共同学习，共同进步]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>插件推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity与Android之二：获取手机电量信息、网络状况]]></title>
    <url>%2F2017%2F11%2F04%2Funity-yu-android-zhi-er-huo-qu-shou-ji-dian-liang-xin-xi-wang-luo-zhuang-kuang%2F</url>
    <content type="text"><![CDATA[Unity&amp;Android之二：获取手机电量信息、网络状况游戏中经常会在UI显示电量以及网络状况 手机电量包括：1、当前正在充电还是放电2、当前电量值 网络包括：1、如果是WIFI，WIFI信号强度2、如果是流量，信号强度等数据 例如王者荣耀中右上角所示[外链图片转存中…(img-GHe5z8lz-1586599241269)] 那么接下来就介绍一下如何实现获取手机电量信息以及网络状况等数据。 ####1、打开Eclipse建一个安卓库工程，注意是库工程[外链图片转存中…(img-Eq2gkKtN-1586599241270)] ####这里注意一下包名 [外链图片转存中…(img-oDCApkUW-1586599241271)] [外链图片转存中…(img-WbLOWqZD-1586599241271)] Icon显示方式选择，默认即可 [外链图片转存中…(img-p3DKc5sS-1586599241272)] 选择一个空的activity [外链图片转存中…(img-BUUZbfrT-1586599241273)] 安卓Activity名称，默认即可，Finish [外链图片转存中…(img-vNmpoZEW-1586599241274)] 创建完之后，就会得到这样一个工程 [外链图片转存中…(img-faVSY9eF-1586599241275)] 至于目录结构，请自行补充相关知识 工程创建好，此时安卓还无法与Unity进行交互，需要为工程导入一个Unity提供的classes.jar，该文件在Unity的安装目录下 [外链图片转存中…(img-qjaIEa70-1586599241276)] 将该jar文件导入到工程目录下的libs文件夹中，鼠标选中工程根目录 [外链图片转存中…(img-u6eBHOsl-1586599241277)] 准备工作完成之后，就可以开始编写代码了。 修改MainActivity.java类的父类为UnityPlayerActivity 该类需要import相关的包 1import com.unity3d.player.UnityPlayerActivity; 删除onCreate函数中的 1setContentView(R.layout.activity_main); 至此，MainActivity.java文件代码如下： 123456789101112131415161718192021222324package com.unityplugin.phonepower;import com.unity3d.player.UnityPlayerActivity;import android.os.Bundle;import android.app.Activity;import android.view.Menu;public class MainActivity extends UnityPlayerActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; &#x2F;&#x2F; Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; &#125; &#125; 接下来编写函数以供Unity调用 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.unityplugin.phonepower;import com.unity3d.player.UnityPlayerActivity;import android.net.wifi.WifiInfo;import android.net.wifi.WifiManager;import android.os.Bundle;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.view.Menu;public class MainActivity extends UnityPlayerActivity &#123; private static Context instance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); instance &#x3D; getApplication(); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; &#x2F;&#x2F; Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; &#125; &#x2F;&#x2F;获取手机当前电量、总电量（默认其实都是100）、当前状态（充电还是放电） &#x2F;&#x2F;其余数据例如电压、电池温度用的较少 public String MonitorBatteryState() &#123; IntentFilter iFilter &#x3D; new IntentFilter(Intent.ACTION_BATTERY_CHANGED); Intent intent &#x3D; instance.registerReceiver(null, iFilter); int rawLevel &#x3D; intent.getIntExtra(&quot;level&quot;, 0); &#x2F;&#x2F;获得当前电量 int scale &#x3D; intent.getIntExtra(&quot;scale&quot;, 0); &#x2F;&#x2F;获得总电量 int status &#x3D; intent.getIntExtra(&quot;status&quot;, 0); &#x2F;&#x2F;电池充电状态 int health &#x3D; intent.getIntExtra(&quot;voltage&quot;, 0); &#x2F;&#x2F;电池健康状况 int batteryV &#x3D; intent.getIntExtra(&quot;voltage&quot;, 0); &#x2F;&#x2F;电池电压(mv) int temperature &#x3D; intent.getIntExtra(&quot;temperature&quot;, 0); &#x2F;&#x2F;电池温度(数值) double t &#x3D; temperature &#x2F; 10.0; &#x2F;&#x2F;电池摄氏温度，默认获取的非摄氏温度值，需做一下运算转换 String targetStr &#x3D; &quot;&quot;; int level &#x3D; -1; if(rawLevel &gt; 0 &amp;&amp; scale &gt; 0) &#123; level &#x3D; (rawLevel * 100) &#x2F; scale; targetStr &#x3D; level + &quot;|&quot; + scale + &quot;|&quot; + status; &#125; return targetStr; &#125; &#x2F;&#x2F;获取Wifi信号强度 @SuppressWarnings(&quot;deprecation&quot;) private String ObtainWifiInfo() &#123; String result &#x3D; &quot;&quot;; WifiManager wifiManager &#x3D; (WifiManager)getApplication().getSystemService(WIFI_SERVICE); WifiInfo info &#x3D; wifiManager.getConnectionInfo(); if(info.getBSSID() !&#x3D; null) &#123; &#x2F;&#x2F;链接信号强度 int strength &#x3D; WifiManager.calculateSignalLevel(info.getRssi(), 5); &#x2F;&#x2F;链接速度 int speed &#x3D; info.getLinkSpeed(); &#x2F;&#x2F;链接速度单位 String units &#x3D; WifiInfo.LINK_SPEED_UNITS; &#x2F;&#x2F;Wifi源名称 String ssid &#x3D; info.getSSID(); int ip &#x3D; info.getIpAddress(); String mac &#x3D; info.getMacAddress(); result &#x3D; strength + &quot;|&quot; + IntToIp(ip) + &quot;|&quot; + mac + &quot;|&quot; + ssid; &#125; return result; &#125; private String IntToIp(int paramInt) &#123; return (paramInt &amp; 0xFF) + &quot;.&quot; + (0xFF &amp; paramInt &gt;&gt; 8) + &quot;.&quot; + (0xFF &amp; paramInt &gt;&gt; 16) + &quot;.&quot; + (0xFF &amp; paramInt &gt;&gt; 24); &#125;&#125; 代码编写完之后，还有一件重要的事情，那就是手机权限。访问手机电量，不需要权限，不过WIFI状况需要添加一个权限。 ###如何添加权限 双击AndroidManifest.xml文件[外链图片转存中…(img-kqf506tU-1586599241278)] 点击Add按钮添加权限 [外链图片转存中…(img-JpeMi6Cj-1586599241279)] 选中最后一项Uses Permission 添加Name为android.permission.ACCESS_WIFI_STATE的权限 [外链图片转存中…(img-UyLGdJ6s-1586599241279)] ###记得保存该文件！ 权限弄完之后即可到处jar包到Unity工程中了。 [外链图片转存中…(img-SUauE1wD-1586599241280)] [外链图片转存中…(img-wX7hrc3t-1586599241280)] [外链图片转存中…(img-HA33SXmc-1586599241281)] jar导出后，就可以创建一个Unity工程，进行测试了。 创建一个Plugins/Android的文件夹，该文件夹用来 存放安卓插件的。 将Android工程中的Libs、Res、AndroidMainFest.xml文件拷贝过来，如下：[外链图片转存中…(img-xyGiOzjW-1586599241281)] 接下来编写测试代码： 在场景中创建一个Button（用来点击从安卓那边获取数据）和两个text（分别用来显示电量数据和wifi数据），并创建一个test脚本 [外链图片转存中…(img-fGNO7G2V-1586599241282)] 脚本代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class Test : MonoBehaviour &#123; public Button button; public Text phonePowerText; public Text wifiText; private string batteryData; private string wifiData; void Awake() &#123; button.onClick.AddListener(OnButtonClicked); &#125; private void OnButtonClicked() &#123; AndroidJavaClass jc &#x3D; new AndroidJavaClass(&quot;com.unity3d.player.UnityPlayer&quot;); AndroidJavaObject jo &#x3D; jc.GetStatic&lt;AndroidJavaObject&gt;(&quot;currentActivity&quot;); batteryData &#x3D; jo.Call&lt;string&gt;(&quot;MonitorBatteryState&quot;); wifiData &#x3D; jo.Call&lt;string&gt;(&quot;ObtainWifiInfo&quot;); OnBatteryDataBack(batteryData); OnWifiDataBack(wifiData); &#125; &#x2F;&#x2F;安卓那边将数据以“|”进行分割，所以这边以&quot;|&quot;来分割数据 private void OnBatteryDataBack(string data) &#123; phonePowerText.text &#x3D; &quot;&quot;; string[] args &#x3D; data.Split(&#39;|&#39;); if (args[2] &#x3D;&#x3D; &quot;2&quot;) &#123; phonePowerText.text +&#x3D; &quot;电池充电中\n&quot;; &#125; else &#123; phonePowerText.text +&#x3D; &quot;电池放电中\n&quot;; &#125; int curPower &#x3D; int.Parse(args[0]); float power &#x3D; float.Parse(args[1]); float percent &#x3D; curPower &#x2F; power; phonePowerText.text +&#x3D; &quot; cur power:&quot; + curPower; phonePowerText.text +&#x3D; &quot; all power:&quot; + power; phonePowerText.text +&#x3D; &quot; 电量比例：&quot; + (Mathf.CeilToInt(percent * 100) + &quot;%&quot;).ToString(); &#125; private void OnWifiDataBack(string data) &#123; wifiText.text &#x3D; &quot;&quot;; wifiText.text +&#x3D; wifiData; string[] args &#x3D; wifiData.Split(&#39;|&#39;); int wifiLevel &#x3D; int.Parse(args[0]); wifiText.text +&#x3D; &quot;Wifi信号格数：&quot; + wifiLevel.ToString() + &quot;\n&quot;; string ip &#x3D; &quot;IP：&quot; + args[1] + &quot;\n&quot;; string mac &#x3D; &quot;MAC:&quot; + args[2] + &quot;\n&quot;; string ssid &#x3D; &quot;Wifi Name:&quot; + args[3] + &quot;\n&quot;; wifiText.text +&#x3D; ip; wifiText.text +&#x3D; mac; wifiText.text +&#x3D; ssid; &#125;&#125; 记得将工程平台切换成Android 最后设置PlayerSettings， [外链图片转存中…(img-6ipKBUqz-1586599241283)] 可以build成apk了。 测试截图： [外链图片转存中…(img-uGK9JHFY-1586599241284)] 从图中可以看出当前手机正在充电，并且电量为60，至于图中的61属于浮点类型数据的运算带来的精度问题，不过这点问题在应用中不足为虑。而wifi状况则是，四格信号，都是正常的。 抱歉，IP地址被我打码了。 以上知识分享，步骤详细，如有错误，欢迎指出，共同学习，共同进步]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity &amp; Android</category>
      </categories>
      <tags>
        <tag>电量信息</tag>
        <tag>网络状况</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity与Android之一：手机震动]]></title>
    <url>%2F2017%2F11%2F04%2Funity-yu-android-zhi-yi-shou-ji-zhen-dong%2F</url>
    <content type="text"><![CDATA[Unity调用手机震动在游戏中，有时为了增加游戏的打击感，会使用手机震动。关于手机震动其实很简单。 实现步骤Unity中提供了一个接口 1Handheld.Vibrate(); 该接口无需做平台判断。官方介绍：Triggers device vibration.翻译就是指触发装置振动。https://docs.unity3d.com/2017.3/Documentation/ScriptReference/Handheld.Vibrate.html 该接口无法为振动设置时长、频率等。如有需要，安卓则需要通过获取系统服务后开启振动 123456public void Shake() &#123; Activity curActivity &#x3D; UnityPlayer.currentActivity; m_vibrator &#x3D; (Vibrator)curActivity.getSystemService(Service.VIBRATOR_SERVICE); m_vibrator.vibrate(new long[]&#123;100,10,100,1000&#125;,-1); &#125; 详情参考：http://www.cnblogs.com/android-blogs/p/6381850.html 如果只是简单的使用，Unity 提供的接口已经够了。。 请在真机下进行测试最近正在补充Unity跟Android交互相关的知识，包括接入SDK、游戏中使用二维码等 以上知识分享，如有错误，欢迎指出，共同学习，共同进步]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity &amp; Android</category>
      </categories>
      <tags>
        <tag>手机震动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之三：拓展Unity的Hierarchy面板]]></title>
    <url>%2F2017%2F09%2F16%2Funity-bian-ji-qi-tuo-zhan-zhi-san-tuo-zhan-unity-de-hierarchy-mian-ban%2F</url>
    <content type="text"><![CDATA[效果图： ![这里写图片描述](https://img-blog.csdn.net/20170916213433810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 上图中在Hierarchy右侧绘制了Toggle，Label，以及自定义的texture和Unity原声的Texture，知道了原理，其实这些都很简单。。 这里主要是使用了EditorApplication类下的HierarchyWindowItemCallback类型的hierarchyWindowItemOnGUI // // 摘要: // /// // Delegate to be called for every visible list item in the HierarchyWindow on every // OnGUI event. // /// // // 参数: // instanceID: // // selectionRect: public delegate void HierarchyWindowItemCallback(int instanceID, Rect selectionRect);该委托有两个参数，一个是int类型的instanceID，通过该ID利用EditorUtility.InstanceIDToObject(instanceID)可以获取该GameObject，然后第二个参数Rect，也就是该物体在Hierarchy面板的位置信息了，通过这两个数据，在Hierarchy面板上拓展就很简单了。 using System; using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; using UnityEngine.Networking; using UnityEngine.UI; [InitializeOnLoad] public class HierachyIconManager { // 层级窗口项回调 private static readonly EditorApplication.HierarchyWindowItemCallback hiearchyItemCallback; private static Texture2D hierarchyIcon; private static Texture2D HierarchyIcon { get { if (HierachyIconManager.hierarchyIcon == null) { HierachyIconManager.hierarchyIcon = (Texture2D)Resources.Load(&quot;icon_1&quot;); } return HierachyIconManager.hierarchyIcon; } } /// &lt;summary&gt; /// 静态构造 /// &lt;/summary&gt; static HierachyIconManager() { HierachyIconManager.hiearchyItemCallback = new EditorApplication.HierarchyWindowItemCallback(HierachyIconManager.DrawHierarchyIcon); EditorApplication.hierarchyWindowItemOnGUI = (EditorApplication.HierarchyWindowItemCallback)Delegate.Combine( EditorApplication.hierarchyWindowItemOnGUI, HierachyIconManager.hiearchyItemCallback); //EditorApplication.update += Update; } // 绘制icon方法 private static void DrawHierarchyIcon(int instanceID, Rect selectionRect) { Rect rectCheck = new Rect(selectionRect); rectCheck.x += rectCheck.width - 20; rectCheck.width = 18; GameObject go = EditorUtility.InstanceIDToObject(instanceID) as GameObject; go.SetActive(GUI.Toggle(rectCheck, go.activeSelf, string.Empty)); var index = 0; GUIStyle style = null; if (go.isStatic) { index += 1; Rect rectIcon = GetRect(selectionRect, index); GUI.Label(rectIcon, &quot;S&quot;); } // 文字颜色定义 var colorMesh = new Color(42 / 255f, 210 / 255f, 235 / 255f); var colorSkinMesh = new Color(0.78f, 0.35f, 0.78f); var colorLight = new Color(251 / 255f, 244 / 255f, 124 / 255f); var colorPhysic = new Color(0.35f, 0.75f, 0f); var colorCollider = new Color(0.35f, 0.75f, 0.196f); var colorAnimation = new Color(175 / 255f, 175 / 255f, 218 / 255f); var colorCamera = new Color(111 / 255f, 121 / 255f, 212 / 255f); var colorParticle = new Color(130 / 255f, 124 / 255f, 251 / 255f); var colorNav = new Color(217 / 255f, 80 / 255f, 62 / 255f); var colorNetwork = new Color(42 / 255f, 129 / 255f, 235 / 255f); var colorAudio = new Color(255 / 255f, 126 / 255f, 0f); DrawRectIcon(selectionRect,HierarchyIcon,ref index); DrawRectIcon&lt;MeshRenderer&gt;(selectionRect, go, colorMesh, ref index, ref style); DrawRectIcon&lt;SkinnedMeshRenderer&gt;(selectionRect, go, colorSkinMesh, ref index, ref style); // Colliders DrawRectIcon&lt;BoxCollider&gt;(selectionRect, go, colorCollider, ref index, ref style); DrawRectIcon&lt;SphereCollider&gt;(selectionRect, go, colorCollider, ref index, ref style); DrawRectIcon&lt;CapsuleCollider&gt;(selectionRect, go, colorCollider, ref index, ref style); DrawRectIcon&lt;MeshCollider&gt;(selectionRect, go, colorCollider, ref index, ref style); DrawRectIcon&lt;CharacterController&gt;(selectionRect, go, colorCollider, ref index, ref style); // RigidBody DrawRectIcon&lt;Rigidbody&gt;(selectionRect, go, colorPhysic, ref index, ref style); // Lights DrawRectIcon&lt;Light&gt;(selectionRect, go, colorLight, ref index, ref style); // Joints // Animation / Animator DrawRectIcon&lt;Animator&gt;(selectionRect, go, colorAnimation, ref index, ref style); DrawRectIcon&lt;Animation&gt;(selectionRect, go, colorAnimation, ref index, ref style); // Camera / Projector DrawRectIcon&lt;Camera&gt;(selectionRect, go, colorCamera, ref index, ref style); DrawRectIcon&lt;Projector&gt;(selectionRect, go, colorCamera, ref index, ref style); // NavAgent DrawRectIcon&lt;UnityEngine.AI.NavMeshAgent&gt;(selectionRect, go, colorNav, ref index, ref style); DrawRectIcon&lt;UnityEngine.AI.NavMeshObstacle&gt;(selectionRect, go, colorNav, ref index, ref style); // Network DrawRectIcon&lt;NetworkIdentity&gt;(selectionRect, go, colorNetwork, ref index, ref style); DrawRectIcon&lt;NetworkAnimator&gt;(selectionRect, go, colorNetwork, ref index, ref style); DrawRectIcon&lt;NetworkTransform&gt;(selectionRect, go, colorNetwork, ref index, ref style); DrawRectIcon&lt;NetworkBehaviour&gt;(selectionRect, go, colorNetwork, ref index, ref style); DrawRectIcon&lt;NetworkManager&gt;(selectionRect, go, colorNetwork, ref index, ref style); // Particle DrawRectIcon&lt;ParticleSystem&gt;(selectionRect, go, colorParticle, ref index, ref style); // Audio DrawRectIcon&lt;AudioSource&gt;(selectionRect, go, colorAudio, ref index, ref style); DrawRectIcon&lt;AudioReverbZone&gt;(selectionRect, go, colorAudio, ref index, ref style); //UI DrawRectIcon&lt;Image&gt;(selectionRect, go, colorParticle, ref index, ref style); DrawRectIcon&lt;Text&gt;(selectionRect, go, colorParticle, ref index, ref style); DrawRectIcon&lt;SpriteRenderer&gt;(selectionRect, go, colorParticle, ref index, ref style); // 绘制Label来覆盖原有的名字 if (style != null &amp;&amp; go.activeInHierarchy) { GUI.Label(selectionRect, go.name, style); } } private static void Update() { Debug.Log(&quot;1&quot;); } private static Rect GetRect(Rect selectionRect , int index) { Rect rect = new Rect(selectionRect); rect.x += rect.width - 20 - (20 * index); rect.width = 18; return rect; } /// &lt;summary&gt; /// 绘制一个Unity原声图标 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;rect&quot;&gt;&lt;/param&gt; private static void DrawIcon&lt;T&gt;(Rect rect) { var icon = EditorGUIUtility.ObjectContent(null, typeof(T)).image; GUI.Label(rect, icon); } private static void DrawRectIcon&lt;T&gt;(Rect selectionRect,GameObject go,Color textColor,ref int order, ref GUIStyle style)where T :Component { if (go.HasComponent&lt;T&gt;()) { order += 1; var rect = GetRect(selectionRect, order); DrawIcon&lt;T&gt;(rect); } } private static void DrawRectIcon(Rect selectionRect,Texture2D texture,ref int order) { order += 1; var rect = GetRect(selectionRect,order); GUI.Label(rect,texture); } } public static class ExtensionMethods { public static bool HasComponent&lt;T&gt;(this GameObject go) where T : Component { return go.GetComponent&lt;T&gt;() != null; } }其中使用了[InitializeOnLoad]，这个Attribute的意思是在启动Unity的时候运行的编辑器脚本，该类需要一个静态的构造函数。。 通过EditorGUIUtility.ObjectContent(null,typeof(T)).image就可以获取到T类型的Unity原声Texture了。而Label和Toggle，则分别使用GUI.Label和GUI.Toggle即可。。具体参见上面代码。 我们可以根据需要定制自己需要的Hierarchy面板，例如上述代码中通过判断该GameObject是否是static的，如果是，则绘制一个S在旁边，这样就可以很快速的查看哪些物体是static的了。。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>Hierarchy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之二：ReorderableList可重新排序的列表框（复杂使用）]]></title>
    <url>%2F2017%2F09%2F02%2Funity-bian-ji-qi-tuo-zhan-zhi-er-reorderablelist-ke-chong-xin-pai-xu-de-lie-biao-kuang-fu-za-shi-yong%2F</url>
    <content type="text"><![CDATA[先看效果gif图：![这里写图片描述](https://img-blog.csdn.net/20170902160043794?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 如果没有看过Unity编辑器拓展之一：ReorderableList可重新排序的列表框（简单使用）的，可以先看这一篇： http://blog.csdn.net/qq_26999509/article/details/77782177 在此基础上，来绘制更加复杂的类 先提供一个需要绘制的类 using UnityEngine; using System.Collections; using System.Collections.Generic; using System; public class CharacterTest : MonoBehaviour { public List&lt;Character&gt; characters = new List&lt;Character&gt;(); // Use this for initialization void Start () { } // Update is called once per frame void Update () { } } [Serializable] public class Character { [SerializeField] Texture icon; [SerializeField] string name; [SerializeField] int hp; [SerializeField] int power; [SerializeField] GameObject weapon; }然后跟上一篇一样，通过使用ReorderableList绘制List using UnityEngine; using System.Collections; using UnityEditor; using UnityEditorInternal; [CustomEditor(typeof(CharacterTest))] public class CharacterInspector : Editor { ReorderableList reorderableList; void OnEnable() { SerializedProperty prop = serializedObject.FindProperty(&quot;characters&quot;); reorderableList = new ReorderableList(serializedObject, prop, true, true, true, true); //设置单个元素的高度 reorderableList.elementHeight = 80; //绘制单个元素 reorderableList.drawElementCallback = (rect, index, isActive, isFocused) =&gt; { var element = prop.GetArrayElementAtIndex(index); rect.height -= 4; rect.y += 2; EditorGUI.PropertyField(rect, element); }; //背景色 reorderableList.drawElementBackgroundCallback = (rect, index, isActive, isFocused) =&gt; { GUI.backgroundColor = Color.yellow; }; //头部 reorderableList.drawHeaderCallback = (rect) =&gt; EditorGUI.LabelField(rect, prop.displayName); } public override void OnInspectorGUI() { serializedObject.Update(); reorderableList.DoLayoutList(); serializedObject.ApplyModifiedProperties(); } }目前的效果如下图： ![这里写图片描述](https://img-blog.csdn.net/20170902160317066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 最后还需要利用PropertyDrawer来绘制单个Serializable类的每个实例的GUI，也就是Character类 using UnityEngine; using System.Collections; using UnityEditor; //定制Serializable类的每个实例的GUI [CustomPropertyDrawer(typeof(Character))] public class CharacterDrawer : PropertyDrawer { public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) { //创建一个属性包装器，用于将常规GUI控件与SerializedProperty一起使用 using (new EditorGUI.PropertyScope(position, label, property)) { //设置属性名宽度 Name HP EditorGUIUtility.labelWidth = 60; //输入框高度，默认一行的高度 position.height = EditorGUIUtility.singleLineHeight; //ico 位置矩形 Rect iconRect = new Rect(position) { width = 68, height = 68 }; Rect nameRect = new Rect(position) { width = position.width - 70, //减去icon的width 64 x = position.x + 70 //在icon的基础上右移64 }; Rect hpRect = new Rect(nameRect) { //在name的基础上，y坐标下移 y = nameRect.y + EditorGUIUtility.singleLineHeight + 2 }; Rect powerRect = new Rect(hpRect) { //在hp的基础上，y坐标下移 y = hpRect.y + EditorGUIUtility.singleLineHeight + 2 }; Rect weaponLabelRect = new Rect(powerRect) { y = powerRect.y + EditorGUIUtility.singleLineHeight + 2, width = 60 }; Rect weaponRect = new Rect(weaponLabelRect) { x = weaponLabelRect.x + 60, width = powerRect.width - 60 }; //找到每个属性的序列化值 SerializedProperty iconProperty = property.FindPropertyRelative(&quot;icon&quot;); SerializedProperty nameProperty = property.FindPropertyRelative(&quot;name&quot;); SerializedProperty hpProperty = property.FindPropertyRelative(&quot;hp&quot;); SerializedProperty powerProperty = property.FindPropertyRelative(&quot;power&quot;); SerializedProperty weaponProperty = property.FindPropertyRelative(&quot;weapon&quot;); //绘制icon iconProperty.objectReferenceValue = EditorGUI.ObjectField(iconRect, iconProperty.objectReferenceValue, typeof(Texture), false); //绘制name nameProperty.stringValue = EditorGUI.TextField(nameRect, nameProperty.displayName, nameProperty.stringValue); //Slider，范围在0-100 EditorGUI.IntSlider(hpRect, hpProperty, 0, 100); //Slider，范围在0-10 EditorGUI.IntSlider(powerRect, powerProperty, 0, 10); EditorGUI.PrefixLabel(weaponLabelRect, new GUIContent(&quot;weapon&quot;)); EditorGUI.PropertyField(weaponRect, weaponProperty, GUIContent.none); } } }最后效果就是文章一开始的gif图了 示例工程链接：链接： http://pan.baidu.com/s/1cgyZ98 密码：jbzh 以上知识分享，如有错误，欢迎指出，共同学习，共同进步]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>ReorderableList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器拓展之一：ReorderableList可重新排序的列表框（简单使用）]]></title>
    <url>%2F2017%2F09%2F01%2Funity-bian-ji-qi-tuo-zhan-zhi-yi-reorderablelist-ke-chong-xin-pai-xu-de-lie-biao-kuang-jian-dan-shi-yong%2F</url>
    <content type="text"><![CDATA[可重新排序的列表框先看效果图：![这里写图片描述](https://img-blog.csdn.net/20170901231522594?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) UnityEditorInternal命名空间下提供 一个类ReorderableList可以实现通过拖曳来达到列表元素的重新排序。 基本使用：名称 描述draggable 拖曳排序displayAdd 显示添加按钮displayRemove 显示移除按钮elementHeight 元素高度headerHeight 表头高度footerHeight 尾部高度showDefaultBackground 显示默认背景drawHeaderCallback 绘制表头回调drawFooterCallback 绘制尾部回调drawElementCallback 绘制元素回调drawElementBackgroundCallback 绘制元素背景回调onReorderCallback 重新排序回调onSelectCallback 选中回调onAddCallback 添加按钮回调onAddDropdownCallback 添加下拉选项回调onRemoveCallback 移除元素回调onMouseUpCallback 鼠标抬起回调onCanRemoveCallback 是否显示可移除按钮回调onChangedCallback 列表改变回调 示例代码如下：先创建一个脚本：TestList using UnityEngine; using System.Collections; using System.Collections.Generic; public class TestList : MonoBehaviour { public List&lt;Color&gt; m_colors = new List&lt;Color&gt;(); private void Start() { } }上述代码中有一个List类型的变量，接下来使用一个继承自Editor脚本实现主要逻辑 using UnityEngine; using System.Collections; using UnityEditor; using UnityEditorInternal; using System; [CustomEditor(typeof(TestList))] public class TestListEditor : Editor { private ReorderableList m_colors; private void OnEnable() { m_colors = new ReorderableList(serializedObject, serializedObject.FindProperty(&quot;m_colors&quot;), true, true, true, true); //绘制元素 m_colors.drawElementCallback = (Rect rect, int index, bool selected, bool focused) =&gt; { SerializedProperty itemData = m_colors.serializedProperty.GetArrayElementAtIndex(index); rect.y += 2; rect.height = EditorGUIUtility.singleLineHeight; EditorGUI.PropertyField(rect, itemData, GUIContent.none); }; //绘制表头 m_colors.drawHeaderCallback = (Rect rect) =&gt; { GUI.Label(rect, &quot;Colors&quot;); }; //当移除元素时回调 m_colors.onRemoveCallback = (ReorderableList list) =&gt; { //弹出一个对话框 if (EditorUtility.DisplayDialog(&quot;警告&quot;,&quot;是否确定删除该颜色&quot;,&quot;是&quot;,&quot;否&quot;)) { //当点击“是” ReorderableList.defaultBehaviours.DoRemoveButton(list); } }; //添加按钮回调 m_colors.onAddCallback = (ReorderableList list) =&gt; { if (list.serializedProperty != null) { list.serializedProperty.arraySize++; list.index = list.serializedProperty.arraySize - 1; SerializedProperty itemData = list.serializedProperty.GetArrayElementAtIndex(list.index); itemData.colorValue = Color.red; } else { ReorderableList.defaultBehaviours.DoAddButton(list); } }; //鼠标抬起回调 m_colors.onMouseUpCallback = (ReorderableList list) =&gt; { Debug.Log(&quot;MouseUP&quot;); }; //当选择元素回调 m_colors.onSelectCallback = (ReorderableList list) =&gt; { //打印选中元素的索引 Debug.Log(list.index); }; } public override void OnInspectorGUI() { EditorGUILayout.Space(); serializedObject.Update(); m_colors.DoLayoutList(); serializedObject.ApplyModifiedProperties(); } }结果就如之前的图中显示所示。 其中OnInspectorGUI函数中，删除了base.OnInspectorGUI();不然的话，效果如下图：![这里写图片描述](https://img-blog.csdn.net/20170901232457862?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 可以看出，colors绘制了两遍。 示例工程链接：链接： http://pan.baidu.com/s/1o7Tjslc 密码：pgri 以上知识分享，如有错误，欢迎指出，共同学习，共同进步]]></content>
      <categories>
        <category>Unity</category>
        <category>Unity编辑器拓展</category>
      </categories>
      <tags>
        <tag>ReorderableList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之图片轮播组件实现]]></title>
    <url>%2F2017%2F08%2F20%2Funity-zhi-tu-pian-lun-bo-zu-jian-shi-xian%2F</url>
    <content type="text"><![CDATA[游戏中有时候会见到图片轮播的效果，那么这里就自己封装了一个，包括自动轮播、切页按钮控制、页码下标更新、滑动轮播、切页后的回调等等下面，先上一个简陋的gif动态效果图 ![这里写图片描述](https://img-blog.csdn.net/20170820225254127?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 从图中可以看出，该示例包括了三张图片的轮播，左右分别是上一张和下一张的按钮，右下角显示了当前是第几章的页码下标。 直接上脚本： using System; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.Events; using UnityEngine.EventSystems; using UnityEngine.UI; namespace UnityEngine.UI { [AddComponentMenu(&quot;UI/Slidershow&quot;, 39)] //添加菜单 [ExecuteInEditMode] //编辑模式下可执行 [DisallowMultipleComponent] //不可重复 [RequireComponent(typeof(RectTransform))] //依赖于RectTransform组件 public class Slideshow : UIBehaviour,IPointerDownHandler,IPointerUpHandler { public enum MovementType { /// &lt;summary&gt; /// 循环 /// &lt;/summary&gt; Circulation, //循环，轮播到最后一页之后，直接回到第一页 /// &lt;summary&gt; /// 来回往复 /// &lt;/summary&gt; PingPong, //来回往复，轮播到最后一页之后，倒序轮播，到第一页之后，同理 } public enum MoveDir { Left, Right, } [SerializeField] private MovementType m_movement = MovementType.Circulation; public MovementType Movement { get { return m_movement; } set { m_movement = value; } } [SerializeField] private RectTransform m_content; public RectTransform Content { get { return m_content; } set { m_content = value; } } [SerializeField] private Button m_lastPageButton; public Button LastPageButton { get { return m_lastPageButton; } set { m_lastPageButton = value; } } [SerializeField] private Button m_nextPageButton; public Button NextPageButton { get { return m_nextPageButton; } set { m_nextPageButton = value; } } /// &lt;summary&gt; /// 自动轮播时长 /// &lt;/summary&gt; [SerializeField] private float m_showTime = 2.0f; public float ShowTime { get { return m_showTime; } set { m_showTime = value; } } /// &lt;summary&gt; /// 是否自动轮播 /// &lt;/summary&gt; [SerializeField] private bool m_autoSlide = false; public bool AutoSlide { get { return m_autoSlide; }set { m_autoSlide = value; } } /// &lt;summary&gt; /// 自动轮播方向，-1表示向左，1表示向右 /// &lt;/summary&gt; private MoveDir m_autoSlideDir = MoveDir.Right; /// &lt;summary&gt; /// 是否允许拖动切页 /// &lt;/summary&gt; [SerializeField] private bool m_allowDrag = true; public bool AllowDrag { get { return m_allowDrag; }set { m_allowDrag = value; } } /// &lt;summary&gt; /// 当前显示页的页码，下标从0开始 /// &lt;/summary&gt; private int m_curPageIndex = 0; public int CurPageIndex { get { return m_curPageIndex; } } /// &lt;summary&gt; /// 最大页码 /// &lt;/summary&gt; private int m_maxPageIndex = 0; public int MaxPageIndex { get { return m_maxPageIndex; } } /// &lt;summary&gt; /// 圆圈页码ToggleGroup /// &lt;/summary&gt; [SerializeField] private ToggleGroup m_pageToggleGroup; public ToggleGroup PageToggleGroup { get { return m_pageToggleGroup; } set { m_pageToggleGroup = value; } } /// &lt;summary&gt; /// 圆圈页码Toggle List /// &lt;/summary&gt; private List&lt;Toggle&gt; m_pageToggleList; public List&lt;Toggle&gt; PageToggleLise { get { return m_pageToggleList; }} //item数目 private int m_itemNum = 0; public int ItemNum { get { return m_itemNum; } } //以Toggle为Key，返回页码 private Dictionary&lt;Toggle, int&gt; m_togglePageNumDic = null; private float m_time = 0f; private List&lt;float&gt; m_childItemPos = new List&lt;float&gt;(); private GridLayoutGroup m_grid = null; protected override void Awake() { base.Awake(); if (null == m_content) { throw new Exception(&quot;Slideshow content is null&quot;); } else { m_grid = m_content.GetComponent&lt;GridLayoutGroup&gt;(); if (m_grid == null) { throw new Exception(&quot;Slideshow content is miss GridLayoutGroup Component&quot;); } InitChildItemPos(); } if (null != m_lastPageButton) { m_lastPageButton.onClick.AddListener(OnLastPageButtonClick); } if (null != m_nextPageButton) { m_nextPageButton.onClick.AddListener(OnNextPageButtonClick); } if (null != m_pageToggleGroup) { int toggleNum = m_pageToggleGroup.transform.childCount; if (toggleNum &gt; 0) { m_pageToggleList = new List&lt;Toggle&gt;(); m_togglePageNumDic = new Dictionary&lt;Toggle, int&gt;(); for (int i = 0; i &lt; toggleNum; i++) { Toggle childToggle = m_pageToggleGroup.transform.GetChild(i).GetComponent&lt;Toggle&gt;(); if (null != childToggle) { m_pageToggleList.Add(childToggle); m_togglePageNumDic.Add(childToggle, i); childToggle.onValueChanged.AddListener(OnPageToggleValueChanged); } } m_itemNum = m_pageToggleList.Count; m_maxPageIndex = m_pageToggleList.Count - 1; } } UpdateCutPageButtonActive(m_curPageIndex); } private void InitChildItemPos() { int childCount = m_content.transform.childCount; float cellSizeX = m_grid.cellSize.x; float spacingX = m_grid.spacing.x; float posX = -cellSizeX * 0.5f; m_childItemPos.Add(posX); for (int i = 1; i &lt; childCount; i++) { posX -= cellSizeX + spacingX; m_childItemPos.Add(posX); } } private void OnPageToggleValueChanged(bool ison) { if (ison) { Toggle activeToggle = GetActivePageToggle(); if (m_togglePageNumDic.ContainsKey(activeToggle)) { int page = m_togglePageNumDic[activeToggle]; SwitchToPageNum(page); } } } private Toggle GetActivePageToggle() { if (m_pageToggleGroup == null || m_pageToggleList == null || m_pageToggleList.Count &lt;= 0) { return null; } for (int i = 0; i &lt; m_pageToggleList.Count; i++) { if (m_pageToggleList[i].isOn) { return m_pageToggleList[i]; } } return null; } /// &lt;summary&gt; /// 切换至某页 /// &lt;/summary&gt; /// &lt;param name=&quot;pageNum&quot;&gt;页码&lt;/param&gt; private void SwitchToPageNum(int pageNum) { if (pageNum &lt; 0 || pageNum &gt; m_maxPageIndex) { throw new Exception(&quot;page num is error&quot;); } if (pageNum == m_curPageIndex) { //目标页与当前页是同一页 return; } m_curPageIndex = pageNum; if (m_movement == MovementType.PingPong) { UpdateCutPageButtonActive(m_curPageIndex); } Vector3 pos = m_content.localPosition; m_content.localPosition = new Vector3(m_childItemPos[m_curPageIndex], pos.y, pos.z); m_pageToggleList[m_curPageIndex].isOn = true; if (m_onValueChanged != null) { //执行回调 m_onValueChanged.Invoke(m_pageToggleList[m_curPageIndex].gameObject); } } /// &lt;summary&gt; /// 根据页码更新切页按钮active /// &lt;/summary&gt; /// &lt;param name=&quot;pageNum&quot;&gt;&lt;/param&gt; private void UpdateCutPageButtonActive(int pageNum) { if (pageNum == 0) { UpdateLastButtonActive(false); UpdateNextButtonActive(true); } else if (pageNum == m_maxPageIndex) { UpdateLastButtonActive(true); UpdateNextButtonActive(false); } else { UpdateLastButtonActive(true); UpdateNextButtonActive(true); } } private void OnNextPageButtonClick() { m_time = Time.time; //重新计时 switch (m_movement) { case MovementType.Circulation: SwitchToPageNum((m_curPageIndex + 1) % m_itemNum); break; case MovementType.PingPong: //该模式下，会自动隐藏切页按钮 SwitchToPageNum(m_curPageIndex + 1); break; default: break; } Debug.Log(m_content.localPosition); } private void OnLastPageButtonClick() { m_time = Time.time; //重新计时 switch (m_movement) { case MovementType.Circulation: SwitchToPageNum((m_curPageIndex + m_itemNum - 1) % m_itemNum); break; case MovementType.PingPong: //该模式下，会自动隐藏切页按钮 SwitchToPageNum(m_curPageIndex - 1); break; default: break; } } private void UpdateLastButtonActive(bool activeSelf) { if (null == m_lastPageButton) { throw new Exception(&quot;Last Page Button is null&quot;); } bool curActive = m_lastPageButton.gameObject.activeSelf; if (curActive != activeSelf) { m_lastPageButton.gameObject.SetActive(activeSelf); } } private void UpdateNextButtonActive(bool activeSelf) { if (null == m_nextPageButton) { throw new Exception(&quot;Next Page Button is null&quot;); } bool curActive = m_nextPageButton.gameObject.activeSelf; if (curActive != activeSelf) { m_nextPageButton.gameObject.SetActive(activeSelf); } } private Vector3 m_originDragPos = Vector3.zero; private Vector3 m_desDragPos = Vector3.zero; private bool m_isDrag = false; public void OnPointerDown(PointerEventData eventData) { if (!m_allowDrag) { return; } if (eventData.button != PointerEventData.InputButton.Left) { return; } if (!IsActive()) { return; } m_isDrag = true; m_originDragPos = eventData.position; } public void OnPointerUp(PointerEventData eventData) { m_desDragPos = eventData.position; MoveDir dir = MoveDir.Right; if (m_desDragPos.x &lt; m_originDragPos.x) { dir = MoveDir.Left; } switch (dir) { case MoveDir.Left: if (m_movement == MovementType.Circulation || (m_movement == MovementType.PingPong &amp;&amp; m_curPageIndex != 0)) { OnLastPageButtonClick(); } break; case MoveDir.Right: if (m_movement == MovementType.Circulation || (m_movement == MovementType.PingPong &amp;&amp; m_curPageIndex != m_maxPageIndex)) { OnNextPageButtonClick(); } break; } m_isDrag = false; } /// &lt;summary&gt; /// 切页后回调函数 /// &lt;/summary&gt; [Serializable] public class SlideshowEvent : UnityEvent&lt;GameObject&gt; { } [SerializeField] private SlideshowEvent m_onValueChanged = new SlideshowEvent(); public SlideshowEvent OnValueChanged { get { return m_onValueChanged; } set { m_onValueChanged = value; } } public override bool IsActive() { return base.IsActive() &amp;&amp; m_content != null; } private void Update() { if (m_autoSlide &amp;&amp; !m_isDrag) { if (Time.time &gt; m_time + m_showTime) { m_time = Time.time; switch (m_movement) { case MovementType.Circulation: m_autoSlideDir = MoveDir.Right; break; case MovementType.PingPong: if (m_curPageIndex == 0) { m_autoSlideDir = MoveDir.Right; } else if (m_curPageIndex == m_maxPageIndex) { m_autoSlideDir = MoveDir.Left; } break; } switch (m_autoSlideDir) { case MoveDir.Left: OnLastPageButtonClick(); break; case MoveDir.Right: OnNextPageButtonClick(); break; } } } } } }这里提供了一个枚举MovementType，该枚举定义了两种循环方式，其中Circulation循环，是指轮播到最后一页之后，直接回到第一页；而PingPong相信大家你熟悉了，就是来回往复的。 其中还提供了对每张图显示的时长进行设置，还有是否允许自动轮播的控制，是否允许拖动切页控制，等等。。其实将图片作为轮播子元素只是其中之一而已，完全可以将ScrollRect作为轮播子元素，这样每个子元素又可以滑动阅览了。。 这里还提供了两个编辑器脚本，一个是SlideshowEditor（依赖Slideshow组件），另一个是给用户提供菜单用的CreateSlideshow，代码分别如下： using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; public class CreateSlideshow : Editor { private static GameObject m_slideshowPrefab = null; private static GameObject m_canvas = null; [MenuItem(&quot;GameObject/UI/Slideshow&quot;)] static void CreateSlideshowUI(MenuCommand menuCommand) { if (null == m_slideshowPrefab) { m_slideshowPrefab = Resources.Load&lt;GameObject&gt;(&quot;Slideshow&quot;); if (null == m_slideshowPrefab) { Debug.LogError(&quot;Prefab Slideshow is null&quot;); return; } } m_canvas = menuCommand.context as GameObject; if (m_canvas == null || m_canvas.GetComponentInParent&lt;Canvas&gt;() == null) { m_canvas = GetOrCreateCanvasGameObject(); } GameObject go = GameObject.Instantiate(m_slideshowPrefab, m_canvas.transform); go.transform.localPosition = Vector3.zero; go.name = &quot;Slideshow&quot;; Selection.activeGameObject = go; } static public GameObject GetOrCreateCanvasGameObject() { GameObject selectedGo = Selection.activeGameObject; Canvas canvas = (selectedGo != null) ? selectedGo.GetComponentInParent&lt;Canvas&gt;() : null; if (canvas != null &amp;&amp; canvas.gameObject.activeInHierarchy) return canvas.gameObject; canvas = Object.FindObjectOfType(typeof(Canvas)) as Canvas; if (canvas != null &amp;&amp; canvas.gameObject.activeInHierarchy) return canvas.gameObject; return CreateCanvas(); } public static GameObject CreateCanvas() { var root = new GameObject(&quot;Canvas&quot;); root.layer = LayerMask.NameToLayer(&quot;UI&quot;); Canvas canvas = root.AddComponent&lt;Canvas&gt;(); canvas.renderMode = RenderMode.ScreenSpaceOverlay; root.AddComponent&lt;CanvasScaler&gt;(); root.AddComponent&lt;GraphicRaycaster&gt;(); Undo.RegisterCreatedObjectUndo(root, &quot;Create &quot; + root.name); CreateEventSystem(); return root; } public static void CreateEventSystem() { var esys = Object.FindObjectOfType&lt;EventSystem&gt;(); if (esys == null) { var eventSystem = new GameObject(&quot;EventSystem&quot;); GameObjectUtility.SetParentAndAlign(eventSystem, null); esys = eventSystem.AddComponent&lt;EventSystem&gt;(); eventSystem.AddComponent&lt;StandaloneInputModule&gt;(); Undo.RegisterCreatedObjectUndo(eventSystem, &quot;Create &quot; + eventSystem.name); } } } using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor.Advertisements; using UnityEngine.UI; namespace UnityEditor.UI { [CustomEditor(typeof(Slideshow), true)] public class SlideshowEditor : Editor { SerializedProperty m_movement; SerializedProperty m_content; SerializedProperty m_lastPageButton; SerializedProperty m_nextPageButton; SerializedProperty m_showTime; SerializedProperty m_pageToggleGroup; SerializedProperty m_onValueChanged; SerializedProperty m_allowDrag; SerializedProperty m_autoSlide; protected virtual void OnEnable() { m_movement = serializedObject.FindProperty(&quot;m_movement&quot;); m_content = serializedObject.FindProperty(&quot;m_content&quot;); m_lastPageButton = serializedObject.FindProperty(&quot;m_lastPageButton&quot;); m_nextPageButton = serializedObject.FindProperty(&quot;m_nextPageButton&quot;); m_showTime = serializedObject.FindProperty(&quot;m_showTime&quot;); m_pageToggleGroup = serializedObject.FindProperty(&quot;m_pageToggleGroup&quot;); m_onValueChanged = serializedObject.FindProperty(&quot;m_onValueChanged&quot;); m_allowDrag = serializedObject.FindProperty(&quot;m_allowDrag&quot;); m_autoSlide = serializedObject.FindProperty(&quot;m_autoSlide&quot;); } public override void OnInspectorGUI() { serializedObject.Update(); EditorGUILayout.PropertyField(m_movement); EditorGUILayout.PropertyField(m_content); EditorGUILayout.PropertyField(m_lastPageButton); EditorGUILayout.PropertyField(m_nextPageButton); EditorGUILayout.PropertyField(m_allowDrag); EditorGUILayout.PropertyField(m_autoSlide); EditorGUILayout.PropertyField(m_showTime); EditorGUILayout.PropertyField(m_pageToggleGroup); EditorGUILayout.Space(); EditorGUILayout.PropertyField(m_onValueChanged); //不加这句代码，在编辑模式下，无法将物体拖拽赋值 serializedObject.ApplyModifiedProperties(); } } }这两个脚本中使用了一些拓展编辑器的知识，后续在另外写博客介绍其中脚本CreateSlideshow中使用UGUI源码中的DefaultControls脚本里的方法，有兴趣可以去下载查阅。Demo工程下载地址如下：链接： http://pan.baidu.com/s/1i4Rralf 密码：7loe链接如有私有，请及时联系补充 以上知识分享，如有错误，欢迎指出，共同学习，共同进步]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>图片轮播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之UGUI脚本自动生成]]></title>
    <url>%2F2017%2F08%2F09%2Funity-zhi-ugui-jiao-ben-zi-dong-sheng-cheng%2F</url>
    <content type="text"><![CDATA[在做UI开发工作中，往往会有很多重复工作，比如用FindChild找可交互的ui呀，比如给这些ui加Listener等，那么这里提供一种思路，通过给UI中需要加交互事件的ui物体加上标记脚本，然后就可以根据这些标记得出相对于UIRoot的路径，得到路径就可以通过FindChild得到交互UI物体，然后给他们加上事件监听即可。 先定义一个枚举 using System.Collections; using System.Collections.Generic; using UnityEngine; public enum UIType { UIRoot, Transform, Image, RawImage, Button, Toggle, Slider, Scrollbar, Dropdown, InputField, ScrollRect, }然后上一个效果图来给UI物体加标记 ![这里写图片描述](https://img-blog.csdn.net/20170809002217766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 从图中可以看出，加完标记之后，生成代码。先看示例的UIDialog![这里写图片描述](https://img-blog.csdn.net/20170809002336955?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)其中图中两一个Image，一个InputFiel，一个Button，一个Toggle生成的代码如下： using UnityEngine; using UnityEngine.UI; using System; public class TestDialog : MonoBehaviour { private Image m_Image = null; private InputField m_UserNameInputField = null; private Button m_CloseButton = null; private Toggle m_SexToggle = null; void Awake() { m_Image = transform.FindChild(&quot;Image&quot;).GetComponent&lt;Image&gt;(); m_UserNameInputField = transform.FindChild(&quot;Image/UserNameInputField&quot;).GetComponent&lt;InputField&gt;(); m_CloseButton = transform.FindChild(&quot;CloseButton&quot;).GetComponent&lt;Button&gt;(); m_SexToggle = transform.FindChild(&quot;SexToggle&quot;).GetComponent&lt;Toggle&gt;(); } void Start() { InitUIEvent(); } private void InitUIEvent() { m_UserNameInputField.onEndEdit.AddListener(OnUserNameInputFieldEndEdit); m_CloseButton.onClick.AddListener(OnCloseButtonClick); m_SexToggle.onValueChanged.AddListener(OnSexToggleValueChanged); } private void OnUserNameInputFieldEndEdit(string arg0) { throw new NotImplementedException(); } private void OnCloseButtonClick() { throw new NotImplementedException(); } private void OnSexToggleValueChanged(bool arg0) { throw new NotImplementedException(); } }生成代码的逻辑比较长，就不放出来了，原理就是按照规范拼StringBuilder，包括变量名前缀，函数名规范等，以及插入等长度的空格代替tab、还有换行使得代码对其等等。 这个只是提供一种思路，Demo以及源码会放在下面，大家有兴趣可以参考一下，转载请注明原文地址。Demo源码下载地址：链接： http://pan.baidu.com/s/1i4YbIML 密码：uyg9 下载链接如有失效，请即时联系以上知识分享，如有错误，欢迎指出，共同学习，共同进步]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
      <tags>
        <tag>脚本生成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之简易定时器Timer]]></title>
    <url>%2F2017%2F08%2F06%2Funity-zhi-jian-yi-ding-shi-qi-timer%2F</url>
    <content type="text"><![CDATA[有时候我们会有这样的需求：几秒或者几帧之后做什么事，也就是一个定时器。这里我利用Time.realtimeSinceStartup实现了一个简单的秒钟定时器，当然还可以利用Time.frameCount实现一个帧计时器 上代码： using System; using System.Collections; using System.Collections.Generic; using UnityEngine; public class Timer { private Timer() { m_timerTask = new List&lt;TimerTask&gt;(); } private static Timer m_instance; public static Timer Instance { get { if (m_instance == null) { m_instance = new Timer(); } return m_instance; } } public delegate void OnTimeStart(); private List&lt;TimerTask&gt; m_timerTask = null; public class TimerTask { //public int Id; public float RealTime; public float Time; //public bool IsLoop; //public int LoopCount; public OnTimeStart CallBack; } public void UpdateTimer() { for (int i = 0; i &lt; m_timerTask.Count; i++) { TimerTask t = m_timerTask[i]; if (t == null) { continue; } if (t.RealTime &lt; Time.realtimeSinceStartup) { if (null != t.CallBack) { t.CallBack(); m_timerTask.Remove(t); } } } } public void AddTimerTask(float time, OnTimeStart callback) { if (null == callback) { return; } TimerTask t = new TimerTask(); t.Time = time; t.RealTime = Time.realtimeSinceStartup + time; t.CallBack = callback; m_timerTask.Add(t); } }上面的代码省略了是否循环、循环次数以及帧计时器，思路类似。最后附上测试Demo下载地址：链接： http://pan.baidu.com/s/1bp5xRSr 密码：y35i 下载链接如有失效，请即时联系以上知识分享，如有错误，欢迎指出，共同学习，共同进步]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>简易定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之拓展Button：支持双击与长按]]></title>
    <url>%2F2017%2F08%2F06%2Funity-zhi-tuo-zhan-button-zhi-chi-shuang-ji-yu-chang-an%2F</url>
    <content type="text"><![CDATA[双击直接利用的eventData.clickCount实现，而长按则是在PointerDown的时候记录时间，然后在Update里判断时间即可，由于代码比较简单，直接上源码。 using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; public class UIButton : Button { protected UIButton() { m_onDoubleClick = new ButtonClickedEvent(); m_onLongPress = new ButtonClickedEvent(); } private ButtonClickedEvent m_onLongPress; public ButtonClickedEvent OnLongPress { get { return m_onLongPress; } set { m_onLongPress = value; } } private ButtonClickedEvent m_onDoubleClick; public ButtonClickedEvent OnDoubleClick { get { return m_onDoubleClick; } set { m_onDoubleClick = value; } } private bool m_isStartPress = false; private float m_curPointDownTime = 0f; private float m_longPressTime = 1f; private bool m_longPressTrigger = false; void Update () { if (m_isStartPress &amp;&amp; !m_longPressTrigger) { if (Time.time &gt; m_curPointDownTime + m_longPressTime) { m_longPressTrigger = true; m_isStartPress = false; if (m_onLongPress != null) { m_onLongPress.Invoke(); } } } } public override void OnPointerDown(PointerEventData eventData) { base.OnPointerDown(eventData); m_curPointDownTime = Time.time; m_isStartPress = true; m_longPressTrigger = false; } public override void OnPointerUp(PointerEventData eventData) { base.OnPointerUp(eventData); m_isStartPress = false; m_longPressTrigger = false; } public override void OnPointerExit(PointerEventData eventData) { base.OnPointerExit(eventData); m_isStartPress = false; m_longPressTrigger = false; } public override void OnPointerClick(PointerEventData eventData) { //base.OnPointerClick(eventData); if (!m_longPressTrigger) { if (eventData.clickCount == 1) { onClick.Invoke(); } else if (eventData.clickCount == 2) { if (m_onDoubleClick != null) { m_onDoubleClick.Invoke(); } } } } }以上知识分享，如有错误，欢迎指出，共同学习，共同进步]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Button双击与长按</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之ScrollRect滑动居中]]></title>
    <url>%2F2017%2F07%2F16%2Funity-zhi-scrollrect-hua-dong-ju-zhong%2F</url>
    <content type="text"><![CDATA[先上效果图![这里写图片描述](https://img-blog.csdn.net/20170716183336257?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 这里同时支持水平方向和垂直方向，同时ScrollRect支持使用GridLayoutGroup、HorizontalLayoutGroup、VerticalLayoutGroup三种LayoutGroup，不过水平方向的ScrollRect不支持VerticalLayoutGroup，垂直方向的ScrollRect不支持HorizontalLayoutGroup，当然也不存在这两种情况。 由于这里是通过对ScrollRect的content的localPosition做了插值移动，因此ScrollRect的中心点设置必须跟我这保持一致。 下面直接上代码： using System; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; public enum ScrollDir { Horizontal, Vertical } public class ScrollRectCenter : MonoBehaviour , IEndDragHandler,IDragHandler,IBeginDragHandler { public ScrollDir Dir = ScrollDir.Horizontal; /// &lt;summary&gt; /// 是否正在居中 /// &lt;/summary&gt; private bool _isCentering = false; /// &lt;summary&gt; /// 居中过程移动速度 /// &lt;/summary&gt; public float MoveToCenterSpeed = 10f; private ScrollRect _scrollView; private Transform _content; private List&lt;float&gt; _childrenPos = new List&lt;float&gt;(); private float _targetPos; /// &lt;summary&gt; /// 当前中心child索引 /// &lt;/summary&gt; private int _curCenterChildIndex = -1; /// &lt;summary&gt; /// 当前中心ChildItem /// &lt;/summary&gt; public GameObject CurCenterChildItem { get { GameObject centerChild = null; if (_content != null &amp;&amp; _curCenterChildIndex &gt;= 0 &amp;&amp; _curCenterChildIndex &lt; _content.childCount) { centerChild = _content.GetChild(_curCenterChildIndex).gameObject; } return centerChild; } } void Awake() { _scrollView = GetComponent&lt;ScrollRect&gt;(); if (_scrollView == null) { Debug.LogError(&quot;ScrollRect is null&quot;); return; } _content = _scrollView.content; LayoutGroup layoutGroup = null; layoutGroup = _content.GetComponent&lt;LayoutGroup&gt;(); if (layoutGroup == null) { Debug.LogError(&quot;LayoutGroup component is null&quot;); } _scrollView.movementType = ScrollRect.MovementType.Unrestricted; float spacing = 0f; //根据dir计算坐标，Horizontal：存x，Vertical：存y switch (Dir) { case ScrollDir.Horizontal: if (layoutGroup is HorizontalLayoutGroup) { float childPosX = _scrollView.GetComponent&lt;RectTransform&gt;().rect.width * 0.5f - GetChildItemWidth(0) * 0.5f; spacing = (layoutGroup as HorizontalLayoutGroup).spacing; _childrenPos.Add(childPosX); for (int i = 1; i &lt; _content.childCount; i++) { childPosX -= GetChildItemWidth(i) * 0.5f + GetChildItemWidth(i - 1) * 0.5f + spacing; _childrenPos.Add(childPosX); } } else if (layoutGroup is GridLayoutGroup) { GridLayoutGroup grid = layoutGroup as GridLayoutGroup; float childPosX = _scrollView.GetComponent&lt;RectTransform&gt;().rect.width * 0.5f - grid.cellSize.x * 0.5f; _childrenPos.Add(childPosX); for (int i = 0; i &lt; _content.childCount - 1; i++) { childPosX -= grid.cellSize.x + grid.spacing.x; _childrenPos.Add(childPosX); } } else { Debug.LogError(&quot;Horizontal ScrollView is using VerticalLayoutGroup&quot;); } break; case ScrollDir.Vertical: if (layoutGroup is VerticalLayoutGroup) { float childPosY = -_scrollView.GetComponent&lt;RectTransform&gt;().rect.height * 0.5f + GetChildItemHeight(0) * 0.5f; spacing = (layoutGroup as VerticalLayoutGroup).spacing; _childrenPos.Add(childPosY); for (int i = 1; i &lt; _content.childCount; i++) { childPosY += GetChildItemHeight(i) * 0.5f + GetChildItemHeight(i - 1) * 0.5f + spacing; _childrenPos.Add(childPosY); } } else if (layoutGroup is GridLayoutGroup) { GridLayoutGroup grid = layoutGroup as GridLayoutGroup; float childPosY = -_scrollView.GetComponent&lt;RectTransform&gt;().rect.height * 0.5f + grid.cellSize.y * 0.5f; _childrenPos.Add(childPosY); for (int i = 1; i &lt; _content.childCount; i++) { childPosY += grid.cellSize.y + grid.spacing.y; _childrenPos.Add(childPosY); } } else { Debug.LogError(&quot;Vertical ScrollView is using HorizontalLayoutGroup&quot;); } break; } } private float GetChildItemWidth(int index) { return (_content.GetChild(index) as RectTransform).sizeDelta.x; } private float GetChildItemHeight(int index) { return (_content.GetChild(index) as RectTransform).sizeDelta.y; } void Start () { } void Update () { if (_isCentering) { Vector3 v = _content.localPosition; switch (Dir) { case ScrollDir.Horizontal: v.x = Mathf.Lerp(_content.localPosition.x, _targetPos, MoveToCenterSpeed * Time.deltaTime); _content.localPosition = v; if (Math.Abs(_content.localPosition.x - _targetPos) &lt; 0.01f) { _isCentering = false; } break; case ScrollDir.Vertical: v.y = Mathf.Lerp(_content.localPosition.y, _targetPos, MoveToCenterSpeed * Time.deltaTime); _content.localPosition = v; if (Math.Abs(_content.localPosition.y - _targetPos) &lt; 0.01f) { _isCentering = false; } break; } } } public void OnDrag(PointerEventData eventData) { } public void OnEndDrag(PointerEventData eventData) { switch (Dir) { case ScrollDir.Horizontal: _targetPos = FindClosestChildPos(_content.localPosition.x, out _curCenterChildIndex); break; case ScrollDir.Vertical: _targetPos = FindClosestChildPos(_content.localPosition.y, out _curCenterChildIndex); break; } _isCentering = true; } public void OnBeginDrag(PointerEventData eventData) { _isCentering = false; _curCenterChildIndex = -1; } private float FindClosestChildPos(float currentPos, out int curCenterChildIndex) { float closest = 0; float distance = Mathf.Infinity; curCenterChildIndex = -1; for (int i = 0; i &lt; _childrenPos.Count; i++) { float p = _childrenPos[i]; float d = Mathf.Abs(p - currentPos); if (d &lt; distance) { distance = d; closest = p; curCenterChildIndex = i; } } return closest; } }最后附上Demo下载链接：链接： http://pan.baidu.com/s/1pLoJcjL 密码：js7g链接如果失效，请及时评论，及时更新 以上知识分享，如有错误，欢迎指出，共同学习，共同进步]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
      <tags>
        <tag>ScrollRect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之粘贴板操作]]></title>
    <url>%2F2017%2F07%2F15%2Funity-zhi-nian-tie-ban-cao-zuo%2F</url>
    <content type="text"><![CDATA[Unity之粘贴板操作Untiy提供GUIUtility.systemCopyBuffer进行对粘贴板缓存数据存储与获取 官方解释为访问系统的粘贴板，可set，可get 上图![这里写图片描述](https://img-blog.csdn.net/20170715113619738?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 附上官方文档地址：[ https://docs.unity3d.com/2017.2/Documentation/ScriptReference/GUIUtility-systemCopyBuffer.html](https://docs.unity3d.com/2017.2/Documentation/ScriptReference/GUIUtility-systemCopyBuffer.html) 以上知识分享，如有错误，欢迎指出，共同学习，共同进步]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>粘贴板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之简易任务队列TaskQueue]]></title>
    <url>%2F2017%2F07%2F09%2Funity-zhi-jian-yi-ren-wu-dui-lie-taskqueue%2F</url>
    <content type="text"><![CDATA[任务队列该功能包括两个类：Task任务类，TaskQueue任务队列类其中TaskQueue负责：1、开始任务2、添加任务3、清空任务4、开始任务回调5、完成队列中所有任务回调6、下一个任务7、当前任务进度8、队列存储所有任务 其中Task类代码如下： using System; using System.Collections; using System.Collections.Generic; public class Task { //任务名 private string m_TaskName; public string TaskName { set { m_TaskName = value; } get { return m_TaskName; } } //任务具体内容，外部传入 public Action Work; public Task(Action work, string taskName = &quot;defaultTaskName&quot;) { this.Work = work; this.m_TaskName = taskName; } }TaskQueue类代码如下： using System; using System.Collections; using System.Collections.Generic; using UnityEngine; public class TaskQueue { //构造函数 public TaskQueue() { m_TaskQueue = new Queue&lt;Task&gt;(); m_TasksNum = 0; } //1、添加任务 public void AddTask(Task task) { m_TaskQueue.Enqueue(task); } public void AddTask(Action work) { Task task = new Task(work); m_TaskQueue.Enqueue(task); } //2、开始任务 public void Start() { //获取任务队列的总任务数 m_TasksNum = m_TaskQueue.Count; if (OnStart != null) { OnStart(); } NextTask(); } //3、清空任务 public void Clear() { m_TaskQueue.Clear(); m_TasksNum = 0; } //4、开始任务回调 public Action OnStart = null; //5、完成所有任务回调 public Action OnFinish = null; //6、下一个任务 private void NextTask() { if (m_TaskQueue.Count &gt; 0) { Task task = m_TaskQueue.Dequeue(); task.Work(); NextTask(); } else { if (OnFinish != null) { OnFinish(); } } } //7、当前任务进度 public float TaskProcess { get { return 1 - m_TaskQueue.Count * 1.0f / m_TasksNum; } } //8、任务队列总任务量 private int m_TasksNum = 0; //9、任务队列 private Queue&lt;Task&gt; m_TaskQueue; }然后写一个test脚本挂在相机上，测试前面的代码： using System.Collections; using System.Collections.Generic; using UnityEngine; public class Test : MonoBehaviour { void Start () { TaskQueue taskQueue = new TaskQueue(); taskQueue.OnStart = () =&gt; { Debug.Log(&quot;OnStart&quot;); }; taskQueue.OnFinish = () =&gt; { Debug.Log(&quot;OnFinish&quot;); }; taskQueue.AddTask(Task1); taskQueue.AddTask(Task2); taskQueue.Start(); } private void Task1() { Debug.Log(&quot;Task1&quot;); } private void Task2() { Debug.Log(&quot;Task2&quot;); } }执行结果如下图：![这里写图片描述](https://img-blog.csdn.net/20170709182839383?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 该任务队列写的比较简单，后期会拓展，敬请期待。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>TaskQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之NetworkReachability描述网络可达性选项。]]></title>
    <url>%2F2017%2F07%2F06%2Funity-zhi-networkreachability-miao-shu-wang-luo-ke-da-xing-xuan-xiang%2F</url>
    <content type="text"><![CDATA[Unity自带一个枚举NetworkReachability，用来描述网络可达性NotReachable：网络无法访问ReachableViaCarrierDataNetwork：通过运营商数据网络可以访问网络ReachableViaLocalAreaNetwork：网络通过WIFI或电缆可达 附上Unity官方文档地址： https://docs.unity3d.com/ScriptReference/NetworkReachability.html 截图如下：![这里写图片描述](https://img-blog.csdn.net/20170706125329699?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>NetworkReachability</tag>
        <tag>网络可达性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之使用IOS 3DTouch功能]]></title>
    <url>%2F2017%2F04%2F26%2Funity-zhi-shi-yong-ios-3dtouch-gong-neng%2F</url>
    <content type="text"><![CDATA[Unity工程在IOS平台使用3DTouch功能，提供了以下接口：（1）Input.touchPressureSupported：是否支持3Dtouch，bool类型（2）Touch.pressure：获取当前按压值，float类型（3）Touch.maximumPossiblePressure：获取最大按压值，float类型 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>3D Touch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之DOTweenPath轨迹移动]]></title>
    <url>%2F2017%2F04%2F26%2Funity-zhi-dotweenpath-gui-ji-yi-dong%2F</url>
    <content type="text"><![CDATA[先简单介绍一下DOTweenPath。 先来看一下DOTweenPath组件的截图 ![这里写图片描述](https://img-blog.csdn.net/20170426150708706?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 1、Scene View Commands（1）SHIFT+CTRL：add a waypoint加一个轨迹点（2）SHIFT+ALT：remove a waypoint移除一个轨迹点 2、INfo（1）Path Length：轨迹长度 3、Tween Options（1）AutoPlay：自动播放（2）AutoKill：播放完自动销毁动画（3）Duration：动画时长SpeedBased：If selected ,the duration will count as units/degreexsecond;如果被选上，该时间作为单位时间。 （4）Delay：延时（5）Ease：这是一个枚举，可以理解为动画播放速率曲线![这里写图片描述](https://img-blog.csdn.net/20170426152601405?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 相关网址： http://dotween.demigiant.com/documentation.php 以及： http://robertpenner.com/easing/easing_demo.html （6）Loops：循环次数，动画循环播放的次数-1：表示 一直循环0：表示只播放一次当该值&gt;1时，检视面板出现LoopType，顾名思义就是指循环类型：Restart：重新开始，后面的动画循环播放会从起点重新开始；Yoyo：来回播放Incremental：增加的，后面的path移动动画会在上一次循环的终点的基础上进行播放 （7）ID：动画ID（8）UpdateType：这个枚举有三个值，指更新类型Normal：正常更新，Update()Late：晚于更新，LateUpdate()Fixed：固定更新，FixedUpdate() 4、Path Tween Options（1）Path Type：轨迹线类型Linear：线型的Catmull Rom：曲线（2）Close Path：封闭曲线，将起点和终点相连（3）Lock Rotation：锁旋转，xyzw 5、Path Editor Options：轨迹编辑参数，就不介绍了 6、ResetPath：重置轨迹7、Events：（1）OnStart：开始时（2）OnPlay：播放时（3）OnUpdate：更新时（4）OnStep：单步完成时（5）OnComplete：完成时（6）OnCreated：动画创建时事件顺序为：OnCreated-&gt;OnStart-&gt;OnPlay-&gt;OnUpdate（一直执行，直到完成），动画过程中单步完成时执行OnStep，整个动画完成后执行OnComplete 8、WayPoints：移动轨迹点其中右边的Copy to clipboard，将坐标复制至剪贴板![这里写图片描述](https://img-blog.csdn.net/20170426160635797?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)加减按钮即指增加减少坐标点 以上便是对于DOTweenPath组件的一个基本介绍。 接下来，DOTween对于轨迹移动提供的接口：（1）DOPath：![这里写图片描述](https://img-blog.csdn.net/20170426162319897?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)（2）DOLocalPath![这里写图片描述](https://img-blog.csdn.net/20170426162640305?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 以上两个函数的参数再上面已经介绍过，这里就不再重复说明了。 DOTween插件，大家请自行下载。]]></content>
      <categories>
        <category>Unity</category>
        <category>DOTween</category>
      </categories>
      <tags>
        <tag>DOTweenPath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之MessageBox]]></title>
    <url>%2F2017%2F04%2F25%2Funity-zhi-messagebox%2F</url>
    <content type="text"><![CDATA[先上示意图：![这里写图片描述](https://img-blog.csdn.net/20170425112628114?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 从图中可以看出，这是标准的MessageBox样式。我采用的是UGUI，中间是文字内容，下面包括确定取消两个按钮，右上角一个关闭按钮。 那么模仿MFC呢，我写了一个枚举如下： public enum MessageType { Confirm, //确定 Cancel, //取消 ConfirmCancel, //确定取消 Yes, //是 No, //否 YesNO, //是否 }从上可以看出，这是在定义按钮的样式，举例：Confirm指仅包括确定按钮。 接下来，直接上挂在该UI上的脚本代码： using System; using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; public class MessageBoxDialog : MonoBehaviour { public GameObject CancelButton = null; //取消按钮 public GameObject ConfirmButton = null; //确定按钮 public GameObject CloseButton = null; //关闭按钮 public Text MessageText = null; //提示文字 public Text ConfirmText = null; //确定文字 public Text CancelText = null; //取消文字 public Action OnCloseEvent = null; public Action OnConfirmEvent = null; // Use this for initialization void Start() { AddListener(); } // Update is called once per frame void Update() { } private void AddListener() { if (CancelButton != null) { EventTriggerListener.Get(CancelButton).onClick = OnCancelButtonClicked; } if (ConfirmButton != null) { EventTriggerListener.Get(ConfirmButton).onClick = OnConfirmButtonClicked; } } private void OnConfirmButtonClicked(GameObject go, BaseEventData eventData) { if (OnConfirmEvent != null) { OnConfirmEvent(); } else { OnCloseButtonClicked(null, null); } } private void OnCancelButtonClicked(GameObject go, BaseEventData eventData) { if (OnCloseEvent != null) { OnCloseEvent(); } else { OnCloseButtonClicked(null, null); } } private void OnCloseButtonClicked(GameObject go, BaseEventData eventData) { GameObject.DestroyImmediate(gameObject); } public void UpdateButton(MessageType type) { switch (type) { case MessageType.ConfirmCancel: break; case MessageType.Cancel: ConfirmButton.SetActive(false); break; case MessageType.Confirm: CancelButton.SetActive(false); break; case MessageType.No: ConfirmButton.SetActive(false); CancelText.text = &quot;否&quot;; break; case MessageType.Yes: CancelButton.SetActive(false); ConfirmText.text = &quot;是&quot;; break; case MessageType.YesNO: ConfirmText.text = &quot;是&quot;; CancelText.text = &quot;否&quot;; break; } } }接下来是该篇文章的重点代码了， using System; using UnityEngine; public class MessageBox { private static GameObject _messageBoxPrefab = null; private static GameObject _messageBox = null; private static string _messageBoxPrefabPath = &quot;UI/MessageBox&quot;; public static void Show(string info, MessageType type = MessageType.ConfirmCancel, Action cancelCallback = null, Action confirmCallback = null) { if (_messageBoxPrefab == null) { _messageBoxPrefab = Resources.Load(_messageBoxPrefabPath) as GameObject; } _messageBox = GameObject.Instantiate(_messageBoxPrefab) as GameObject; MessageBoxDialog msgbox = _messageBox.GetComponent&lt;MessageBoxDialog&gt;(); msgbox.UpdateButton(type); msgbox.OnConfirmEvent += confirmCallback; msgbox.OnCloseEvent += cancelCallback; msgbox.MessageText.text = info; //以下是在自己的场景管理的基础上写的，既然这里还没讲到我的场景管理，就暂时用比较low的方法了 //GameObject uiRoot = ScenesManager.Instance.CurScene.UiRoot.gameObject; //_messageBox.transform.SetParent(uiRoot.transform, false); GameObject canvas = GameObject.Find(&quot;Canvas&quot;); if(canvas != null) { _messageBox.transform.SetParent(canvas.transform, false); } } }该段代码中，大家应该注意到三点：1、MessageBox的预制件路径，修改为自己的路径；2、加载该预制件的方法，我用的是Resources.Load，这里并没有将我的资源管理介绍出来，所以就用的这个；3、实例化该UI，给该UI赋父物体的时候，用的是比较low的方法，注释已经解释了。 接下来，就直接上工程了，大家 如有疑问，请留言。链接： http://pan.baidu.com/s/1kVibxQJ 密码：45ql 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>MessageBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua]]></title>
    <url>%2F2017%2F04%2F25%2Flua%2F</url>
    <content type="text"><![CDATA[两个连字符（–）在Lua中表示开始一条注释 Lua定义一个计算阶乘的函数：–定义一个阶乘函数function fact(n)if n == 0 thenreturn 1elsereturn n * fact(n-1)endend –打印print(“Hello World”) –读取一个数字a = io.read(“*number”) Lua执行的 每段代码，例如一个源代码文件或在交互模式中输入的一行代码，都称为一个“程序块”，一个程序块也就是一连串的语句或命令。 几条连续的Lua语句之间并不需要分隔符，但也可以使用分号来分割语句。代码中的换行不起任何作用a = 1 b=a*2 –有点难看，但是合法 程序块可以是任意大小 语法规范Lua的标识符可以是任意字母、数字和下画线构成的字符串，但不能以数字开头 Lua的保留字：and break do else elseifend false for function ifin local nil not orrepeat return then true unitlwhile Lua 是有大小写之分的 Lua注释：可以在任何地方以两个连字符（–）开始一个“行注释”，该注释一直延伸到一行的结尾。Lua也提供了“块注释”，以“–[[”开始，直至“–]]”，如果块注释包含的“–]]”并非是注释结尾，例如下面的例子 --[[ function fact(n) if n == 0 then return 1 else return n * fact(n - 1) end end --]] print(&quot;enter a number:&quot;) --打印 a = io.read(&quot;*number&quot;) --读取一个数字 print(fact(a)) --]]如果代码中的第一个“–]]”并非是想要的块注释结尾，那么就改为以下依然合法 --[=[ function fact(n) if n == 0 then return 1 else return n * fact(n - 1) end end --]] print(&quot;enter a number:&quot;) --打印 a = io.read(&quot;*number&quot;) --读取一个数字 print(fact(a)) --]=]Lua全局变量：全局变量不需要声明。只需要将一个值赋予一个全局变量就可以创建了。在Lua中，访问一个未初始化的变量不会引发错误，访问结果是一个特殊的值nil。 print(a) --nil a=10 print(a) --10删除一个全局变量，只需要将其赋值为nil Lua类型与值：Lua是一种动态类型的语言。在语言中没有类型定义的语法，每个值都“携带”了它本身的类型信息。在Lua中有8种基础类型：nil（空），boolean（布尔），number（数字），string（字符串），userdata（自定义类型），function（函数），thread（线程），table（表）。函数type可根据一个值返回其类型名称。 print(type(&quot;Hello world&quot;)) --string print(type(10.4 * 3)) --number print(type(print)) --function print(type(type)) --function print(type(true)) --boolean print(type(nil)) --nil print(type(type(X))) --string最后一行将永远返回“string”，而无关乎X这个值的内容，这是因为type函数总是返回一个字符串。 变量没有预定义的类型，任何变量都可以包含任何类型的值： print(type(a)) --nil a = 10 print(type(a)) --number a = &quot;a string&quot; print(type(a)) --string a = print a(type(a)) --function将一个变量用于不同类型，通常会导致代码混乱，但有时明智地使用这种特性会带来便利。 nil（空）nil是一种类型，只有一个值nil，它的主要功能是用于区别其他任何值。一个全局变量在第一次赋值前的默认值就是nil，将nil赋予一个全局变量等同于删除它。Lua将nil用于表示一种无效值的情况，也就是没有任何有效值的情况。 boolean（布尔）boolean类型有两个可选值：false和true，在Lua中任何值都可以表示一个条件。Lua将false和nil视为假，其他值全为真，Lua在条件测试中，将数字零和空字符串也都视为真 number（数字）number类型用于表示双精度浮点数，支持科学计数法：0.3e12 string（字符串）Lua中的字符串通常表示“一个字符序列”。可以将任意二进制数据存储到一个字符串中。Lua的字符串是不可变的值，不能直接修改字符串的某个字符，而是根据修改要求来创建一个新的字符串。 a=&quot;Hello world&quot; b=string.gsub(a,&quot;world&quot;,&quot;lua&quot;) --修改字符串的一部分 c=string.gsub(a,&quot;o&quot;,&quot;c&quot;) print(a) --Hello world print(b) --Hello lua print(c) --Hellc wcrldstring的gsub函数修改所有匹配到的子串。Lua的字符串和其他Lua对象一样，都是自动内存管理机制所管理的对象。以一对匹配的单引号或者双引号来界定字符串，根据编程风格，应该坚持在程序中使用相同类型的引号，如果字符串本身包含引号，那么使用转义序列 ![这里写图片描述](https://img-blog.csdn.net/20170313192419753?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)Lua字符串中的转义序列 还可以通过数值来指定字符串中的字符，数值以转义序列“\”给出，其中是一个至多3个十进制数字组成的序列。例如：“alo\n123\””与字符串”\97lo\10\04923”是相同的，在ASCII中，’a’的ASCII编码是97，换行是10，’1’的编码是49.这里必须将49写成三个数字049，不然Lua会读取到数值492. 另外，可以用一对匹配的双方括号来界定一个字母字符串，就像写“块注释”那样，不过Lua不会解释其中的转义序列，并且会忽略第一个字符是换行字符的部分，这种写法对于书写那种含有程序代码的字符串尤为有用。 page=[[ &lt;html&gt; &lt;head&gt; &lt;title&gt;an html page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;http://www.lua.org&quot;&gt;lua&lt;/a&gt; &lt;/body&gt; &lt;/html&gt;]] print(page) print(type(page)) --stringLua提供了运行时的数字与字符串的自动转换。在一个字符串上应用算术操作时，Lua会尝试将这个字符串转换成一个数字: print(&quot;10&quot; + 1) --11 print(&quot;10+1&quot;) --10+1 print(&quot;hello&quot; + 1) --报错，不能将string字符串转换成一个数字在Lua期望一个字符串但却得到一个数字时，它也会将数字转换成字符串： a=10 .. 20 print(10 .. 20) --1020 print(a) --1020 print(type(a)) --string在Lua中，“..”是字符串连接操作符，记得该操作符与数字之间必须要用空格来分隔，不然Lua会将第一个点理解为一个小数点。]]></content>
      <categories>
        <category>Lua</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Unity之事件机制]]></title>
    <url>%2F2016%2F12%2F29%2Funity-zhi-shi-jian-ji-zhi%2F</url>
    <content type="text"><![CDATA[事件机制主要用于模块之间解耦和，事件机制将各个模块联系在一起，并且它们之间的耦合性非常低，特别适用于游戏产品的模块化开发。事件的类型可以通过枚举的形式来表示。事件机制的实现原理是将表示不同事件的枚举与其对应的回调函数通过AddListener函数加到定义好的表中，触发回调函数通过notify函数对已定义的事件枚举进行分类分发，从发触发已加载到内存的事件回调函数。等开发者不需要监听事件可通过RemoveListener函数移除监听即可。 下面给出一个Demo的UnityPackage的链接：链接： http://pan.baidu.com/s/1c1LOD4O 密码：y4fv 链接如有失效，联系博主及时更新。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>事件机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之私人订制Debug]]></title>
    <url>%2F2016%2F12%2F14%2Funity-zhi-si-ren-ding-zhi-debug%2F</url>
    <content type="text"><![CDATA[其实原理很简单，这里用到的是富文本的知识，也许大家会觉得这种low定制反而显得麻烦了，那就直接跳过。。。 直接上代码： using UnityEngine; using System.Collections; using System; using System.Text; namespace Scripts.CoreScripts.Core.Helper { public class Debugger { /// &lt;summary&gt; /// 是否开启Debugger /// &lt;/summary&gt; static public bool Enable = true; /// &lt;summary&gt; /// 默认错误颜色：红色 /// &lt;/summary&gt; static public string ErrorColor = &quot;red&quot;; /// &lt;summary&gt; /// 默认警告颜色：黄色 /// &lt;/summary&gt; static public string WarningColor = &quot;yellow&quot;; /// &lt;summary&gt; /// 默认输出颜色：白色 /// &lt;/summary&gt; static public string LogColor = &quot;white&quot;; /// &lt;summary&gt; /// 默认字号：20 /// &lt;/summary&gt; static public int FontSize = 20; /// &lt;summary&gt; /// 默认颜色，默认字号输出 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt; static public void Log(object message) { if (Enable) { Debug.Log(&quot;&lt;color=&quot; + LogColor + &quot;&gt;&quot; + &quot;&lt;size=&quot; + FontSize + &quot;&gt;&quot; + message + &quot;&lt;/size&gt;&quot; + &quot;&lt;/color&gt;&quot;); } } /// &lt;summary&gt; /// 默认颜色，默认字号输出 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt; /// &lt;param name=&quot;context&quot;&gt;连接上下文&lt;/param&gt; static public void Log(object message, UnityEngine.Object context) { if (Enable) { Debug.Log(&quot;&lt;color=&quot; + LogColor + &quot;&gt;&quot; + &quot;&lt;size=&quot; + FontSize + &quot;&gt;&quot; + message + &quot;&lt;/size&gt;&quot; + &quot;&lt;/color&gt;&quot;, context); } } /// &lt;summary&gt; /// 自定义颜色输出 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt; /// &lt;param name=&quot;color&quot;&gt;颜色&lt;/param&gt; static public void Log(object message, Color32 color) { if (Enable) { Debug.Log(&quot;&lt;color=&quot; + FormatColor32(color) + &quot;&gt;&quot; + message + &quot;&lt;/color&gt;&quot;); } } /// &lt;summary&gt; /// 自定义颜色、默认字号输出 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt; /// &lt;param name=&quot;color&quot;&gt;颜色&lt;/param&gt; /// &lt;param name=&quot;context&quot;&gt;连接上下文&lt;/param&gt; static public void Log(object message, Color32 color, UnityEngine.Object context) { if (Enable) { Debug.Log(&quot;&lt;color=&quot; + FormatColor32(color) + &quot;&gt;&quot; + &quot;&lt;size=&quot; + FontSize + &quot;&gt;&quot; + message + &quot;&lt;/size&gt;&quot; + &quot;&lt;/color&gt;&quot;, context); } } /// &lt;summary&gt; /// 自定义字号输出 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt; /// &lt;param name=&quot;fontSize&quot;&gt;字号大小，汉字上限26，大写英文上限30，小写英文上限25，仅供参考&lt;/param&gt; static public void Log(object message, int fontSize) { if (Enable) { Debug.Log(&quot;&lt;color=&quot; + LogColor + &quot;&gt;&quot; + &quot;&lt;size=&quot; + FontSize + &quot;&gt;&quot; + message + &quot;&lt;/size&gt;&quot; + &quot;&lt;/color&gt;&quot;); } } /// &lt;summary&gt; /// 自定义字号输出 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt; /// &lt;param name=&quot;fontSize&quot;&gt;字号&lt;/param&gt; /// &lt;param name=&quot;context&quot;&gt;连接上下文&lt;/param&gt; static public void Log(object message, int fontSize, UnityEngine.Object context) { if (Enable) { Debug.Log(&quot;&lt;size=&quot; + fontSize + &quot;&gt;&quot; + message + &quot;&lt;/size&gt;&quot;, context); } } /// &lt;summary&gt; /// 自定义字号、颜色输出 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt; /// &lt;param name=&quot;color&quot;&gt;颜色&lt;/param&gt; /// &lt;param name=&quot;fontsize&quot;&gt;字号&lt;/param&gt; static public void Log(object message, Color32 color, int fontsize) { if (Enable) { Debug.Log(&quot;&lt;color=&quot; + FormatColor32(color) + &quot;&gt;&quot; + &quot;&lt;size=&quot; + fontsize + &quot;&gt;&quot; + message + &quot;&lt;/size&gt;&quot; + &quot;&lt;/color&gt;&quot;); } } /// &lt;summary&gt; /// 自定义字号、颜色输出 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt; /// &lt;param name=&quot;color&quot;&gt;颜色&lt;/param&gt; /// &lt;param name=&quot;fontSize&quot;&gt;字号&lt;/param&gt; /// &lt;param name=&quot;context&quot;&gt;连接上下文&lt;/param&gt; static public void Log(object message, Color32 color, int fontSize, UnityEngine.Object context) { if (Enable) { Debug.Log(&quot;&lt;color=&quot; + FormatColor32(color) + &quot;&gt;&quot; + &quot;&lt;size=&quot; + fontSize + &quot;&gt;&quot; + message + &quot;&lt;/size&gt;&quot; + &quot;&lt;/color&gt;&quot;, context); } } static public void LogWarning(object message) { if (Enable) { Debug.LogWarning(&quot;&lt;color=&quot; + WarningColor + &quot;&gt;&quot; + message + &quot;&lt;/color&gt;&quot;); } } static public void LogWarning(object message, UnityEngine.Object context) { if (Enable) { Debug.LogWarning(&quot;&lt;color=&quot; + WarningColor + &quot;&gt;&quot; + message + &quot;&lt;/color&gt;&quot;, context); } } static public void LogError(object message) { if (Enable) { Debug.LogError(&quot;&lt;color=&quot; + ErrorColor + &quot;&gt;&quot; + message + &quot;&lt;/color&gt;&quot;); } } static public void LogError(object message, UnityEngine.Object context) { if (Enable) { Debug.LogError(&quot;&lt;color=&quot; + ErrorColor + &quot;&gt;&quot; + message + &quot;&lt;/color&gt;&quot;, context); } } /// &lt;summary&gt; /// 将Color32转换为#FFFFFFFF格式 /// &lt;/summary&gt; /// &lt;param name=&quot;color&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static private string FormatColor32(Color32 color) { StringBuilder sb = new StringBuilder(); sb.Append(&quot;#&quot;); sb.Append(color.r.ToString(&quot;x2&quot;)); sb.Append(color.g.ToString(&quot;x2&quot;)); sb.Append(color.b.ToString(&quot;x2&quot;)); sb.Append(color.a.ToString(&quot;x2&quot;)); return sb.ToString(); } } }以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>订制Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之Vector3D：重现Vector3]]></title>
    <url>%2F2016%2F12%2F13%2Funity-zhi-vector3d-chong-xian-vector3%2F</url>
    <content type="text"><![CDATA[直接上代码 using System; using System.Text; using UnityEngine; public class Vector3D { public static Vector3D back { get { return new Vector3D(0, 0, -1); } } public static Vector3D down { get { return new Vector3D(0, -1, 0); } } public static Vector3D forward { get { return new Vector3D(0, 0, 1); } } public static Vector3D left { get { return new Vector3D(-1, 0, 0); } } public static Vector3D right { get { return new Vector3D(1, 0, 0); } } public static Vector3D up { get { return new Vector3D(0, 1, 0); } } public static Vector3D one { get { return new Vector3D(1, 1, 1); } } public static Vector3D zero { get { return new Vector3D(0, 0, 0); } } /// &lt;summary&gt; /// 向量的长度 /// &lt;/summary&gt; public float magnitude { get { return (float)Math.Sqrt(sqrMagnitudfe); } } /// &lt;summary&gt; /// 向量的的长度的平方 /// &lt;/summary&gt; public float sqrMagnitudfe { get { return x * x + y * y + z * z; } } /// &lt;summary&gt; /// 规范化 /// &lt;/summary&gt; public Vector3D normalized { get { if (IsZero) { return Vector3D.zero; } else { Vector3D v = new Vector3D(); float length = magnitude; v.x = this.x / length; v.y = this.y / length; v.z = this.z / length; return v; } } } /// &lt;summary&gt; /// 是否是零向量 /// &lt;/summary&gt; public bool IsZero { get { return this.x == 0 &amp;&amp; this.y == 0 &amp;&amp; this.z == 0; } } #region 操作符重载 /// &lt;summary&gt; /// 两个向量相加 /// &lt;/summary&gt; /// &lt;param name=&quot;a&quot;&gt;向量a&lt;/param&gt; /// &lt;param name=&quot;b&quot;&gt;向量b&lt;/param&gt; /// &lt;returns&gt;两个向量的和&lt;/returns&gt; public static Vector3D operator +(Vector3D a,Vector3D b) { return new Vector3D(a.x + b.x, a.y + b.y, a.z + b.z); } /// &lt;summary&gt; /// 两个向量相减 /// &lt;/summary&gt; /// &lt;param name=&quot;a&quot;&gt;向量a&lt;/param&gt; /// &lt;param name=&quot;b&quot;&gt;向量b&lt;/param&gt; /// &lt;returns&gt;两个向量的差&lt;/returns&gt; public static Vector3D operator -(Vector3D a,Vector3D b) { return new Vector3D(a.x - b.x, a.y - b.y, a.z - b.z); } /// &lt;summary&gt; /// 向量取反 /// &lt;/summary&gt; /// &lt;param name=&quot;a&quot;&gt;向量a&lt;/param&gt; /// &lt;returns&gt;向量a的反向量&lt;/returns&gt; public static Vector3D operator -(Vector3D a) { return new Vector3D(-a.x, -a.y, -a.z); } /// &lt;summary&gt; /// 一个数乘以一个向量 /// &lt;/summary&gt; /// &lt;param name=&quot;d&quot;&gt;一个数&lt;/param&gt; /// &lt;param name=&quot;a&quot;&gt;一个向量&lt;/param&gt; /// &lt;returns&gt;返回数与向量的乘积&lt;/returns&gt; public static Vector3D operator *(float d, Vector3D a) { return new Vector3D(a.x * d, a.y * d, a.z * d); } /// &lt;summary&gt; /// 一个向量乘以一个数 /// &lt;/summary&gt; /// &lt;param name=&quot;a&quot;&gt;一个向量&lt;/param&gt; /// &lt;param name=&quot;d&quot;&gt;一个数&lt;/param&gt; /// &lt;returns&gt;返回向量与数的乘积&lt;/returns&gt; public static Vector3D operator *(Vector3D a, float d) { return new Vector3D(a.x * d, a.y * d, a.z * d); } /// &lt;summary&gt; /// 一个数除一个向量，向量a/数b /// &lt;/summary&gt; /// &lt;param name=&quot;a&quot;&gt;一个向量&lt;/param&gt; /// &lt;param name=&quot;d&quot;&gt;一个数&lt;/param&gt; /// &lt;returns&gt;返回向量a/d&lt;/returns&gt; public static Vector3D operator /(Vector3D a,float d) { return new Vector3D(a.x / d, a.y / d, a.z / d); } /// &lt;summary&gt; /// 两个向量是否相等 /// &lt;/summary&gt; /// &lt;param name=&quot;lhs&quot;&gt;向量lhs&lt;/param&gt; /// &lt;param name=&quot;rhs&quot;&gt;向量rhs&lt;/param&gt; /// &lt;returns&gt;如果相等，则为true，否则为false&lt;/returns&gt; public static bool operator ==(Vector3D lhs, Vector3D rhs) { bool x = Math.Abs(lhs.x - rhs.x) &lt; 0.00001f; bool y = Math.Abs(lhs.y - rhs.y) &lt; 0.00001f; bool z = Math.Abs(lhs.z - rhs.z) &lt; 0.00001f; return x &amp;&amp; y &amp;&amp; z; } /// &lt;summary&gt; /// 两个向量是否不等 /// &lt;/summary&gt; /// &lt;param name=&quot;lhs&quot;&gt;向量lhs&lt;/param&gt; /// &lt;param name=&quot;rhs&quot;&gt;向量rhs&lt;/param&gt; /// &lt;returns&gt;如果不等，则为true，否则为false&lt;/returns&gt; public static bool operator !=(Vector3D lhs, Vector3D rhs) { return !(lhs == rhs); } #endregion public float x; public float y; public float z; private float[] data = new float[3]; #region 构造器 public Vector3D() { this.x = 0.0f; this.y = 0.0f; this.z = 0.0f; data[0] = 0.0f; data[1] = 0.0f; data[2] = 0.0f; } public Vector3D(float x, float y) { this.x = x; this.y = y; this.z = 1.0f; data[0] = 0.0f; data[1] = 0.0f; data[2] = 1.0f; } public Vector3D(float x, float y, float z) { this.x = x; this.y = y; this.z = z; data[0] = x; data[1] = y; data[2] = z; } #endregion public float this[int index] { get { switch (index) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Exception(&quot;index is out of array&quot;); } } set { data[index] = value; switch (index) { case 0: this.x = value; break; case 1: this.y = value; break; case 2: this.z = value; break; default: break; } } } public override string ToString() { StringBuilder sb = new StringBuilder(); sb.Append(&quot;(&quot;); sb.Append(this.x); sb.Append(&quot;,&quot;); sb.Append(this.y); sb.Append(&quot;,&quot;); sb.Append(this.z); sb.Append(&quot;)&quot;); return sb.ToString(); } public void Set(float new_x, float new_y, float new_z) { this.x = new_x; this.y = new_y; this.z = new_z; data[0] = new_x; data[1] = new_y; data[2] = new_z; } /// &lt;summary&gt; /// 规范化，使向量长度为1 /// &lt;/summary&gt; public void Normalize() { if (!IsZero) { this.x /= magnitude; this.y /= magnitude; this.z /= magnitude; } } #region 静态函数 /// &lt;summary&gt; /// 距离 /// &lt;/summary&gt; /// &lt;param name=&quot;a&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;b&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;返回a和b之间的距离&lt;/returns&gt; public static float Distance(Vector3D a, Vector3D b) { return (float)Math.Sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z)); } /// &lt;summary&gt; /// 计算两个向量的点乘积 /// &lt;/summary&gt; /// &lt;param name=&quot;lhs&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;rhs&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static float Dot(Vector3D lhs, Vector3D rhs) { return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z; } /// &lt;summary&gt; /// 计算两个向量的叉乘 /// &lt;/summary&gt; /// &lt;param name=&quot;v1&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;v2&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Vector3D Cross(Vector3D v1, Vector3D v2) { float x = v1.y * v2.z - v2.y * v1.z; float y = v1.z * v2.x - v2.z * v1.x; float z = v1.x * v2.y - v2.x * v1.y; return new Vector3D(x, y, z); } /// &lt;summary&gt; /// 限制长度 /// &lt;/summary&gt; /// &lt;param name=&quot;v&quot;&gt;向量v&lt;/param&gt; /// &lt;param name=&quot;maxLength&quot;&gt;最长长度&lt;/param&gt; /// &lt;returns&gt;返回限制长度后的向量&lt;/returns&gt; public static Vector3D ClampMagnitude(Vector3D v,float maxLength) { if (maxLength &gt;= v.magnitude) { return v; } return (maxLength / v.magnitude) * v; } /// &lt;summary&gt; /// 计算两个向量的夹角 /// &lt;/summary&gt; /// &lt;param name=&quot;from&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;to&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static float Angle(Vector3D from,Vector3D to) { float dot = Dot(from, to); return (float)(180 * Math.Acos(dot / (from.magnitude * to.magnitude)) / Math.PI); } /// &lt;summary&gt; /// 投射一个向量到另一个向量 /// &lt;/summary&gt; /// &lt;param name=&quot;vector&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;onNormal&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;返回被投射到onNormal的vector&lt;/returns&gt; public static Vector3D Project(Vector3D vector, Vector3D onNormal) { if (vector.IsZero || onNormal == Vector3D.zero) { return Vector3D.zero; } return Dot(vector, onNormal) / (onNormal.magnitude * onNormal.magnitude) * onNormal; } /// &lt;summary&gt; /// 反射 /// &lt;/summary&gt; /// &lt;param name=&quot;inDirection&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;inNormal&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Vector3D Reflect(Vector3D inDirection,Vector3D inNormal) { return Vector3D.zero; } /// &lt;summary&gt; /// 缩放 /// &lt;/summary&gt; /// &lt;param name=&quot;scale&quot;&gt;&lt;/param&gt; public void Scale(Vector3D scale) { this.x *= scale.x; this.y *= scale.y; this.z *= scale.z; } /// &lt;summary&gt; /// 缩放 /// &lt;/summary&gt; /// &lt;param name=&quot;a&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;b&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Vector3D Scale(Vector3D a,Vector3D b) { return new Vector3D(a.x * b.x, a.y * b.y, a.z * b.z); } /// &lt;summary&gt; /// 两个向量是否平行 /// &lt;/summary&gt; /// &lt;param name=&quot;a&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;b&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool Parallel(Vector3D a, Vector3D b) { return Cross(a,b).IsZero; } /// &lt;summary&gt; /// 两个向量之间的线性插值 /// &lt;/summary&gt; /// &lt;param name=&quot;from&quot;&gt;向量from&lt;/param&gt; /// &lt;param name=&quot;to&quot;&gt;向量to&lt;/param&gt; /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Vector3D Lerp(Vector3D from, Vector3D to, float t) { if (t &lt;= 0) { return from; } else if (t &gt;= 1) { return to; } return t * to + (1 - t) * from; } /// &lt;summary&gt; /// 两个向量的球形插值 /// &lt;/summary&gt; /// &lt;param name=&quot;a&quot;&gt;向量a&lt;/param&gt; /// &lt;param name=&quot;b&quot;&gt;向量b&lt;/param&gt; /// &lt;param name=&quot;t&quot;&gt;t的值在[0..1]&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Vector3D Slerp(Vector3D a, Vector3D b, float t) { if (t &lt;= 0) { return a; } else if (t &gt;= 1) { return b; } Vector3D v = RotateTo(a, b, Vector3D.Angle(a, b) * t); //向量的长度，跟线性插值一样计算 float length = b.magnitude * t + a.magnitude * (1 - t); return v.normalized * length; } /// &lt;summary&gt; /// 将向量from向向量to旋转角度angle /// &lt;/summary&gt; /// &lt;param name=&quot;from&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;to&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;angle&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Vector3D RotateTo(Vector3D from, Vector3D to, float angle) { //如果两向量角度为0 if (Vector3D.Angle(from, to) == 0) { return from; } //旋转轴 Vector3D n = Vector3D.Cross(from, to); n.Normalize(); //旋转矩阵 Matrix4x4 rotateMatrix = new Matrix4x4(); //旋转的弧度 double radian = angle * Math.PI / 180; float cosAngle = (float)Math.Cos(radian); float sinAngle = (float)Math.Sin(radian); rotateMatrix.SetRow(0, new Vector4(n.x * n.x * (1 - cosAngle) + cosAngle, n.x * n.y * (1 - cosAngle) + n.z * sinAngle, n.x * n.z * (1 - cosAngle) - n.y * sinAngle, 0)); rotateMatrix.SetRow(1, new Vector4(n.x * n.y * (1 - cosAngle) - n.z * sinAngle, n.y * n.y * (1 - cosAngle) + cosAngle, n.y * n.z * (1 - cosAngle) + n.x * sinAngle, 0)); rotateMatrix.SetRow(2, new Vector4(n.x * n.z * (1 - cosAngle) + n.y * sinAngle, n.y * n.z * (1 - cosAngle) - n.x * sinAngle, n.z * n.z * (1 - cosAngle) + cosAngle, 0)); rotateMatrix.SetRow(3, new Vector4(0, 0, 0, 1)); Vector4 v = Vector3D.ToVector4(from); Vector3D vector = new Vector3D(); for (int i = 0; i &lt; 3; ++i) { for (int j = 0; j &lt; 3; j++) { vector[i] += v[j] * rotateMatrix[j, i]; } } return vector; } /// &lt;summary&gt; /// 将一个Vector3D转换为Vector4 /// &lt;/summary&gt; /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Vector4 ToVector4(Vector3D v) { return new Vector4(v.x, v.y, v.z, 0); } public Vector3 ToVector3() { return new Vector3(x, y, z); } #endregion }以上代码只是自己在学习过程中一点成果，希望对大家有帮助，当然跟Vector3比起来肯定差很多。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Vector3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity之Vector3.Lerp线性插值原理介绍]]></title>
    <url>%2F2016%2F12%2F13%2Funity-zhi-vector3.lerp-xian-xing-cha-zhi-yuan-li-jie-shao%2F</url>
    <content type="text"><![CDATA[先看下面这个图：![这里写图片描述](https://img-blog.csdn.net/20161213114512329?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 画的比较潦草，大家将就看。。。 向量from 和 向量to在xy平面上，其实这并不影响讲解插值原理。 图中可以看出当t=0.5f时，插值向量就是中间那个向量，其x轴分量的计算图中已经给出了，y轴也同理，z轴也一样。。 下面看下函数：public static Vector3 Lerp(Vector3 a, Vector3 b, float t); 其中a就是图中的from向量，b就是to向量。t是夹在 [0…1]之间，当t = 0时，返回from，当t = 1时，返回to。当t = 0.5 返回from和to的平均数 所以具体实现代码如下： /// &lt;summary&gt; /// 两个向量之间的线性插值 /// &lt;/summary&gt; /// &lt;param name=&quot;from&quot;&gt;向量from&lt;/param&gt; /// &lt;param name=&quot;to&quot;&gt;向量to&lt;/param&gt; /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Vector3D Lerp(Vector3D from, Vector3D to, float t) { if (t &lt;= 0) { return from; } else if (t &gt;= 1) { return to; } return t * to + (1 - t) * from; }线性插值比Slerp球形插值简单的多。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Unity之Vector3.Slerp球形插值原理介绍]]></title>
    <url>%2F2016%2F12%2F09%2Funity-zhi-vector3.slerp-qiu-xing-cha-zhi-yuan-li-jie-shao%2F</url>
    <content type="text"><![CDATA[先看API：public static Vector3 Slerp(Vector3 a, Vector3 b, float t);介绍：通过t数值在from和to之间插值。返回的向量的长度将被插值到from到to的长度之间。先上一个示意图：![这里写图片描述](https://img-blog.csdn.net/20161209112110583?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)上图的代码如下： private Vector3 mStart = new Vector3(-1, 1, 0); private Vector3 mEnd = new Vector3(1, 1, 0); // Update is called once per frame private void Update() { //绘制坐标轴 Debug.DrawLine(new Vector3(-100, 0, 0), new Vector3(100, 0, 0), Color.green); Debug.DrawLine(new Vector3(0, -100, 0), new Vector3(0, 100, 0), Color.green); Debug.DrawLine(new Vector3(0, 0, -100), new Vector3(0, 0, 100), Color.green); Debug.DrawLine(Vector3.zero, mStart, Color.red); Debug.DrawLine(Vector3.zero, mEnd, Color.red); Debug.DrawLine(mStart, mEnd, Color.red); for (int i = 1; i &lt; 10; ++i) { Vector3 drawVec = Vector3.Slerp(mStart, mEnd, 0.1f * i); Debug.DrawLine(Vector3.zero, drawVec, Color.yellow); } }下面先做几次实验来验证下面两个猜想：1、猜想一：插值的向量的长度是均匀线性变化的2、猜想二：插值的向量之间的角度是一样大的 上图验证：实验一：我们在上面代码的基础上加上输出： //加在for循环里 Debug.Log(&quot;插值向量长度：&quot;+ drawVec.magnitude); Debug.Log(&quot;角度：&quot; + Vector3.Angle(drawVec, mStart) / i);![这里写图片描述](https://img-blog.csdn.net/20161209112850532?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 我们发现虽然有误差，但是猜想基本成立，我们修改mStart和mEnd两向量继续实验。 实验二：mStart = (-1,0,0) mEnd = (0,3,4)![这里写图片描述](https://img-blog.csdn.net/20161209113159037?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 从上面可以看出两个猜想成立 这里额外要验证一个问题，就是当两个向量为平行向量时，结果如下，下面直接看图：（1）mStart = (-1, 0, 0) mEnd = (1, 0, 0)![这里写图片描述](https://img-blog.csdn.net/20161209114817399?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) （2）mStart = (-1, 1, 0) mEnd = (1, -1, 0)![这里写图片描述](https://img-blog.csdn.net/20161209115239713?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) （3）mStart = (-1, 1, 1) mEnd = (1, -1, -1)![这里写图片描述](https://img-blog.csdn.net/20161209134923381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 那么现在就可以利用这几个结论来自实现Slerp插值了。 下面直接上代码：代码关键内容如下：（1）旋转向量函数（2）旋转矩阵 /// &lt;summary&gt; /// 两个向量的球形插值 /// &lt;/summary&gt; /// &lt;param name=&quot;a&quot;&gt;向量a&lt;/param&gt; /// &lt;param name=&quot;b&quot;&gt;向量b&lt;/param&gt; /// &lt;param name=&quot;t&quot;&gt;t的值在[0..1]&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Vector3D Slerp(Vector3D a, Vector3D b, float t) { if (t &lt;= 0) { return a; } else if (t &gt;= 1) { return b; } Vector3D v = RotateTo(a, b, Vector3D.Angle(a, b) * t); //向量的长度，跟线性插值一样计算 float length = b.magnitude * t + a.magnitude * (1 - t); return v.normalized * length; } /// &lt;summary&gt; /// 将向量from向向量to旋转角度angle /// &lt;/summary&gt; /// &lt;param name=&quot;from&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;to&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;angle&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Vector3D RotateTo(Vector3D from, Vector3D to, float angle) { //如果两向量角度为0 if (Vector3D.Angle(from, to) == 0) { return from; } //旋转轴 Vector3D n = Vector3D.Cross(from, to); //旋转轴规范化 n.Normalize(); //旋转矩阵 Matrix4x4 rotateMatrix = new Matrix4x4(); //旋转的弧度 double radian = angle * Math.PI / 180; float cosAngle = (float)Math.Cos(radian); float sinAngle = (float)Math.Sin(radian); //矩阵的数据 //这里看不懂的自行科普矩阵知识 rotateMatrix.SetRow(0, new Vector4(n.x * n.x * (1 - cosAngle) + cosAngle, n.x * n.y * (1 - cosAngle) + n.z * sinAngle, n.x * n.z * (1 - cosAngle) - n.y * sinAngle, 0)); rotateMatrix.SetRow(1, new Vector4(n.x * n.y * (1 - cosAngle) - n.z * sinAngle, n.y * n.y * (1 - cosAngle) + cosAngle, n.y * n.z * (1 - cosAngle) + n.x * sinAngle, 0)); rotateMatrix.SetRow(2, new Vector4(n.x * n.z * (1 - cosAngle) + n.y * sinAngle, n.y * n.z * (1 - cosAngle) - n.x * sinAngle, n.z * n.z * (1 - cosAngle) + cosAngle, 0)); rotateMatrix.SetRow(3, new Vector4(0, 0, 0, 1)); Vector4 v = Vector3D.ToVector4(from); Vector3D vector = new Vector3D(); for (int i = 0; i &lt; 3; ++i) { for (int j = 0; j &lt; 3; j++) { vector[i] += v[j] * rotateMatrix[j, i]; } } return vector; } /// &lt;summary&gt; /// 将一个Vector3D转换为Vector4 /// &lt;/summary&gt; /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Vector4 ToVector4(Vector3D v) { return new Vector4(v.x, v.y, v.z, 0); } public Vector3 ToVector3() { return new Vector3(x, y, z); }这里暂时没有对两个向量共线反向的情况进行说明，不过主要实现已经给出来了。但是，我发现一点问题，看图：（1）v1 = new Vector3(0, 2, 0);v2 = new Vector3(5, 0, 0);![这里写图片描述](https://img-blog.csdn.net/20161211204127975?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) ok，正常 （2）v1 = new Vector3(3, 0, 0);v2 = new Vector3(0, 0, 5);![这里写图片描述](https://img-blog.csdn.net/20161211204257397?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) ok，正常 （3）在RotateTo函数中，数据不精确导致存在误差，也就是我打印v1和v2的叉乘 （图中黄色） 与 （图中红色向量）的叉乘存在误差，这样其实就是该函数的旋转轴不准确。 以上猜想以及代码实现 没有找到权威认证，如有异议，欢迎探讨。。。 补充：自己无聊利用Slerp插值画了下面这个图，纯属娱乐。。。![这里写图片描述](https://img-blog.csdn.net/20161212121854699?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Vector3.Slerp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI之Aspect Ratio Fitter组件介绍]]></title>
    <url>%2F2016%2F12%2F08%2Fugui-zhi-aspect-ratio-fitter-zu-jian-jie-shao%2F</url>
    <content type="text"><![CDATA[组件截图如下： 1、Aspect Mode：AspectMode枚举类型 public enum AspectMode { //不使用适合的纵横比 None, //让Height随着Width自动调节 WidthControlsHeight, //让Width随着Height自动调节 HeightControlsWidth, //宽度、高度、位置和锚点都会被自动调整，以使得该矩形拟合父物体的矩形内，同时保持宽高比例 FitInParent, //宽度、高度、位置和锚点都会被自动调整，以使得该矩形覆盖父物体的整个区域，同时保持宽高比 EnvelopeParent }2、Aspect Ratio：宽高比例，width/height 下面根据实际情况来介绍一下该组件。在我的工作中，遇到一种情况，玩家获得一些奖励，做成一个通用的UI界面，该界面通常包括以下东西：标题、获得按钮、中间是一排物品item，显然中间的一排物品item会用到水平布局，并且居中显示，每一个item又包括一个icon和一个text（显示count），如果此时存在某一个icon比其他的大些，就会显得很突兀，这个时候我就用到了该组件 给item预制件 中的icon 添加一个父物体，然后给icon加一个Aspect RatioFitter，AspectMode选用FitInParent，Aspect Ratio的值需要在代码中计算，因为我们在做这个UI的时候，肯定是根据数据来动态实例化这些item的，每一个icon的宽高比不一样，所以需要在代码中计算，代码如下： Rect rect = GetComponent&lt;Image&gt;().sprite.rect; AspectRatioFitter fitter = GetComponent&lt;AspectRatioFitter&gt;(); fitter.aspectRatio = rect.width / rect.height;这种做法就会保持icon的大小基本一致，当然如果美术团队出的物品图片资源都一致大小，咱们也就省去了这一步。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UGUI之布局实战——聊天系统]]></title>
    <url>%2F2016%2F11%2F30%2Fugui-zhi-bu-ju-shi-zhan-liao-tian-xi-tong%2F</url>
    <content type="text"><![CDATA[聊天系统中的UGUI布局常用的聊天系统内容包括以下几点：1、发言内容；2、发言人头像3、发言人名称4、语言聊天（本文不考虑该功能，与布局无关）5、表情（本文暂不考虑该功能，后续补充）（4.1）表情与文字混排，比如：PC端的QQ聊天（4.2）表情与文字分开，比如：移动端的QQ6、聊天模式：文本模式、气泡模式（5.1）文本模式：参与聊天的所有人均在左边（5.2）气泡模式：自己的气泡在左边，其余玩家的气泡在右边，如下图： 这里以气泡模式为例进行讲解：先上类似效果图： 先简单分析一下：这里分为三个预制件：（1）整个对话框作为一个预制件a（2）玩家自己的气泡作为一个预制件b（3）其余玩家的气泡作为一个预制件c然后预制件a对气泡用了垂直布局；预制件b和c做法类似，大小一致；预制件b和c中的气泡背景图片要随着文字内容变化而自动缩放，因此背景图片身上挂上一个VerticalLayout Group组件和Content Size Fitter组件，相关设置如下：然后将文字内容物体作为背景图片的子物体，并添加组件Content Size Fitter相关设置如下： 预制件b和c还有一点区别就是b（玩家自己）的Pivot为（1,1），预制件c（其他玩家）的Pivot为（0,1） 这样描述可能不太好理解，最后会直接给大家提供一个工程下载地址。 然后聊天框还支持滚动翻阅浏览前面的聊天记录，因此还需要Scroll Rect、Mask等组件 由于聊天窗口下方几个按钮和输入框不是布局的重点，这里就不做介绍，如有需要，后续给大家提供一个工程下载地址。 那么，布局实战——聊天系统就介绍到这里。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。 更新：Demo示意图如下：![这里写图片描述](https://img-blog.csdn.net/20170114224142012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 此时图中是空的聊天窗口，每发送或者收到一条聊天记录，只需要生成一个相应 的预制件并作为Content的子物体 ![这里写图片描述](https://img-blog.csdn.net/20170114224522158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 关于聊天系统的布局呢，根据设计不同布局也就不同，这里是将我工作中的一个聊天系统讲解给大家，具体详情如有兴趣欢迎点击链接： http://pan.baidu.com/s/1hrMxwf6 密码：6bss下载工程 我用的unity版本是5.3.7，工程所用美术资源非本人原创，请不要商用，仅限学习使用，如因此出现版权问题，与本人无关。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UGUI之Grid Layout Group组件介绍]]></title>
    <url>%2F2016%2F11%2F30%2Fugui-zhi-grid-layout-group-zu-jian-jie-shao%2F</url>
    <content type="text"><![CDATA[Grid Layout Group是LayoutGroup的子类 脚本属性截图如下： 1、Padding：RectOffset类型，矩形偏移，详解请戳 UGUI之Horizontal Layout Group组件介绍 2、Cell Size：Vector2类型，默认值为(100,100)，网格中的每个单元格的大小 [SerializeField] protected Vector2 m_CellSize = new Vector2(100, 100); public Vector2 cellSize { get { return m_CellSize; } set { SetProperty(ref m_CellSize, value); } }3、Spacing：这里的Spacing不同于水平布局、垂直布局，是Vector2类型，既然是网格布局，当然存在水平方向的间隔和垂直方向的间隔，这里也不做过多的介绍。 3、Start Corner：Corner枚举类型 public enum Corner { UpperLeft = 0, //左上角 UpperRight = 1, //右上角 LowerLeft = 2, //左下角 LowerRight = 3 //右下角 }第一个单元格放在哪个角落，默认为UpperLeft左上角 4、Start Axis：Axis枚举类型 public enum Axis { Horizontal = 0, //水平 Vertical = 1 //垂直 }（1）Horizontal：水平优先水平排列单元格（2）Vertical：垂直优先垂直排列单元格 5、Child Alignment：TextAnchor枚举类型，文本锚点，详解请戳 UGUI之Horizontal Layout Group组件介绍 6、Constraint：Constraint枚举类型 public enum Constraint { Flexible = 0, //不限制行数和列数 FixedColumnCount = 1, //约束指定数量的列数 FixedRowCount = 2 //约束指定数量的行数 }下面以几个截图来看看上面几个设置具体是怎样的作用：以下单元格物体加了一个Text来表示其编号，并且Hierarchy面板中的层级关系并未调整 图一：默认情况 图二：设置Start Corner为Upper Right 图三：设置Start Axis为Vertical 图四：设置Start Corner为Lower Left、Start Axis为Vertical 从以上图中不难看出这两个设置的使用用途。 实际开发中，我常与Content Size Fitter组件一起使用 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
      <tags>
        <tag>GridLayoutGroup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI之Vertical Layout Group组件介绍]]></title>
    <url>%2F2016%2F11%2F30%2Fugui-zhi-vertical-layout-group-zu-jian-jie-shao%2F</url>
    <content type="text"><![CDATA[VerticalLayoutGroup也是HorizontalOrVerticalLayoutGroup的子类，HorizontalOrVerticalLayoutGroup是LayoutGroup的子类，下面从源码中进行对比 namespace UnityEngine.UI { [AddComponentMenu(&quot;Layout/Horizontal Layout Group&quot;, 150)] public class HorizontalLayoutGroup : HorizontalOrVerticalLayoutGroup { protected HorizontalLayoutGroup() {} public override void CalculateLayoutInputHorizontal() { base.CalculateLayoutInputHorizontal(); CalcAlongAxis(0, false); } public override void CalculateLayoutInputVertical() { CalcAlongAxis(1, false); } public override void SetLayoutHorizontal() { SetChildrenAlongAxis(0, false); } public override void SetLayoutVertical() { SetChildrenAlongAxis(1, false); } } } namespace UnityEngine.UI { [AddComponentMenu(&quot;Layout/Vertical Layout Group&quot;, 151)] public class VerticalLayoutGroup : HorizontalOrVerticalLayoutGroup { protected VerticalLayoutGroup() {} public override void CalculateLayoutInputHorizontal() { base.CalculateLayoutInputHorizontal(); CalcAlongAxis(0, true); } public override void CalculateLayoutInputVertical() { CalcAlongAxis(1, true); } public override void SetLayoutHorizontal() { SetChildrenAlongAxis(0, true); } public override void SetLayoutVertical() { SetChildrenAlongAxis(1, true); } } }可以看出，唯一的区别就是四个重写的基方法里的调用的CalcAlongAxis、SetChildrenAlongAxis一个是false，一个是true，那么显然true表示是vertical，false表示horizontal 所以在这就不过多的对Vertical Layout Group组件做过多的介绍，用法跟 Horizontal LayoutGroup组件一样的用，如果对Horizontal Layout Group组件有不了解的，详情请点击这里 Horizontal LayoutGroup组件介绍 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
      <tags>
        <tag>VerticalLayoutGroup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI之Horizontal Layout Group组件介绍]]></title>
    <url>%2F2016%2F11%2F30%2Fugui-zhi-horizontal-layout-group-zu-jian-jie-shao%2F</url>
    <content type="text"><![CDATA[Horizontal LayoutGroup是HorizontalOrVerticalLayoutGroup的子类，HorizontalOrVerticalLayoutGroup又是LayoutGroup的子类 脚本截图如下： 图中包括以下属性：1、Padding：RectOffset类型，矩形偏移源码如下： public sealed class RectOffset { public RectOffset(); public RectOffset(int left, int right, int top, int bottom); ~RectOffset(); public int bottom { get; set; } //底边缘 public int horizontal { get; } //水平 public int left { get; set; } //左边缘 public int right { get; set; } //右边缘 public int top { get; set; } //顶边缘 public int vertical { get; } //垂直 public Rect Add(Rect rect); //向一个Rect添加边框偏移 public Rect Remove(Rect rect); //从一个Rect移除边框偏移 public override string ToString(); }如下面几个图中：图一：默认情况 图二：只改变Padding 当Padding中的边缘大小过大时，会自动缩放布局元素以保持布局元素均在边框内，从下图可以看出图三 2、Spacing：float类型布局元素之间的间隔 图四：只改变Spacing 当Spacing过大，会自动缩放布局元素以保持布局元素均在边框内，从下图可以看出布局元素宽度缩小了图五： 3、Child Alignment：TextAnchor枚举类型，文本锚点源码如下： public enum TextAnchor { UpperLeft = 0, //上左 UpperCenter = 1, //上中 UpperRight = 2, //上右 MiddleLeft = 3, //中左 MiddleCenter = 4, //中中 MiddleRight = 5, //中右 LowerLeft = 6, //下左 LowerCenter = 7, //下中 LowerRight = 8 //下右 }4、Child Force Expand：有两个可选（1）Width：是否强行扩大布局元素宽度以填补额外可用的空间（2）Height：是否强行扩大布局元素高度以填补额外可用的空间下面结合截图来说明：图六：勾选Width，填补宽度 图七：勾选Height，填补高度 图八：勾选Width和Height，填补宽度和高度 从以上三图结合图一默认图可以看出其具体效果 实际开发中，我经常结合Content Size Fitter组件一起使用 关于UI布局，大家开发的多了，就熟练了。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
      <tags>
        <tag>HorizontalLayoutGroup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI之Content Size Fitter组件]]></title>
    <url>%2F2016%2F11%2F29%2Fugui-zhi-content-size-fitter-zu-jian%2F</url>
    <content type="text"><![CDATA[具体属性截图： Horizontal Fit和VerticalFit均为UI.ContentSizeFitter.FitMode枚举类型，有三个值可选：Unconstrained，MinSize，PreferredSize Unconstrained：不执行任何调整MinSize：调整内容的最小大小PreferredSize：调整内容的首选大小，也就是会自动根据内容来调整大小 使用Content Size Fitter组件，RectTransform组件会发生响应的变化默认情况下RectTransform组件的Width 和 Height 可以在编辑模式下就行修改，当HorizontalFit不为Unconstrained时，Width不可修改，同理，Vertical Fit不为Unconstrained时，Height不可修改。 代码中，如果需要获取这个gameobject的Width 和Height，下图中提供了Preferred Height和PreferredWidth的获取方式 右下角可以看出数据的Source是Text组件，那么我们就可以通过GetComponent().PreferredWidth和PreferredHeight来获得。 当然不是所有情况，这两个数据的source都是Text！！！ 关于Content Size Fitter介绍暂时就到这里，后续完善 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
      <tags>
        <tag>ContentSizeFitter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI之Outline轮廓组件]]></title>
    <url>%2F2016%2F11%2F29%2Fugui-zhi-outline-lun-kuo-zu-jian%2F</url>
    <content type="text"><![CDATA[属性图如下： 从源码中可以看出，其实Outline是Shadow的子类，只不过Outline脚本在四个方向上调用了Shadow的ApplyShadowZeroAlloc函数而已，具体源码如下： using System.Collections.Generic; namespace UnityEngine.UI { [AddComponentMenu(&quot;UI/Effects/Outline&quot;, 15)] public class Outline : Shadow { protected Outline() {} public override void ModifyMesh(VertexHelper vh) { if (!IsActive()) return; var verts = ListPool&lt;UIVertex&gt;.Get(); vh.GetUIVertexStream(verts); var neededCpacity = verts.Count * 5; if (verts.Capacity &lt; neededCpacity) verts.Capacity = neededCpacity; var start = 0; var end = verts.Count; ApplyShadowZeroAlloc(verts, effectColor, start, verts.Count, effectDistance.x, effectDistance.y); start = end; end = verts.Count; ApplyShadowZeroAlloc(verts, effectColor, start, verts.Count, effectDistance.x, -effectDistance.y); start = end; end = verts.Count; ApplyShadowZeroAlloc(verts, effectColor, start, verts.Count, -effectDistance.x, effectDistance.y); start = end; end = verts.Count; ApplyShadowZeroAlloc(verts, effectColor, start, verts.Count, -effectDistance.x, -effectDistance.y); vh.Clear(); vh.AddUIVertexTriangleStream(verts); ListPool&lt;UIVertex&gt;.Release(verts); } } }这里不再赘述Outline组件的属性了，跟Shadow组件一样用，关于Shadow组件的介绍请戳这里 UGUI之Shadow阴影组件 相应的，使用Outline组件，顶点数加了四倍 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
      <tags>
        <tag>Outline</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI之Shadow阴影组件]]></title>
    <url>%2F2016%2F11%2F29%2Fugui-zhi-shadow-yin-ying-zu-jian%2F</url>
    <content type="text"><![CDATA[基本属性图如下： 1、Effect Color：阴影的颜色2、Effect Distance：阴影的偏移距离（1）x轴水平方向：当x=0时，阴影在水平方向上中间；当x&gt;0时，阴影在右方；当x&lt;0时，阴影在左方（2）y轴垂直方向：当y=0时，阴影在垂直方向上中间；当y&gt;0时，阴影在上方；当y&lt;0时，阴影在下方从上图中可见其效果，另外从源码中可以看出x、y的范围均为[-600,600]，当然实际应用中这个范围是绝对足够用的源码如下： public Vector2 effectDistance { get { return m_EffectDistance; } set { if (value.x &gt; 600) value.x = 600; if (value.x &lt; -600) value.x = -600; if (value.y &gt; 600) value.y = 600; if (value.y &lt; -600) value.y = -600; if (m_EffectDistance == value) return; m_EffectDistance = value; if (graphic != null) graphic.SetVerticesDirty(); } }3、Use Graphic Alpha：是否使用Graphic中的Alpha透明度（1）勾选：阴影的透明度会根据Graphic的透明度变化而变化注意看下面两个图中的颜色Alpha值以及左边的Text透明度变化图一 图二 从以上可以看出勾选Use Graphic Alpha的效果（2）不勾选：阴影的透明度不会根据Graphic的透明度变化而变化在图二的基础上，去掉Use Graphic Alpha的勾选，结果如下：阴影部分透明度并没有受到Graphic的影响源码部分：如果Use GraphicAlpha被勾选，m_UseGraphicAlpha为true，否则为false，从源码中可以如果m_UseGraphicAlpha为true，阴影的alpha经过了以下运算：newColor.a= (byte)((newColor.a * verts[i].color.a) / 255)； protected void ApplyShadowZeroAlloc(List&lt;UIVertex&gt; verts, Color32 color, int start, int end, float x, float y) { UIVertex vt; var neededCpacity = verts.Count * 2; if (verts.Capacity &lt; neededCpacity) verts.Capacity = neededCpacity; for (int i = start; i &lt; end; ++i) { vt = verts[i]; verts.Add(vt); Vector3 v = vt.position; v.x += x; v.y += y; vt.position = v; var newColor = color; if (m_UseGraphicAlpha) newColor.a = (byte)((newColor.a * verts[i].color.a) / 255); vt.color = newColor; verts[i] = vt; } }以上为Shadow结合Text组件的使用介绍，下面看一下Shadow结合Image组件的使用： 这里不再过多介绍，大家有兴趣，可以深入研究源码。 另外，使用Shadow会导致顶点数翻倍： 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
      <tags>
        <tag>Shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI之Text组件详解]]></title>
    <url>%2F2016%2F11%2F29%2Fugui-zhi-text-zu-jian-xiang-jie%2F</url>
    <content type="text"><![CDATA[基本属性如下图： Character：1、Font：字体2、Font Style：（1）Normal：正常（2）Bold：粗体（3）Italic：斜体（4）Bold And Italic：粗体+斜体3、Font Size：字体大小4、Line Spacing：行间距（注：Text组件没有提供修改字间距的属性，在前面写过修改字间距的脚本）5、Rich Text：富文本支持多组合的语法例如下面例子： Paragraph：1、Alignment： 前面三个按钮是水平方向（分别为左对齐、居中、右对齐），后面三个按钮是垂直方向（分别为顶对齐，居中，底对齐） 2、Align By Geometry：官方解释：Use the extents of glyph geometry to perform horizontal alignment rather thanglyph metrics.This can result in better fitting left and right alignment, but may result inincorrect positioning when attempting to overlay multiple fonts (such as aspecialized outline font) on top of each other.使用区段的字形几何执行水平对齐,而不是字形指标。这可以导致更好的拟合左和右对齐,但可能会导致不正确的定位当试图覆盖多个字体(如专业轮廓字体)上。 3、Horizontal Overflow：水平溢出（1）Wrap：文本将自动换行，当达到水平边界（2）Overflow：文本可以超出水平边界，继续显示4、Vertical Overflow：垂直溢出（1）Truncate：文本不显示超出垂直边界的部分（2）Overflow：文本可以超出垂直边界，继续显示5、Best Fit：勾选之后，编辑器发生变化，显示Min Size和Max Size（1）Min Size：最小大小（2）Max Size：最大大小当边框很大时，文字最大显示Max Size字体大小；当边框很小时，文字最小显示Min Size字体大小，边框显示不了MinSize字体大小就不再显示文字了。 Color：颜色 Material：材质 Raycast Target：来自类Graphic，当该项为false时，消息会透传]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
      <tags>
        <tag>Text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI之Text对齐至格子]]></title>
    <url>%2F2016%2F08%2F06%2Fugui-zhi-text-dui-qi-zhi-ge-zi%2F</url>
    <content type="text"><![CDATA[UGUI之Text对齐至格子背景：前几天有个需求：玩家输入的6位房间ID号，要对齐至背景格子图中，故将前面写的调整Text字间距勉强给boss用了 大致效果如图： 具体脚本代码如下: using UnityEngine; using System.Collections; using UnityEngine.UI; using System; using System.Collections.Generic; [AddComponentMenu(&quot;UI/Effects/TextAlignToGrid&quot;)] public class TextAlignToGrid : BaseMeshEffect { public RectTransform _gridBg; //格子背景 public int _gridNum; //我的格子数为6 private Vector2 _gridSize; //格子大小 private Vector3[] _targetFocusPos; //目标中心点，也就是对应的格子中心点 public override void ModifyMesh(VertexHelper vh) { if (!IsActive() || vh.currentVertCount == 0) { return; } if (_gridBg == null) { Debug.Log(&quot;Missing Grid Background&quot;); return; } Text text = GetComponent&lt;Text&gt;(); if (text == null) { Debug.Log(&quot;Missing Text component&quot;); return; } _gridSize = _gridBg.sizeDelta; int textLen = text.text.Length; Vector3[] textFocusPos = new Vector3[textLen]; List&lt;UIVertex&gt; vertexs = new List&lt;UIVertex&gt;(); _targetFocusPos = new Vector3[textLen]; vh.GetUIVertexStream(vertexs); //计算text各文字中心点坐标 for (int i = 0; i &lt; textLen; i++) { float x = (vertexs[i * 6].position.x + vertexs[i * 6 + 1].position.x) / 2; float y = (vertexs[i * 6 + 1].position.y + vertexs[i * 6 + 2].position.y) / 2; textFocusPos[i] = new Vector3(x, y, 0); } //根据格子大小_gridSize计算目标中心点 float xOffset = _gridSize.x / _gridNum; for (int i = 0; i &lt; textLen; i++) { float x = (float)(-_gridSize.x / 2 + xOffset * (i + 0.5)); _targetFocusPos[i] = new Vector3(x, 0, 0); } //计算text各顶点新坐标 UIVertex v = new UIVertex(); for (int i = 0; i &lt; vh.currentVertCount; i++) { vh.PopulateUIVertex(ref v, i); float x = v.position.x + _targetFocusPos[i / 4].x - textFocusPos[i / 4].x; float y = v.position.y + _targetFocusPos[i / 4].y - textFocusPos[i / 4].y; v.position = new Vector3(x, y, 0); vh.SetUIVertex(v, i); } } }]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
      <tags>
        <tag>Text对齐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI之修改Text字间距]]></title>
    <url>%2F2016%2F07%2F13%2Fugui-zhi-xiu-gai-text-zi-jian-ju%2F</url>
    <content type="text"><![CDATA[UGUI之修改Text字间距第一版先看效果图： 思路是修改顶点坐标 脚本TextSpacing代码如下： using UnityEngine; using System.Collections; using UnityEngine.UI; using System; using System.Collections.Generic; [AddComponentMenu(&quot;UI/Effects/TextSpacing&quot;)] public class TextSpacing : BaseMeshEffect { public float _textSpacing = 1f; public override void ModifyMesh(VertexHelper vh) { if (!IsActive() || vh.currentVertCount == 0) { return; } List&lt;UIVertex&gt; vertexs = new List&lt;UIVertex&gt;(); vh.GetUIVertexStream(vertexs); int indexCount = vh.currentIndexCount; UIVertex vt; for (int i = 6; i &lt; indexCount; i++) { //第一个字不用改变位置 vt = vertexs[i]; vt.position += new Vector3(_textSpacing * (i / 6), 0, 0); vertexs[i] = vt; //以下注意点与索引的对应关系 if (i % 6 &lt;= 2) { vh.SetUIVertex(vt, (i / 6) * 4 + i % 6); } if (i % 6 == 4) { vh.SetUIVertex(vt, (i / 6) * 4 + i % 6 - 1); } } } }第二版在第一版的基础上，解决了换行之后存在的问题先看第二版的效果图：![这里写图片描述](https://img-blog.csdn.net/20170508115729311?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 直接上源码： using UnityEngine; using System.Collections; using UnityEngine.UI; using System; using System.Collections.Generic; public class Line { private int _startVertexIndex = 0; /// &lt;summary&gt; /// 起点索引 /// &lt;/summary&gt; public int StartVertexIndex { get { return _startVertexIndex; } } private int _endVertexIndex = 0; /// &lt;summary&gt; /// 终点索引 /// &lt;/summary&gt; public int EndVertexIndex { get { return _endVertexIndex; } } private int _vertexCount = 0; /// &lt;summary&gt; /// 该行占的点数目 /// &lt;/summary&gt; public int VertexCount { get { return _vertexCount; } } public Line(int startVertexIndex,int length) { _startVertexIndex = startVertexIndex; _endVertexIndex = length * 6 - 1 + startVertexIndex; _vertexCount = length * 6; } } [AddComponentMenu(&quot;UI/Effects/TextSpacing&quot;)] public class TextSpacing : BaseMeshEffect { public float _textSpacing = 1f; public override void ModifyMesh(VertexHelper vh) { if (!IsActive() || vh.currentVertCount == 0) { return; } Text text = GetComponent&lt;Text&gt;(); if (text == null) { Debug.LogError(&quot;Missing Text component&quot;); return; } List&lt;UIVertex&gt; vertexs = new List&lt;UIVertex&gt;(); vh.GetUIVertexStream(vertexs); int indexCount = vh.currentIndexCount; string[] lineTexts = text.text.Split(&apos;\n&apos;); Line[] lines = new Line[lineTexts.Length]; //根据lines数组中各个元素的长度计算每一行中第一个点的索引，每个字、字母、空母均占6个点 for (int i = 0; i &lt; lines.Length; i++) { //除最后一行外，vertexs对于前面几行都有回车符占了6个点 if (i == 0) { lines[i] = new Line(0, lineTexts[i].Length + 1); } else if(i &gt; 0 &amp;&amp; i &lt; lines.Length - 1) { lines[i] = new Line(lines[i - 1].EndVertexIndex + 1, lineTexts[i].Length + 1); } else { lines[i] = new Line(lines[i - 1].EndVertexIndex + 1, lineTexts[i].Length); } } UIVertex vt; for (int i = 0; i &lt; lines.Length; i++) { for (int j = lines[i].StartVertexIndex + 6; j &lt;= lines[i].EndVertexIndex; j++) { if (j &lt; 0 || j &gt;= vertexs.Count) { continue; } vt = vertexs[j]; vt.position += new Vector3(_textSpacing * ((j - lines[i].StartVertexIndex) / 6), 0, 0); vertexs[j] = vt; //以下注意点与索引的对应关系 if (j % 6 &lt;= 2) { vh.SetUIVertex(vt, (j / 6) * 4 + j % 6); } if (j % 6 == 4) { vh.SetUIVertex(vt, (j / 6) * 4 + j % 6 - 1); } } } } }思路是在第一版的基础上，对每一行都顶点坐标做处理。 以上知识分享，如有错误，欢迎指出，共同学习，共同进步。]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UGUI之Text镜像效果]]></title>
    <url>%2F2016%2F07%2F11%2Fugui-zhi-text-jing-xiang-xiao-guo%2F</url>
    <content type="text"><![CDATA[UGUI之Text镜像效果先上效果图： 脚本Mirror直接挂在Text下，distance是镜像距离 Mirror脚本如下： using UnityEngine; using System.Collections; using UnityEngine.UI; using System; using System.Collections.Generic; [AddComponentMenu(&quot;UI/Effects/Mirror&quot;)] public class Mirror : BaseMeshEffect { //距离，限制范围0-30 [Range(0,30)] public float distance; public override void ModifyMesh(VertexHelper vh) { if (!IsActive() || vh.currentVertCount == 0) { return; } List&lt;UIVertex&gt; vertexs = new List&lt;UIVertex&gt;(); vh.GetUIVertexStream(vertexs); UIVertex vt; int count = vertexs.Count; float miny = vertexs[0].position.y; float maxy = vertexs[0].position.y; for (int i = 1; i &lt; count; i++) { if (vertexs[i].position.y &lt; miny) { miny = vertexs[i].position.y; } else if (vertexs[i].position.y &gt; maxy) { maxy = vertexs[i].position.y; } } float uiElementHeight = maxy - miny; float mirrorMinY = -maxy + 2 * miny - distance; Color32 top = GetComponent&lt;Text&gt;().color; Color32 bottom = new Color(top.r, top.g, top.b, 0); for (int i = 0; i &lt; count; i++) { vt = vertexs[i]; vertexs.Add(vt); Vector3 v = vt.position; v.y = -v.y + 2 * miny - distance; vt.position = v; //透明度效果 vt.color = Color32.Lerp(bottom, top, (vt.position.y - mirrorMinY) / uiElementHeight); vertexs[i + count] = vt; } vh.Clear(); vh.AddUIVertexTriangleStream(vertexs); } }]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
      <tags>
        <tag>Text镜像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI之Text彩虹字]]></title>
    <url>%2F2016%2F07%2F08%2Fugui-zhi-text-cai-hong-zi%2F</url>
    <content type="text"><![CDATA[UGUI之Text彩虹字脚本Rainbow直接挂在Text下 使得每个字母或者汉字均为一种随机颜色 Rainbow脚本如下： using UnityEngine; using System.Collections; using UnityEngine.UI; using System.Collections.Generic; [AddComponentMenu(&quot;UI/Effects/Gradient&quot;)] public class Rainbow : BaseMeshEffect { private Color32[] colors; public override void ModifyMesh(VertexHelper vh) { if (!IsActive() || vh.currentVertCount == 0) { return; } List&lt;UIVertex&gt; vertices = new List&lt;UIVertex&gt;(); vh.GetUIVertexStream(vertices); int count = vertices.Count; colors = new Color32[count / 6]; for (int i = 0; i &lt; colors.Length; i++) { //随机颜色 float r = Random.value; float g = Random.value; float b = Random.value; colors[i] = new Color(r, g, b); } UIVertex v = new UIVertex(); for (int i = 0; i &lt; vh.currentVertCount; i++) { vh.PopulateUIVertex(ref v, i); v.color = colors[i / 4]; vh.SetUIVertex(v, i); } } }]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
      <tags>
        <tag>Text彩虹字</tag>
      </tags>
  </entry>
</search>
